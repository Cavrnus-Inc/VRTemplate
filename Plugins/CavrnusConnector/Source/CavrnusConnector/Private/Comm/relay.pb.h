// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: relay.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_relay_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_relay_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "relay_types.pb.h"
#include "properties.pb.h"
#include "common.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_relay_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_relay_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_relay_2eproto;
namespace ServerData {
class AllJoinableSpacesReq;
struct AllJoinableSpacesReqDefaultTypeInternal;
extern AllJoinableSpacesReqDefaultTypeInternal _AllJoinableSpacesReq_default_instance_;
class AllJoinableSpacesResp;
struct AllJoinableSpacesRespDefaultTypeInternal;
extern AllJoinableSpacesRespDefaultTypeInternal _AllJoinableSpacesResp_default_instance_;
class AuthenticateApiKeyReq;
struct AuthenticateApiKeyReqDefaultTypeInternal;
extern AuthenticateApiKeyReqDefaultTypeInternal _AuthenticateApiKeyReq_default_instance_;
class AuthenticateDeviceCodeBeginReq;
struct AuthenticateDeviceCodeBeginReqDefaultTypeInternal;
extern AuthenticateDeviceCodeBeginReqDefaultTypeInternal _AuthenticateDeviceCodeBeginReq_default_instance_;
class AuthenticateDeviceCodeBeginResp;
struct AuthenticateDeviceCodeBeginRespDefaultTypeInternal;
extern AuthenticateDeviceCodeBeginRespDefaultTypeInternal _AuthenticateDeviceCodeBeginResp_default_instance_;
class AuthenticateDeviceCodeConcludeReq;
struct AuthenticateDeviceCodeConcludeReqDefaultTypeInternal;
extern AuthenticateDeviceCodeConcludeReqDefaultTypeInternal _AuthenticateDeviceCodeConcludeReq_default_instance_;
class AuthenticateGuestReq;
struct AuthenticateGuestReqDefaultTypeInternal;
extern AuthenticateGuestReqDefaultTypeInternal _AuthenticateGuestReq_default_instance_;
class AuthenticateReq;
struct AuthenticateReqDefaultTypeInternal;
extern AuthenticateReqDefaultTypeInternal _AuthenticateReq_default_instance_;
class AuthenticateResp;
struct AuthenticateRespDefaultTypeInternal;
extern AuthenticateRespDefaultTypeInternal _AuthenticateResp_default_instance_;
class AuthenticateTokenReq;
struct AuthenticateTokenReqDefaultTypeInternal;
extern AuthenticateTokenReqDefaultTypeInternal _AuthenticateTokenReq_default_instance_;
class AuthenticateWithLinkReq;
struct AuthenticateWithLinkReqDefaultTypeInternal;
extern AuthenticateWithLinkReqDefaultTypeInternal _AuthenticateWithLinkReq_default_instance_;
class AuthenticateWithLinkResp;
struct AuthenticateWithLinkRespDefaultTypeInternal;
extern AuthenticateWithLinkRespDefaultTypeInternal _AuthenticateWithLinkResp_default_instance_;
class BeginTransientPropertyUpdate;
struct BeginTransientPropertyUpdateDefaultTypeInternal;
extern BeginTransientPropertyUpdateDefaultTypeInternal _BeginTransientPropertyUpdate_default_instance_;
class CancelTransientPropertyUpdate;
struct CancelTransientPropertyUpdateDefaultTypeInternal;
extern CancelTransientPropertyUpdateDefaultTypeInternal _CancelTransientPropertyUpdate_default_instance_;
class ChatAdded;
struct ChatAddedDefaultTypeInternal;
extern ChatAddedDefaultTypeInternal _ChatAdded_default_instance_;
class ChatBase;
struct ChatBaseDefaultTypeInternal;
extern ChatBaseDefaultTypeInternal _ChatBase_default_instance_;
class ChatRemoved;
struct ChatRemovedDefaultTypeInternal;
extern ChatRemovedDefaultTypeInternal _ChatRemoved_default_instance_;
class ChatUpdated;
struct ChatUpdatedDefaultTypeInternal;
extern ChatUpdatedDefaultTypeInternal _ChatUpdated_default_instance_;
class CheckServerStatusReq;
struct CheckServerStatusReqDefaultTypeInternal;
extern CheckServerStatusReqDefaultTypeInternal _CheckServerStatusReq_default_instance_;
class CheckServerStatusResp;
struct CheckServerStatusRespDefaultTypeInternal;
extern CheckServerStatusRespDefaultTypeInternal _CheckServerStatusResp_default_instance_;
class ConstructApiKeyReq;
struct ConstructApiKeyReqDefaultTypeInternal;
extern ConstructApiKeyReqDefaultTypeInternal _ConstructApiKeyReq_default_instance_;
class ConstructApiKeyResp;
struct ConstructApiKeyRespDefaultTypeInternal;
extern ConstructApiKeyRespDefaultTypeInternal _ConstructApiKeyResp_default_instance_;
class ContentDestinationFolderReq;
struct ContentDestinationFolderReqDefaultTypeInternal;
extern ContentDestinationFolderReqDefaultTypeInternal _ContentDestinationFolderReq_default_instance_;
class ContentDestinationFolderResp;
struct ContentDestinationFolderRespDefaultTypeInternal;
extern ContentDestinationFolderRespDefaultTypeInternal _ContentDestinationFolderResp_default_instance_;
class ContinueTransientPropertyUpdate;
struct ContinueTransientPropertyUpdateDefaultTypeInternal;
extern ContinueTransientPropertyUpdateDefaultTypeInternal _ContinueTransientPropertyUpdate_default_instance_;
class CreateSpaceReq;
struct CreateSpaceReqDefaultTypeInternal;
extern CreateSpaceReqDefaultTypeInternal _CreateSpaceReq_default_instance_;
class CreateSpaceResp;
struct CreateSpaceRespDefaultTypeInternal;
extern CreateSpaceRespDefaultTypeInternal _CreateSpaceResp_default_instance_;
class DefinePropertyDefaultValue;
struct DefinePropertyDefaultValueDefaultTypeInternal;
extern DefinePropertyDefaultValueDefaultTypeInternal _DefinePropertyDefaultValue_default_instance_;
class DeleteSpaceReq;
struct DeleteSpaceReqDefaultTypeInternal;
extern DeleteSpaceReqDefaultTypeInternal _DeleteSpaceReq_default_instance_;
class EndForceKeepAlive;
struct EndForceKeepAliveDefaultTypeInternal;
extern EndForceKeepAliveDefaultTypeInternal _EndForceKeepAlive_default_instance_;
class ExitAllSpacesAndLogoutReq;
struct ExitAllSpacesAndLogoutReqDefaultTypeInternal;
extern ExitAllSpacesAndLogoutReqDefaultTypeInternal _ExitAllSpacesAndLogoutReq_default_instance_;
class ExitAllSpacesAndLogoutResp;
struct ExitAllSpacesAndLogoutRespDefaultTypeInternal;
extern ExitAllSpacesAndLogoutRespDefaultTypeInternal _ExitAllSpacesAndLogoutResp_default_instance_;
class FetchAllUploadedContentReq;
struct FetchAllUploadedContentReqDefaultTypeInternal;
extern FetchAllUploadedContentReqDefaultTypeInternal _FetchAllUploadedContentReq_default_instance_;
class FetchAllUploadedContentResp;
struct FetchAllUploadedContentRespDefaultTypeInternal;
extern FetchAllUploadedContentRespDefaultTypeInternal _FetchAllUploadedContentResp_default_instance_;
class FetchAllUserAccountsReq;
struct FetchAllUserAccountsReqDefaultTypeInternal;
extern FetchAllUserAccountsReqDefaultTypeInternal _FetchAllUserAccountsReq_default_instance_;
class FetchAllUserAccountsResp;
struct FetchAllUserAccountsRespDefaultTypeInternal;
extern FetchAllUserAccountsRespDefaultTypeInternal _FetchAllUserAccountsResp_default_instance_;
class FetchAllUserRolesReq;
struct FetchAllUserRolesReqDefaultTypeInternal;
extern FetchAllUserRolesReqDefaultTypeInternal _FetchAllUserRolesReq_default_instance_;
class FetchAllUserRolesResp;
struct FetchAllUserRolesRespDefaultTypeInternal;
extern FetchAllUserRolesRespDefaultTypeInternal _FetchAllUserRolesResp_default_instance_;
class FetchFileByIdCompletedResp;
struct FetchFileByIdCompletedRespDefaultTypeInternal;
extern FetchFileByIdCompletedRespDefaultTypeInternal _FetchFileByIdCompletedResp_default_instance_;
class FetchFileByIdFailureResp;
struct FetchFileByIdFailureRespDefaultTypeInternal;
extern FetchFileByIdFailureRespDefaultTypeInternal _FetchFileByIdFailureResp_default_instance_;
class FetchFileByIdProgressResp;
struct FetchFileByIdProgressRespDefaultTypeInternal;
extern FetchFileByIdProgressRespDefaultTypeInternal _FetchFileByIdProgressResp_default_instance_;
class FetchFileByIdReq;
struct FetchFileByIdReqDefaultTypeInternal;
extern FetchFileByIdReqDefaultTypeInternal _FetchFileByIdReq_default_instance_;
class FetchRemoteContentInfoReq;
struct FetchRemoteContentInfoReqDefaultTypeInternal;
extern FetchRemoteContentInfoReqDefaultTypeInternal _FetchRemoteContentInfoReq_default_instance_;
class FetchRemoteContentInfoResp;
struct FetchRemoteContentInfoRespDefaultTypeInternal;
extern FetchRemoteContentInfoRespDefaultTypeInternal _FetchRemoteContentInfoResp_default_instance_;
class FinalizeTransientPropertyUpdate;
struct FinalizeTransientPropertyUpdateDefaultTypeInternal;
extern FinalizeTransientPropertyUpdateDefaultTypeInternal _FinalizeTransientPropertyUpdate_default_instance_;
class GenericResp;
struct GenericRespDefaultTypeInternal;
extern GenericRespDefaultTypeInternal _GenericResp_default_instance_;
class GetAudioInputDevicesReq;
struct GetAudioInputDevicesReqDefaultTypeInternal;
extern GetAudioInputDevicesReqDefaultTypeInternal _GetAudioInputDevicesReq_default_instance_;
class GetAudioInputDevicesResp;
struct GetAudioInputDevicesRespDefaultTypeInternal;
extern GetAudioInputDevicesRespDefaultTypeInternal _GetAudioInputDevicesResp_default_instance_;
class GetAudioOutputDevicesReq;
struct GetAudioOutputDevicesReqDefaultTypeInternal;
extern GetAudioOutputDevicesReqDefaultTypeInternal _GetAudioOutputDevicesReq_default_instance_;
class GetAudioOutputDevicesResp;
struct GetAudioOutputDevicesRespDefaultTypeInternal;
extern GetAudioOutputDevicesRespDefaultTypeInternal _GetAudioOutputDevicesResp_default_instance_;
class GetSpaceInfoReq;
struct GetSpaceInfoReqDefaultTypeInternal;
extern GetSpaceInfoReqDefaultTypeInternal _GetSpaceInfoReq_default_instance_;
class GetSpaceInfoResp;
struct GetSpaceInfoRespDefaultTypeInternal;
extern GetSpaceInfoRespDefaultTypeInternal _GetSpaceInfoResp_default_instance_;
class GetVideoInputDevicesReq;
struct GetVideoInputDevicesReqDefaultTypeInternal;
extern GetVideoInputDevicesReqDefaultTypeInternal _GetVideoInputDevicesReq_default_instance_;
class GetVideoInputDevicesResp;
struct GetVideoInputDevicesRespDefaultTypeInternal;
extern GetVideoInputDevicesRespDefaultTypeInternal _GetVideoInputDevicesResp_default_instance_;
class InviteUserAccountToSpaceReq;
struct InviteUserAccountToSpaceReqDefaultTypeInternal;
extern InviteUserAccountToSpaceReqDefaultTypeInternal _InviteUserAccountToSpaceReq_default_instance_;
class JoinSpaceFromIdReq;
struct JoinSpaceFromIdReqDefaultTypeInternal;
extern JoinSpaceFromIdReqDefaultTypeInternal _JoinSpaceFromIdReq_default_instance_;
class JoinSpaceFromIdResp;
struct JoinSpaceFromIdRespDefaultTypeInternal;
extern JoinSpaceFromIdRespDefaultTypeInternal _JoinSpaceFromIdResp_default_instance_;
class KeepAlive;
struct KeepAliveDefaultTypeInternal;
extern KeepAliveDefaultTypeInternal _KeepAlive_default_instance_;
class LocalPropertyHandledResp;
struct LocalPropertyHandledRespDefaultTypeInternal;
extern LocalPropertyHandledRespDefaultTypeInternal _LocalPropertyHandledResp_default_instance_;
class ObjectAdded;
struct ObjectAddedDefaultTypeInternal;
extern ObjectAddedDefaultTypeInternal _ObjectAdded_default_instance_;
class ObjectRemoved;
struct ObjectRemovedDefaultTypeInternal;
extern ObjectRemovedDefaultTypeInternal _ObjectRemoved_default_instance_;
class PermissionStatus;
struct PermissionStatusDefaultTypeInternal;
extern PermissionStatusDefaultTypeInternal _PermissionStatus_default_instance_;
class PermissionStatusReq;
struct PermissionStatusReqDefaultTypeInternal;
extern PermissionStatusReqDefaultTypeInternal _PermissionStatusReq_default_instance_;
class PostChat;
struct PostChatDefaultTypeInternal;
extern PostChatDefaultTypeInternal _PostChat_default_instance_;
class PostCreateObject;
struct PostCreateObjectDefaultTypeInternal;
extern PostCreateObjectDefaultTypeInternal _PostCreateObject_default_instance_;
class PostDataCacheUpdate;
struct PostDataCacheUpdateDefaultTypeInternal;
extern PostDataCacheUpdateDefaultTypeInternal _PostDataCacheUpdate_default_instance_;
class PostPropertyUpdate;
struct PostPropertyUpdateDefaultTypeInternal;
extern PostPropertyUpdateDefaultTypeInternal _PostPropertyUpdate_default_instance_;
class PostRemoveObject;
struct PostRemoveObjectDefaultTypeInternal;
extern PostRemoveObjectDefaultTypeInternal _PostRemoveObject_default_instance_;
class PropMetadataStatus;
struct PropMetadataStatusDefaultTypeInternal;
extern PropMetadataStatusDefaultTypeInternal _PropMetadataStatus_default_instance_;
class PropertyValue;
struct PropertyValueDefaultTypeInternal;
extern PropertyValueDefaultTypeInternal _PropertyValue_default_instance_;
class PropertyValueStatus;
struct PropertyValueStatusDefaultTypeInternal;
extern PropertyValueStatusDefaultTypeInternal _PropertyValueStatus_default_instance_;
class QueryAiReq;
struct QueryAiReqDefaultTypeInternal;
extern QueryAiReqDefaultTypeInternal _QueryAiReq_default_instance_;
class QueryAiResp;
struct QueryAiRespDefaultTypeInternal;
extern QueryAiRespDefaultTypeInternal _QueryAiResp_default_instance_;
class RelayClientMessage;
struct RelayClientMessageDefaultTypeInternal;
extern RelayClientMessageDefaultTypeInternal _RelayClientMessage_default_instance_;
class RelayClientMessageBatch;
struct RelayClientMessageBatchDefaultTypeInternal;
extern RelayClientMessageBatchDefaultTypeInternal _RelayClientMessageBatch_default_instance_;
class RelayRemoteMessage;
struct RelayRemoteMessageDefaultTypeInternal;
extern RelayRemoteMessageDefaultTypeInternal _RelayRemoteMessage_default_instance_;
class RelayRemoteMessageBatch;
struct RelayRemoteMessageBatchDefaultTypeInternal;
extern RelayRemoteMessageBatchDefaultTypeInternal _RelayRemoteMessageBatch_default_instance_;
class RemoteContentAdded;
struct RemoteContentAddedDefaultTypeInternal;
extern RemoteContentAddedDefaultTypeInternal _RemoteContentAdded_default_instance_;
class RemoteContentRemoved;
struct RemoteContentRemovedDefaultTypeInternal;
extern RemoteContentRemovedDefaultTypeInternal _RemoteContentRemoved_default_instance_;
class RemoveUserAccountFromSpaceReq;
struct RemoveUserAccountFromSpaceReqDefaultTypeInternal;
extern RemoveUserAccountFromSpaceReqDefaultTypeInternal _RemoveUserAccountFromSpaceReq_default_instance_;
class RenameSpaceReq;
struct RenameSpaceReqDefaultTypeInternal;
extern RenameSpaceReqDefaultTypeInternal _RenameSpaceReq_default_instance_;
class ServerMessage;
struct ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
class SetAudioInputDeviceReq;
struct SetAudioInputDeviceReqDefaultTypeInternal;
extern SetAudioInputDeviceReqDefaultTypeInternal _SetAudioInputDeviceReq_default_instance_;
class SetAudioOutputDeviceReq;
struct SetAudioOutputDeviceReqDefaultTypeInternal;
extern SetAudioOutputDeviceReqDefaultTypeInternal _SetAudioOutputDeviceReq_default_instance_;
class SetForceKeepAlive;
struct SetForceKeepAliveDefaultTypeInternal;
extern SetForceKeepAliveDefaultTypeInternal _SetForceKeepAlive_default_instance_;
class SetVideoInputDeviceReq;
struct SetVideoInputDeviceReqDefaultTypeInternal;
extern SetVideoInputDeviceReqDefaultTypeInternal _SetVideoInputDeviceReq_default_instance_;
class ShutdownSpaceConnectionReq;
struct ShutdownSpaceConnectionReqDefaultTypeInternal;
extern ShutdownSpaceConnectionReqDefaultTypeInternal _ShutdownSpaceConnectionReq_default_instance_;
class ShutdownSpaceConnectionResp;
struct ShutdownSpaceConnectionRespDefaultTypeInternal;
extern ShutdownSpaceConnectionRespDefaultTypeInternal _ShutdownSpaceConnectionResp_default_instance_;
class SpaceConnectionStatus;
struct SpaceConnectionStatusDefaultTypeInternal;
extern SpaceConnectionStatusDefaultTypeInternal _SpaceConnectionStatus_default_instance_;
class StatusMessage;
struct StatusMessageDefaultTypeInternal;
extern StatusMessageDefaultTypeInternal _StatusMessage_default_instance_;
class TransformPropertyValue;
struct TransformPropertyValueDefaultTypeInternal;
extern TransformPropertyValueDefaultTypeInternal _TransformPropertyValue_default_instance_;
class UpdateLocalUserCoPresence;
struct UpdateLocalUserCoPresenceDefaultTypeInternal;
extern UpdateLocalUserCoPresenceDefaultTypeInternal _UpdateLocalUserCoPresence_default_instance_;
class UpdateLocalUserMuted;
struct UpdateLocalUserMutedDefaultTypeInternal;
extern UpdateLocalUserMutedDefaultTypeInternal _UpdateLocalUserMuted_default_instance_;
class UpdateLocalUserStreamState;
struct UpdateLocalUserStreamStateDefaultTypeInternal;
extern UpdateLocalUserStreamStateDefaultTypeInternal _UpdateLocalUserStreamState_default_instance_;
class UpdateThumbnailForSpaceReq;
struct UpdateThumbnailForSpaceReqDefaultTypeInternal;
extern UpdateThumbnailForSpaceReqDefaultTypeInternal _UpdateThumbnailForSpaceReq_default_instance_;
class UpdateTime;
struct UpdateTimeDefaultTypeInternal;
extern UpdateTimeDefaultTypeInternal _UpdateTime_default_instance_;
class UploadLocalFileProgressResp;
struct UploadLocalFileProgressRespDefaultTypeInternal;
extern UploadLocalFileProgressRespDefaultTypeInternal _UploadLocalFileProgressResp_default_instance_;
class UploadLocalFileReq;
struct UploadLocalFileReqDefaultTypeInternal;
extern UploadLocalFileReqDefaultTypeInternal _UploadLocalFileReq_default_instance_;
class UploadLocalFileResp;
struct UploadLocalFileRespDefaultTypeInternal;
extern UploadLocalFileRespDefaultTypeInternal _UploadLocalFileResp_default_instance_;
class UserAdded;
struct UserAddedDefaultTypeInternal;
extern UserAddedDefaultTypeInternal _UserAdded_default_instance_;
class UserRemoved;
struct UserRemovedDefaultTypeInternal;
extern UserRemovedDefaultTypeInternal _UserRemoved_default_instance_;
class UserVideoFrame;
struct UserVideoFrameDefaultTypeInternal;
extern UserVideoFrameDefaultTypeInternal _UserVideoFrame_default_instance_;
}  // namespace ServerData
PROTOBUF_NAMESPACE_OPEN
template<> ::ServerData::AllJoinableSpacesReq* Arena::CreateMaybeMessage<::ServerData::AllJoinableSpacesReq>(Arena*);
template<> ::ServerData::AllJoinableSpacesResp* Arena::CreateMaybeMessage<::ServerData::AllJoinableSpacesResp>(Arena*);
template<> ::ServerData::AuthenticateApiKeyReq* Arena::CreateMaybeMessage<::ServerData::AuthenticateApiKeyReq>(Arena*);
template<> ::ServerData::AuthenticateDeviceCodeBeginReq* Arena::CreateMaybeMessage<::ServerData::AuthenticateDeviceCodeBeginReq>(Arena*);
template<> ::ServerData::AuthenticateDeviceCodeBeginResp* Arena::CreateMaybeMessage<::ServerData::AuthenticateDeviceCodeBeginResp>(Arena*);
template<> ::ServerData::AuthenticateDeviceCodeConcludeReq* Arena::CreateMaybeMessage<::ServerData::AuthenticateDeviceCodeConcludeReq>(Arena*);
template<> ::ServerData::AuthenticateGuestReq* Arena::CreateMaybeMessage<::ServerData::AuthenticateGuestReq>(Arena*);
template<> ::ServerData::AuthenticateReq* Arena::CreateMaybeMessage<::ServerData::AuthenticateReq>(Arena*);
template<> ::ServerData::AuthenticateResp* Arena::CreateMaybeMessage<::ServerData::AuthenticateResp>(Arena*);
template<> ::ServerData::AuthenticateTokenReq* Arena::CreateMaybeMessage<::ServerData::AuthenticateTokenReq>(Arena*);
template<> ::ServerData::AuthenticateWithLinkReq* Arena::CreateMaybeMessage<::ServerData::AuthenticateWithLinkReq>(Arena*);
template<> ::ServerData::AuthenticateWithLinkResp* Arena::CreateMaybeMessage<::ServerData::AuthenticateWithLinkResp>(Arena*);
template<> ::ServerData::BeginTransientPropertyUpdate* Arena::CreateMaybeMessage<::ServerData::BeginTransientPropertyUpdate>(Arena*);
template<> ::ServerData::CancelTransientPropertyUpdate* Arena::CreateMaybeMessage<::ServerData::CancelTransientPropertyUpdate>(Arena*);
template<> ::ServerData::ChatAdded* Arena::CreateMaybeMessage<::ServerData::ChatAdded>(Arena*);
template<> ::ServerData::ChatBase* Arena::CreateMaybeMessage<::ServerData::ChatBase>(Arena*);
template<> ::ServerData::ChatRemoved* Arena::CreateMaybeMessage<::ServerData::ChatRemoved>(Arena*);
template<> ::ServerData::ChatUpdated* Arena::CreateMaybeMessage<::ServerData::ChatUpdated>(Arena*);
template<> ::ServerData::CheckServerStatusReq* Arena::CreateMaybeMessage<::ServerData::CheckServerStatusReq>(Arena*);
template<> ::ServerData::CheckServerStatusResp* Arena::CreateMaybeMessage<::ServerData::CheckServerStatusResp>(Arena*);
template<> ::ServerData::ConstructApiKeyReq* Arena::CreateMaybeMessage<::ServerData::ConstructApiKeyReq>(Arena*);
template<> ::ServerData::ConstructApiKeyResp* Arena::CreateMaybeMessage<::ServerData::ConstructApiKeyResp>(Arena*);
template<> ::ServerData::ContentDestinationFolderReq* Arena::CreateMaybeMessage<::ServerData::ContentDestinationFolderReq>(Arena*);
template<> ::ServerData::ContentDestinationFolderResp* Arena::CreateMaybeMessage<::ServerData::ContentDestinationFolderResp>(Arena*);
template<> ::ServerData::ContinueTransientPropertyUpdate* Arena::CreateMaybeMessage<::ServerData::ContinueTransientPropertyUpdate>(Arena*);
template<> ::ServerData::CreateSpaceReq* Arena::CreateMaybeMessage<::ServerData::CreateSpaceReq>(Arena*);
template<> ::ServerData::CreateSpaceResp* Arena::CreateMaybeMessage<::ServerData::CreateSpaceResp>(Arena*);
template<> ::ServerData::DefinePropertyDefaultValue* Arena::CreateMaybeMessage<::ServerData::DefinePropertyDefaultValue>(Arena*);
template<> ::ServerData::DeleteSpaceReq* Arena::CreateMaybeMessage<::ServerData::DeleteSpaceReq>(Arena*);
template<> ::ServerData::EndForceKeepAlive* Arena::CreateMaybeMessage<::ServerData::EndForceKeepAlive>(Arena*);
template<> ::ServerData::ExitAllSpacesAndLogoutReq* Arena::CreateMaybeMessage<::ServerData::ExitAllSpacesAndLogoutReq>(Arena*);
template<> ::ServerData::ExitAllSpacesAndLogoutResp* Arena::CreateMaybeMessage<::ServerData::ExitAllSpacesAndLogoutResp>(Arena*);
template<> ::ServerData::FetchAllUploadedContentReq* Arena::CreateMaybeMessage<::ServerData::FetchAllUploadedContentReq>(Arena*);
template<> ::ServerData::FetchAllUploadedContentResp* Arena::CreateMaybeMessage<::ServerData::FetchAllUploadedContentResp>(Arena*);
template<> ::ServerData::FetchAllUserAccountsReq* Arena::CreateMaybeMessage<::ServerData::FetchAllUserAccountsReq>(Arena*);
template<> ::ServerData::FetchAllUserAccountsResp* Arena::CreateMaybeMessage<::ServerData::FetchAllUserAccountsResp>(Arena*);
template<> ::ServerData::FetchAllUserRolesReq* Arena::CreateMaybeMessage<::ServerData::FetchAllUserRolesReq>(Arena*);
template<> ::ServerData::FetchAllUserRolesResp* Arena::CreateMaybeMessage<::ServerData::FetchAllUserRolesResp>(Arena*);
template<> ::ServerData::FetchFileByIdCompletedResp* Arena::CreateMaybeMessage<::ServerData::FetchFileByIdCompletedResp>(Arena*);
template<> ::ServerData::FetchFileByIdFailureResp* Arena::CreateMaybeMessage<::ServerData::FetchFileByIdFailureResp>(Arena*);
template<> ::ServerData::FetchFileByIdProgressResp* Arena::CreateMaybeMessage<::ServerData::FetchFileByIdProgressResp>(Arena*);
template<> ::ServerData::FetchFileByIdReq* Arena::CreateMaybeMessage<::ServerData::FetchFileByIdReq>(Arena*);
template<> ::ServerData::FetchRemoteContentInfoReq* Arena::CreateMaybeMessage<::ServerData::FetchRemoteContentInfoReq>(Arena*);
template<> ::ServerData::FetchRemoteContentInfoResp* Arena::CreateMaybeMessage<::ServerData::FetchRemoteContentInfoResp>(Arena*);
template<> ::ServerData::FinalizeTransientPropertyUpdate* Arena::CreateMaybeMessage<::ServerData::FinalizeTransientPropertyUpdate>(Arena*);
template<> ::ServerData::GenericResp* Arena::CreateMaybeMessage<::ServerData::GenericResp>(Arena*);
template<> ::ServerData::GetAudioInputDevicesReq* Arena::CreateMaybeMessage<::ServerData::GetAudioInputDevicesReq>(Arena*);
template<> ::ServerData::GetAudioInputDevicesResp* Arena::CreateMaybeMessage<::ServerData::GetAudioInputDevicesResp>(Arena*);
template<> ::ServerData::GetAudioOutputDevicesReq* Arena::CreateMaybeMessage<::ServerData::GetAudioOutputDevicesReq>(Arena*);
template<> ::ServerData::GetAudioOutputDevicesResp* Arena::CreateMaybeMessage<::ServerData::GetAudioOutputDevicesResp>(Arena*);
template<> ::ServerData::GetSpaceInfoReq* Arena::CreateMaybeMessage<::ServerData::GetSpaceInfoReq>(Arena*);
template<> ::ServerData::GetSpaceInfoResp* Arena::CreateMaybeMessage<::ServerData::GetSpaceInfoResp>(Arena*);
template<> ::ServerData::GetVideoInputDevicesReq* Arena::CreateMaybeMessage<::ServerData::GetVideoInputDevicesReq>(Arena*);
template<> ::ServerData::GetVideoInputDevicesResp* Arena::CreateMaybeMessage<::ServerData::GetVideoInputDevicesResp>(Arena*);
template<> ::ServerData::InviteUserAccountToSpaceReq* Arena::CreateMaybeMessage<::ServerData::InviteUserAccountToSpaceReq>(Arena*);
template<> ::ServerData::JoinSpaceFromIdReq* Arena::CreateMaybeMessage<::ServerData::JoinSpaceFromIdReq>(Arena*);
template<> ::ServerData::JoinSpaceFromIdResp* Arena::CreateMaybeMessage<::ServerData::JoinSpaceFromIdResp>(Arena*);
template<> ::ServerData::KeepAlive* Arena::CreateMaybeMessage<::ServerData::KeepAlive>(Arena*);
template<> ::ServerData::LocalPropertyHandledResp* Arena::CreateMaybeMessage<::ServerData::LocalPropertyHandledResp>(Arena*);
template<> ::ServerData::ObjectAdded* Arena::CreateMaybeMessage<::ServerData::ObjectAdded>(Arena*);
template<> ::ServerData::ObjectRemoved* Arena::CreateMaybeMessage<::ServerData::ObjectRemoved>(Arena*);
template<> ::ServerData::PermissionStatus* Arena::CreateMaybeMessage<::ServerData::PermissionStatus>(Arena*);
template<> ::ServerData::PermissionStatusReq* Arena::CreateMaybeMessage<::ServerData::PermissionStatusReq>(Arena*);
template<> ::ServerData::PostChat* Arena::CreateMaybeMessage<::ServerData::PostChat>(Arena*);
template<> ::ServerData::PostCreateObject* Arena::CreateMaybeMessage<::ServerData::PostCreateObject>(Arena*);
template<> ::ServerData::PostDataCacheUpdate* Arena::CreateMaybeMessage<::ServerData::PostDataCacheUpdate>(Arena*);
template<> ::ServerData::PostPropertyUpdate* Arena::CreateMaybeMessage<::ServerData::PostPropertyUpdate>(Arena*);
template<> ::ServerData::PostRemoveObject* Arena::CreateMaybeMessage<::ServerData::PostRemoveObject>(Arena*);
template<> ::ServerData::PropMetadataStatus* Arena::CreateMaybeMessage<::ServerData::PropMetadataStatus>(Arena*);
template<> ::ServerData::PropertyValue* Arena::CreateMaybeMessage<::ServerData::PropertyValue>(Arena*);
template<> ::ServerData::PropertyValueStatus* Arena::CreateMaybeMessage<::ServerData::PropertyValueStatus>(Arena*);
template<> ::ServerData::QueryAiReq* Arena::CreateMaybeMessage<::ServerData::QueryAiReq>(Arena*);
template<> ::ServerData::QueryAiResp* Arena::CreateMaybeMessage<::ServerData::QueryAiResp>(Arena*);
template<> ::ServerData::RelayClientMessage* Arena::CreateMaybeMessage<::ServerData::RelayClientMessage>(Arena*);
template<> ::ServerData::RelayClientMessageBatch* Arena::CreateMaybeMessage<::ServerData::RelayClientMessageBatch>(Arena*);
template<> ::ServerData::RelayRemoteMessage* Arena::CreateMaybeMessage<::ServerData::RelayRemoteMessage>(Arena*);
template<> ::ServerData::RelayRemoteMessageBatch* Arena::CreateMaybeMessage<::ServerData::RelayRemoteMessageBatch>(Arena*);
template<> ::ServerData::RemoteContentAdded* Arena::CreateMaybeMessage<::ServerData::RemoteContentAdded>(Arena*);
template<> ::ServerData::RemoteContentRemoved* Arena::CreateMaybeMessage<::ServerData::RemoteContentRemoved>(Arena*);
template<> ::ServerData::RemoveUserAccountFromSpaceReq* Arena::CreateMaybeMessage<::ServerData::RemoveUserAccountFromSpaceReq>(Arena*);
template<> ::ServerData::RenameSpaceReq* Arena::CreateMaybeMessage<::ServerData::RenameSpaceReq>(Arena*);
template<> ::ServerData::ServerMessage* Arena::CreateMaybeMessage<::ServerData::ServerMessage>(Arena*);
template<> ::ServerData::SetAudioInputDeviceReq* Arena::CreateMaybeMessage<::ServerData::SetAudioInputDeviceReq>(Arena*);
template<> ::ServerData::SetAudioOutputDeviceReq* Arena::CreateMaybeMessage<::ServerData::SetAudioOutputDeviceReq>(Arena*);
template<> ::ServerData::SetForceKeepAlive* Arena::CreateMaybeMessage<::ServerData::SetForceKeepAlive>(Arena*);
template<> ::ServerData::SetVideoInputDeviceReq* Arena::CreateMaybeMessage<::ServerData::SetVideoInputDeviceReq>(Arena*);
template<> ::ServerData::ShutdownSpaceConnectionReq* Arena::CreateMaybeMessage<::ServerData::ShutdownSpaceConnectionReq>(Arena*);
template<> ::ServerData::ShutdownSpaceConnectionResp* Arena::CreateMaybeMessage<::ServerData::ShutdownSpaceConnectionResp>(Arena*);
template<> ::ServerData::SpaceConnectionStatus* Arena::CreateMaybeMessage<::ServerData::SpaceConnectionStatus>(Arena*);
template<> ::ServerData::StatusMessage* Arena::CreateMaybeMessage<::ServerData::StatusMessage>(Arena*);
template<> ::ServerData::TransformPropertyValue* Arena::CreateMaybeMessage<::ServerData::TransformPropertyValue>(Arena*);
template<> ::ServerData::UpdateLocalUserCoPresence* Arena::CreateMaybeMessage<::ServerData::UpdateLocalUserCoPresence>(Arena*);
template<> ::ServerData::UpdateLocalUserMuted* Arena::CreateMaybeMessage<::ServerData::UpdateLocalUserMuted>(Arena*);
template<> ::ServerData::UpdateLocalUserStreamState* Arena::CreateMaybeMessage<::ServerData::UpdateLocalUserStreamState>(Arena*);
template<> ::ServerData::UpdateThumbnailForSpaceReq* Arena::CreateMaybeMessage<::ServerData::UpdateThumbnailForSpaceReq>(Arena*);
template<> ::ServerData::UpdateTime* Arena::CreateMaybeMessage<::ServerData::UpdateTime>(Arena*);
template<> ::ServerData::UploadLocalFileProgressResp* Arena::CreateMaybeMessage<::ServerData::UploadLocalFileProgressResp>(Arena*);
template<> ::ServerData::UploadLocalFileReq* Arena::CreateMaybeMessage<::ServerData::UploadLocalFileReq>(Arena*);
template<> ::ServerData::UploadLocalFileResp* Arena::CreateMaybeMessage<::ServerData::UploadLocalFileResp>(Arena*);
template<> ::ServerData::UserAdded* Arena::CreateMaybeMessage<::ServerData::UserAdded>(Arena*);
template<> ::ServerData::UserRemoved* Arena::CreateMaybeMessage<::ServerData::UserRemoved>(Arena*);
template<> ::ServerData::UserVideoFrame* Arena::CreateMaybeMessage<::ServerData::UserVideoFrame>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ServerData {

enum ServerMessage_Category : int {
  ServerMessage_Category_Log = 0,
  ServerMessage_Category_UserMessage = 1,
  ServerMessage_Category_CriticalServerMessage = 2,
  ServerMessage_Category_ProgramError = 3,
  ServerMessage_Category_ServerMessage_Category_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ServerMessage_Category_ServerMessage_Category_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ServerMessage_Category_IsValid(int value);
constexpr ServerMessage_Category ServerMessage_Category_Category_MIN = ServerMessage_Category_Log;
constexpr ServerMessage_Category ServerMessage_Category_Category_MAX = ServerMessage_Category_ProgramError;
constexpr int ServerMessage_Category_Category_ARRAYSIZE = ServerMessage_Category_Category_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServerMessage_Category_descriptor();
template<typename T>
inline const std::string& ServerMessage_Category_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServerMessage_Category>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServerMessage_Category_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServerMessage_Category_descriptor(), enum_t_value);
}
inline bool ServerMessage_Category_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServerMessage_Category* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServerMessage_Category>(
    ServerMessage_Category_descriptor(), name, value);
}
enum SpaceConnectionStatus_Status : int {
  SpaceConnectionStatus_Status_ReadyToConnect = 0,
  SpaceConnectionStatus_Status_Connecting = 1,
  SpaceConnectionStatus_Status_ProcessingInitialState = 2,
  SpaceConnectionStatus_Status_Live = 3,
  SpaceConnectionStatus_Status_Reconnecting = 4,
  SpaceConnectionStatus_Status_Closed = 5,
  SpaceConnectionStatus_Status_Error = 6,
  SpaceConnectionStatus_Status_SpaceConnectionStatus_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SpaceConnectionStatus_Status_SpaceConnectionStatus_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SpaceConnectionStatus_Status_IsValid(int value);
constexpr SpaceConnectionStatus_Status SpaceConnectionStatus_Status_Status_MIN = SpaceConnectionStatus_Status_ReadyToConnect;
constexpr SpaceConnectionStatus_Status SpaceConnectionStatus_Status_Status_MAX = SpaceConnectionStatus_Status_Error;
constexpr int SpaceConnectionStatus_Status_Status_ARRAYSIZE = SpaceConnectionStatus_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpaceConnectionStatus_Status_descriptor();
template<typename T>
inline const std::string& SpaceConnectionStatus_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpaceConnectionStatus_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpaceConnectionStatus_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpaceConnectionStatus_Status_descriptor(), enum_t_value);
}
inline bool SpaceConnectionStatus_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpaceConnectionStatus_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpaceConnectionStatus_Status>(
    SpaceConnectionStatus_Status_descriptor(), name, value);
}
enum ChatBase_ChatMessageSourceTypeEnum : int {
  ChatBase_ChatMessageSourceTypeEnum_Chat = 0,
  ChatBase_ChatMessageSourceTypeEnum_Transcription = 1,
  ChatBase_ChatMessageSourceTypeEnum_ChatBase_ChatMessageSourceTypeEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChatBase_ChatMessageSourceTypeEnum_ChatBase_ChatMessageSourceTypeEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChatBase_ChatMessageSourceTypeEnum_IsValid(int value);
constexpr ChatBase_ChatMessageSourceTypeEnum ChatBase_ChatMessageSourceTypeEnum_ChatMessageSourceTypeEnum_MIN = ChatBase_ChatMessageSourceTypeEnum_Chat;
constexpr ChatBase_ChatMessageSourceTypeEnum ChatBase_ChatMessageSourceTypeEnum_ChatMessageSourceTypeEnum_MAX = ChatBase_ChatMessageSourceTypeEnum_Transcription;
constexpr int ChatBase_ChatMessageSourceTypeEnum_ChatMessageSourceTypeEnum_ARRAYSIZE = ChatBase_ChatMessageSourceTypeEnum_ChatMessageSourceTypeEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChatBase_ChatMessageSourceTypeEnum_descriptor();
template<typename T>
inline const std::string& ChatBase_ChatMessageSourceTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatBase_ChatMessageSourceTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatBase_ChatMessageSourceTypeEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChatBase_ChatMessageSourceTypeEnum_descriptor(), enum_t_value);
}
inline bool ChatBase_ChatMessageSourceTypeEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatBase_ChatMessageSourceTypeEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChatBase_ChatMessageSourceTypeEnum>(
    ChatBase_ChatMessageSourceTypeEnum_descriptor(), name, value);
}
// ===================================================================

class RelayClientMessageBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RelayClientMessageBatch) */ {
 public:
  inline RelayClientMessageBatch() : RelayClientMessageBatch(nullptr) {}
  ~RelayClientMessageBatch() override;
  explicit PROTOBUF_CONSTEXPR RelayClientMessageBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayClientMessageBatch(const RelayClientMessageBatch& from);
  RelayClientMessageBatch(RelayClientMessageBatch&& from) noexcept
    : RelayClientMessageBatch() {
    *this = ::std::move(from);
  }

  inline RelayClientMessageBatch& operator=(const RelayClientMessageBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayClientMessageBatch& operator=(RelayClientMessageBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelayClientMessageBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelayClientMessageBatch* internal_default_instance() {
    return reinterpret_cast<const RelayClientMessageBatch*>(
               &_RelayClientMessageBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RelayClientMessageBatch& a, RelayClientMessageBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayClientMessageBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayClientMessageBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayClientMessageBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayClientMessageBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelayClientMessageBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelayClientMessageBatch& from) {
    RelayClientMessageBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelayClientMessageBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RelayClientMessageBatch";
  }
  protected:
  explicit RelayClientMessageBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated .ServerData.RelayClientMessage Messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::ServerData::RelayClientMessage* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayClientMessage >*
      mutable_messages();
  private:
  const ::ServerData::RelayClientMessage& _internal_messages(int index) const;
  ::ServerData::RelayClientMessage* _internal_add_messages();
  public:
  const ::ServerData::RelayClientMessage& messages(int index) const;
  ::ServerData::RelayClientMessage* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayClientMessage >&
      messages() const;

  // @@protoc_insertion_point(class_scope:ServerData.RelayClientMessageBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayClientMessage > messages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class RelayClientMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RelayClientMessage) */ {
 public:
  inline RelayClientMessage() : RelayClientMessage(nullptr) {}
  ~RelayClientMessage() override;
  explicit PROTOBUF_CONSTEXPR RelayClientMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayClientMessage(const RelayClientMessage& from);
  RelayClientMessage(RelayClientMessage&& from) noexcept
    : RelayClientMessage() {
    *this = ::std::move(from);
  }

  inline RelayClientMessage& operator=(const RelayClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayClientMessage& operator=(RelayClientMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelayClientMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kKeepAlive = 1,
    kUpdateTime = 2,
    kSetForceKeepAlive = 3,
    kEndForceKeepAlive = 4,
    kPostDataCacheUpdate = 5,
    kAuthenticateReq = 10,
    kAuthenticateApiKeyReq = 19,
    kAuthenticateGuestReq = 11,
    kAuthenticateDeviceCodeBeginReq = 15,
    kAuthenticateDeviceCodeConcludeReq = 16,
    kExitAllSpacesAndLogoutReq = 12,
    kAuthenticateTokenReq = 13,
    kCheckServerStatusReq = 17,
    kConstructApiKeyReq = 18,
    kJoinSpaceFromIdReq = 20,
    kShutdownSpaceConnectionReq = 21,
    kCreateSpaceReq = 22,
    kFetchAllUserAccountsReq = 23,
    kInviteUserAccountToSpaceReq = 24,
    kRemoveUserAccountFromSpaceReq = 25,
    kFetchAllUserRolesReq = 26,
    kDeleteSpaceReq = 27,
    kRenameSpaceReq = 28,
    kUpdateThumbnailForSpaceReq = 29,
    kGetAudioInputDevicesReq = 30,
    kGetAudioOutputDevicesReq = 31,
    kGetVideoInputDevicesReq = 32,
    kSetAudioInputDeviceReq = 33,
    kSetAudioOutputDeviceReq = 34,
    kSetVideoInputDeviceReq = 35,
    kDefinePropertyDefaultValue = 50,
    kPostPropertyUpdate = 53,
    kBeginTransientPropertyUpdate = 54,
    kContinueTransientPropertyUpdate = 55,
    kFinalizeTransientPropertyUpdate = 56,
    kCancelTransientPropertyUpdate = 57,
    kUpdateLocalUserMuted = 60,
    kUpdateLocalUserCoPresence = 61,
    kUpdateLocalUserStreamState = 62,
    kPostCreateObject = 70,
    kPostRemoveObject = 71,
    kPermissionStatusReq = 90,
    kAllJoinableSpacesReq = 100,
    kGetSpaceInfoReq = 101,
    kFetchFileByIdReq = 110,
    kFetchAllUploadedContentReq = 111,
    kUploadLocalFileReq = 112,
    kContentDestinationFolderReq = 113,
    kFetchRemoteContentInfoReq = 114,
    kPostChat = 120,
    kQueryAiReq = 130,
    MSG_NOT_SET = 0,
  };

  static inline const RelayClientMessage* internal_default_instance() {
    return reinterpret_cast<const RelayClientMessage*>(
               &_RelayClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RelayClientMessage& a, RelayClientMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayClientMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayClientMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayClientMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayClientMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelayClientMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelayClientMessage& from) {
    RelayClientMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelayClientMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RelayClientMessage";
  }
  protected:
  explicit RelayClientMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeepAliveFieldNumber = 1,
    kUpdateTimeFieldNumber = 2,
    kSetForceKeepAliveFieldNumber = 3,
    kEndForceKeepAliveFieldNumber = 4,
    kPostDataCacheUpdateFieldNumber = 5,
    kAuthenticateReqFieldNumber = 10,
    kAuthenticateApiKeyReqFieldNumber = 19,
    kAuthenticateGuestReqFieldNumber = 11,
    kAuthenticateDeviceCodeBeginReqFieldNumber = 15,
    kAuthenticateDeviceCodeConcludeReqFieldNumber = 16,
    kExitAllSpacesAndLogoutReqFieldNumber = 12,
    kAuthenticateTokenReqFieldNumber = 13,
    kCheckServerStatusReqFieldNumber = 17,
    kConstructApiKeyReqFieldNumber = 18,
    kJoinSpaceFromIdReqFieldNumber = 20,
    kShutdownSpaceConnectionReqFieldNumber = 21,
    kCreateSpaceReqFieldNumber = 22,
    kFetchAllUserAccountsReqFieldNumber = 23,
    kInviteUserAccountToSpaceReqFieldNumber = 24,
    kRemoveUserAccountFromSpaceReqFieldNumber = 25,
    kFetchAllUserRolesReqFieldNumber = 26,
    kDeleteSpaceReqFieldNumber = 27,
    kRenameSpaceReqFieldNumber = 28,
    kUpdateThumbnailForSpaceReqFieldNumber = 29,
    kGetAudioInputDevicesReqFieldNumber = 30,
    kGetAudioOutputDevicesReqFieldNumber = 31,
    kGetVideoInputDevicesReqFieldNumber = 32,
    kSetAudioInputDeviceReqFieldNumber = 33,
    kSetAudioOutputDeviceReqFieldNumber = 34,
    kSetVideoInputDeviceReqFieldNumber = 35,
    kDefinePropertyDefaultValueFieldNumber = 50,
    kPostPropertyUpdateFieldNumber = 53,
    kBeginTransientPropertyUpdateFieldNumber = 54,
    kContinueTransientPropertyUpdateFieldNumber = 55,
    kFinalizeTransientPropertyUpdateFieldNumber = 56,
    kCancelTransientPropertyUpdateFieldNumber = 57,
    kUpdateLocalUserMutedFieldNumber = 60,
    kUpdateLocalUserCoPresenceFieldNumber = 61,
    kUpdateLocalUserStreamStateFieldNumber = 62,
    kPostCreateObjectFieldNumber = 70,
    kPostRemoveObjectFieldNumber = 71,
    kPermissionStatusReqFieldNumber = 90,
    kAllJoinableSpacesReqFieldNumber = 100,
    kGetSpaceInfoReqFieldNumber = 101,
    kFetchFileByIdReqFieldNumber = 110,
    kFetchAllUploadedContentReqFieldNumber = 111,
    kUploadLocalFileReqFieldNumber = 112,
    kContentDestinationFolderReqFieldNumber = 113,
    kFetchRemoteContentInfoReqFieldNumber = 114,
    kPostChatFieldNumber = 120,
    kQueryAiReqFieldNumber = 130,
  };
  // .ServerData.KeepAlive KeepAlive = 1;
  bool has_keepalive() const;
  private:
  bool _internal_has_keepalive() const;
  public:
  void clear_keepalive();
  const ::ServerData::KeepAlive& keepalive() const;
  PROTOBUF_NODISCARD ::ServerData::KeepAlive* release_keepalive();
  ::ServerData::KeepAlive* mutable_keepalive();
  void set_allocated_keepalive(::ServerData::KeepAlive* keepalive);
  private:
  const ::ServerData::KeepAlive& _internal_keepalive() const;
  ::ServerData::KeepAlive* _internal_mutable_keepalive();
  public:
  void unsafe_arena_set_allocated_keepalive(
      ::ServerData::KeepAlive* keepalive);
  ::ServerData::KeepAlive* unsafe_arena_release_keepalive();

  // .ServerData.UpdateTime UpdateTime = 2;
  bool has_updatetime() const;
  private:
  bool _internal_has_updatetime() const;
  public:
  void clear_updatetime();
  const ::ServerData::UpdateTime& updatetime() const;
  PROTOBUF_NODISCARD ::ServerData::UpdateTime* release_updatetime();
  ::ServerData::UpdateTime* mutable_updatetime();
  void set_allocated_updatetime(::ServerData::UpdateTime* updatetime);
  private:
  const ::ServerData::UpdateTime& _internal_updatetime() const;
  ::ServerData::UpdateTime* _internal_mutable_updatetime();
  public:
  void unsafe_arena_set_allocated_updatetime(
      ::ServerData::UpdateTime* updatetime);
  ::ServerData::UpdateTime* unsafe_arena_release_updatetime();

  // .ServerData.SetForceKeepAlive SetForceKeepAlive = 3;
  bool has_setforcekeepalive() const;
  private:
  bool _internal_has_setforcekeepalive() const;
  public:
  void clear_setforcekeepalive();
  const ::ServerData::SetForceKeepAlive& setforcekeepalive() const;
  PROTOBUF_NODISCARD ::ServerData::SetForceKeepAlive* release_setforcekeepalive();
  ::ServerData::SetForceKeepAlive* mutable_setforcekeepalive();
  void set_allocated_setforcekeepalive(::ServerData::SetForceKeepAlive* setforcekeepalive);
  private:
  const ::ServerData::SetForceKeepAlive& _internal_setforcekeepalive() const;
  ::ServerData::SetForceKeepAlive* _internal_mutable_setforcekeepalive();
  public:
  void unsafe_arena_set_allocated_setforcekeepalive(
      ::ServerData::SetForceKeepAlive* setforcekeepalive);
  ::ServerData::SetForceKeepAlive* unsafe_arena_release_setforcekeepalive();

  // .ServerData.EndForceKeepAlive EndForceKeepAlive = 4;
  bool has_endforcekeepalive() const;
  private:
  bool _internal_has_endforcekeepalive() const;
  public:
  void clear_endforcekeepalive();
  const ::ServerData::EndForceKeepAlive& endforcekeepalive() const;
  PROTOBUF_NODISCARD ::ServerData::EndForceKeepAlive* release_endforcekeepalive();
  ::ServerData::EndForceKeepAlive* mutable_endforcekeepalive();
  void set_allocated_endforcekeepalive(::ServerData::EndForceKeepAlive* endforcekeepalive);
  private:
  const ::ServerData::EndForceKeepAlive& _internal_endforcekeepalive() const;
  ::ServerData::EndForceKeepAlive* _internal_mutable_endforcekeepalive();
  public:
  void unsafe_arena_set_allocated_endforcekeepalive(
      ::ServerData::EndForceKeepAlive* endforcekeepalive);
  ::ServerData::EndForceKeepAlive* unsafe_arena_release_endforcekeepalive();

  // .ServerData.PostDataCacheUpdate PostDataCacheUpdate = 5;
  bool has_postdatacacheupdate() const;
  private:
  bool _internal_has_postdatacacheupdate() const;
  public:
  void clear_postdatacacheupdate();
  const ::ServerData::PostDataCacheUpdate& postdatacacheupdate() const;
  PROTOBUF_NODISCARD ::ServerData::PostDataCacheUpdate* release_postdatacacheupdate();
  ::ServerData::PostDataCacheUpdate* mutable_postdatacacheupdate();
  void set_allocated_postdatacacheupdate(::ServerData::PostDataCacheUpdate* postdatacacheupdate);
  private:
  const ::ServerData::PostDataCacheUpdate& _internal_postdatacacheupdate() const;
  ::ServerData::PostDataCacheUpdate* _internal_mutable_postdatacacheupdate();
  public:
  void unsafe_arena_set_allocated_postdatacacheupdate(
      ::ServerData::PostDataCacheUpdate* postdatacacheupdate);
  ::ServerData::PostDataCacheUpdate* unsafe_arena_release_postdatacacheupdate();

  // .ServerData.AuthenticateReq AuthenticateReq = 10;
  bool has_authenticatereq() const;
  private:
  bool _internal_has_authenticatereq() const;
  public:
  void clear_authenticatereq();
  const ::ServerData::AuthenticateReq& authenticatereq() const;
  PROTOBUF_NODISCARD ::ServerData::AuthenticateReq* release_authenticatereq();
  ::ServerData::AuthenticateReq* mutable_authenticatereq();
  void set_allocated_authenticatereq(::ServerData::AuthenticateReq* authenticatereq);
  private:
  const ::ServerData::AuthenticateReq& _internal_authenticatereq() const;
  ::ServerData::AuthenticateReq* _internal_mutable_authenticatereq();
  public:
  void unsafe_arena_set_allocated_authenticatereq(
      ::ServerData::AuthenticateReq* authenticatereq);
  ::ServerData::AuthenticateReq* unsafe_arena_release_authenticatereq();

  // .ServerData.AuthenticateApiKeyReq AuthenticateApiKeyReq = 19;
  bool has_authenticateapikeyreq() const;
  private:
  bool _internal_has_authenticateapikeyreq() const;
  public:
  void clear_authenticateapikeyreq();
  const ::ServerData::AuthenticateApiKeyReq& authenticateapikeyreq() const;
  PROTOBUF_NODISCARD ::ServerData::AuthenticateApiKeyReq* release_authenticateapikeyreq();
  ::ServerData::AuthenticateApiKeyReq* mutable_authenticateapikeyreq();
  void set_allocated_authenticateapikeyreq(::ServerData::AuthenticateApiKeyReq* authenticateapikeyreq);
  private:
  const ::ServerData::AuthenticateApiKeyReq& _internal_authenticateapikeyreq() const;
  ::ServerData::AuthenticateApiKeyReq* _internal_mutable_authenticateapikeyreq();
  public:
  void unsafe_arena_set_allocated_authenticateapikeyreq(
      ::ServerData::AuthenticateApiKeyReq* authenticateapikeyreq);
  ::ServerData::AuthenticateApiKeyReq* unsafe_arena_release_authenticateapikeyreq();

  // .ServerData.AuthenticateGuestReq AuthenticateGuestReq = 11;
  bool has_authenticateguestreq() const;
  private:
  bool _internal_has_authenticateguestreq() const;
  public:
  void clear_authenticateguestreq();
  const ::ServerData::AuthenticateGuestReq& authenticateguestreq() const;
  PROTOBUF_NODISCARD ::ServerData::AuthenticateGuestReq* release_authenticateguestreq();
  ::ServerData::AuthenticateGuestReq* mutable_authenticateguestreq();
  void set_allocated_authenticateguestreq(::ServerData::AuthenticateGuestReq* authenticateguestreq);
  private:
  const ::ServerData::AuthenticateGuestReq& _internal_authenticateguestreq() const;
  ::ServerData::AuthenticateGuestReq* _internal_mutable_authenticateguestreq();
  public:
  void unsafe_arena_set_allocated_authenticateguestreq(
      ::ServerData::AuthenticateGuestReq* authenticateguestreq);
  ::ServerData::AuthenticateGuestReq* unsafe_arena_release_authenticateguestreq();

  // .ServerData.AuthenticateDeviceCodeBeginReq AuthenticateDeviceCodeBeginReq = 15;
  bool has_authenticatedevicecodebeginreq() const;
  private:
  bool _internal_has_authenticatedevicecodebeginreq() const;
  public:
  void clear_authenticatedevicecodebeginreq();
  const ::ServerData::AuthenticateDeviceCodeBeginReq& authenticatedevicecodebeginreq() const;
  PROTOBUF_NODISCARD ::ServerData::AuthenticateDeviceCodeBeginReq* release_authenticatedevicecodebeginreq();
  ::ServerData::AuthenticateDeviceCodeBeginReq* mutable_authenticatedevicecodebeginreq();
  void set_allocated_authenticatedevicecodebeginreq(::ServerData::AuthenticateDeviceCodeBeginReq* authenticatedevicecodebeginreq);
  private:
  const ::ServerData::AuthenticateDeviceCodeBeginReq& _internal_authenticatedevicecodebeginreq() const;
  ::ServerData::AuthenticateDeviceCodeBeginReq* _internal_mutable_authenticatedevicecodebeginreq();
  public:
  void unsafe_arena_set_allocated_authenticatedevicecodebeginreq(
      ::ServerData::AuthenticateDeviceCodeBeginReq* authenticatedevicecodebeginreq);
  ::ServerData::AuthenticateDeviceCodeBeginReq* unsafe_arena_release_authenticatedevicecodebeginreq();

  // .ServerData.AuthenticateDeviceCodeConcludeReq AuthenticateDeviceCodeConcludeReq = 16;
  bool has_authenticatedevicecodeconcludereq() const;
  private:
  bool _internal_has_authenticatedevicecodeconcludereq() const;
  public:
  void clear_authenticatedevicecodeconcludereq();
  const ::ServerData::AuthenticateDeviceCodeConcludeReq& authenticatedevicecodeconcludereq() const;
  PROTOBUF_NODISCARD ::ServerData::AuthenticateDeviceCodeConcludeReq* release_authenticatedevicecodeconcludereq();
  ::ServerData::AuthenticateDeviceCodeConcludeReq* mutable_authenticatedevicecodeconcludereq();
  void set_allocated_authenticatedevicecodeconcludereq(::ServerData::AuthenticateDeviceCodeConcludeReq* authenticatedevicecodeconcludereq);
  private:
  const ::ServerData::AuthenticateDeviceCodeConcludeReq& _internal_authenticatedevicecodeconcludereq() const;
  ::ServerData::AuthenticateDeviceCodeConcludeReq* _internal_mutable_authenticatedevicecodeconcludereq();
  public:
  void unsafe_arena_set_allocated_authenticatedevicecodeconcludereq(
      ::ServerData::AuthenticateDeviceCodeConcludeReq* authenticatedevicecodeconcludereq);
  ::ServerData::AuthenticateDeviceCodeConcludeReq* unsafe_arena_release_authenticatedevicecodeconcludereq();

  // .ServerData.ExitAllSpacesAndLogoutReq ExitAllSpacesAndLogoutReq = 12;
  bool has_exitallspacesandlogoutreq() const;
  private:
  bool _internal_has_exitallspacesandlogoutreq() const;
  public:
  void clear_exitallspacesandlogoutreq();
  const ::ServerData::ExitAllSpacesAndLogoutReq& exitallspacesandlogoutreq() const;
  PROTOBUF_NODISCARD ::ServerData::ExitAllSpacesAndLogoutReq* release_exitallspacesandlogoutreq();
  ::ServerData::ExitAllSpacesAndLogoutReq* mutable_exitallspacesandlogoutreq();
  void set_allocated_exitallspacesandlogoutreq(::ServerData::ExitAllSpacesAndLogoutReq* exitallspacesandlogoutreq);
  private:
  const ::ServerData::ExitAllSpacesAndLogoutReq& _internal_exitallspacesandlogoutreq() const;
  ::ServerData::ExitAllSpacesAndLogoutReq* _internal_mutable_exitallspacesandlogoutreq();
  public:
  void unsafe_arena_set_allocated_exitallspacesandlogoutreq(
      ::ServerData::ExitAllSpacesAndLogoutReq* exitallspacesandlogoutreq);
  ::ServerData::ExitAllSpacesAndLogoutReq* unsafe_arena_release_exitallspacesandlogoutreq();

  // .ServerData.AuthenticateTokenReq AuthenticateTokenReq = 13;
  bool has_authenticatetokenreq() const;
  private:
  bool _internal_has_authenticatetokenreq() const;
  public:
  void clear_authenticatetokenreq();
  const ::ServerData::AuthenticateTokenReq& authenticatetokenreq() const;
  PROTOBUF_NODISCARD ::ServerData::AuthenticateTokenReq* release_authenticatetokenreq();
  ::ServerData::AuthenticateTokenReq* mutable_authenticatetokenreq();
  void set_allocated_authenticatetokenreq(::ServerData::AuthenticateTokenReq* authenticatetokenreq);
  private:
  const ::ServerData::AuthenticateTokenReq& _internal_authenticatetokenreq() const;
  ::ServerData::AuthenticateTokenReq* _internal_mutable_authenticatetokenreq();
  public:
  void unsafe_arena_set_allocated_authenticatetokenreq(
      ::ServerData::AuthenticateTokenReq* authenticatetokenreq);
  ::ServerData::AuthenticateTokenReq* unsafe_arena_release_authenticatetokenreq();

  // .ServerData.CheckServerStatusReq CheckServerStatusReq = 17;
  bool has_checkserverstatusreq() const;
  private:
  bool _internal_has_checkserverstatusreq() const;
  public:
  void clear_checkserverstatusreq();
  const ::ServerData::CheckServerStatusReq& checkserverstatusreq() const;
  PROTOBUF_NODISCARD ::ServerData::CheckServerStatusReq* release_checkserverstatusreq();
  ::ServerData::CheckServerStatusReq* mutable_checkserverstatusreq();
  void set_allocated_checkserverstatusreq(::ServerData::CheckServerStatusReq* checkserverstatusreq);
  private:
  const ::ServerData::CheckServerStatusReq& _internal_checkserverstatusreq() const;
  ::ServerData::CheckServerStatusReq* _internal_mutable_checkserverstatusreq();
  public:
  void unsafe_arena_set_allocated_checkserverstatusreq(
      ::ServerData::CheckServerStatusReq* checkserverstatusreq);
  ::ServerData::CheckServerStatusReq* unsafe_arena_release_checkserverstatusreq();

  // .ServerData.ConstructApiKeyReq ConstructApiKeyReq = 18;
  bool has_constructapikeyreq() const;
  private:
  bool _internal_has_constructapikeyreq() const;
  public:
  void clear_constructapikeyreq();
  const ::ServerData::ConstructApiKeyReq& constructapikeyreq() const;
  PROTOBUF_NODISCARD ::ServerData::ConstructApiKeyReq* release_constructapikeyreq();
  ::ServerData::ConstructApiKeyReq* mutable_constructapikeyreq();
  void set_allocated_constructapikeyreq(::ServerData::ConstructApiKeyReq* constructapikeyreq);
  private:
  const ::ServerData::ConstructApiKeyReq& _internal_constructapikeyreq() const;
  ::ServerData::ConstructApiKeyReq* _internal_mutable_constructapikeyreq();
  public:
  void unsafe_arena_set_allocated_constructapikeyreq(
      ::ServerData::ConstructApiKeyReq* constructapikeyreq);
  ::ServerData::ConstructApiKeyReq* unsafe_arena_release_constructapikeyreq();

  // .ServerData.JoinSpaceFromIdReq JoinSpaceFromIdReq = 20;
  bool has_joinspacefromidreq() const;
  private:
  bool _internal_has_joinspacefromidreq() const;
  public:
  void clear_joinspacefromidreq();
  const ::ServerData::JoinSpaceFromIdReq& joinspacefromidreq() const;
  PROTOBUF_NODISCARD ::ServerData::JoinSpaceFromIdReq* release_joinspacefromidreq();
  ::ServerData::JoinSpaceFromIdReq* mutable_joinspacefromidreq();
  void set_allocated_joinspacefromidreq(::ServerData::JoinSpaceFromIdReq* joinspacefromidreq);
  private:
  const ::ServerData::JoinSpaceFromIdReq& _internal_joinspacefromidreq() const;
  ::ServerData::JoinSpaceFromIdReq* _internal_mutable_joinspacefromidreq();
  public:
  void unsafe_arena_set_allocated_joinspacefromidreq(
      ::ServerData::JoinSpaceFromIdReq* joinspacefromidreq);
  ::ServerData::JoinSpaceFromIdReq* unsafe_arena_release_joinspacefromidreq();

  // .ServerData.ShutdownSpaceConnectionReq ShutdownSpaceConnectionReq = 21;
  bool has_shutdownspaceconnectionreq() const;
  private:
  bool _internal_has_shutdownspaceconnectionreq() const;
  public:
  void clear_shutdownspaceconnectionreq();
  const ::ServerData::ShutdownSpaceConnectionReq& shutdownspaceconnectionreq() const;
  PROTOBUF_NODISCARD ::ServerData::ShutdownSpaceConnectionReq* release_shutdownspaceconnectionreq();
  ::ServerData::ShutdownSpaceConnectionReq* mutable_shutdownspaceconnectionreq();
  void set_allocated_shutdownspaceconnectionreq(::ServerData::ShutdownSpaceConnectionReq* shutdownspaceconnectionreq);
  private:
  const ::ServerData::ShutdownSpaceConnectionReq& _internal_shutdownspaceconnectionreq() const;
  ::ServerData::ShutdownSpaceConnectionReq* _internal_mutable_shutdownspaceconnectionreq();
  public:
  void unsafe_arena_set_allocated_shutdownspaceconnectionreq(
      ::ServerData::ShutdownSpaceConnectionReq* shutdownspaceconnectionreq);
  ::ServerData::ShutdownSpaceConnectionReq* unsafe_arena_release_shutdownspaceconnectionreq();

  // .ServerData.CreateSpaceReq CreateSpaceReq = 22;
  bool has_createspacereq() const;
  private:
  bool _internal_has_createspacereq() const;
  public:
  void clear_createspacereq();
  const ::ServerData::CreateSpaceReq& createspacereq() const;
  PROTOBUF_NODISCARD ::ServerData::CreateSpaceReq* release_createspacereq();
  ::ServerData::CreateSpaceReq* mutable_createspacereq();
  void set_allocated_createspacereq(::ServerData::CreateSpaceReq* createspacereq);
  private:
  const ::ServerData::CreateSpaceReq& _internal_createspacereq() const;
  ::ServerData::CreateSpaceReq* _internal_mutable_createspacereq();
  public:
  void unsafe_arena_set_allocated_createspacereq(
      ::ServerData::CreateSpaceReq* createspacereq);
  ::ServerData::CreateSpaceReq* unsafe_arena_release_createspacereq();

  // .ServerData.FetchAllUserAccountsReq FetchAllUserAccountsReq = 23;
  bool has_fetchalluseraccountsreq() const;
  private:
  bool _internal_has_fetchalluseraccountsreq() const;
  public:
  void clear_fetchalluseraccountsreq();
  const ::ServerData::FetchAllUserAccountsReq& fetchalluseraccountsreq() const;
  PROTOBUF_NODISCARD ::ServerData::FetchAllUserAccountsReq* release_fetchalluseraccountsreq();
  ::ServerData::FetchAllUserAccountsReq* mutable_fetchalluseraccountsreq();
  void set_allocated_fetchalluseraccountsreq(::ServerData::FetchAllUserAccountsReq* fetchalluseraccountsreq);
  private:
  const ::ServerData::FetchAllUserAccountsReq& _internal_fetchalluseraccountsreq() const;
  ::ServerData::FetchAllUserAccountsReq* _internal_mutable_fetchalluseraccountsreq();
  public:
  void unsafe_arena_set_allocated_fetchalluseraccountsreq(
      ::ServerData::FetchAllUserAccountsReq* fetchalluseraccountsreq);
  ::ServerData::FetchAllUserAccountsReq* unsafe_arena_release_fetchalluseraccountsreq();

  // .ServerData.InviteUserAccountToSpaceReq InviteUserAccountToSpaceReq = 24;
  bool has_inviteuseraccounttospacereq() const;
  private:
  bool _internal_has_inviteuseraccounttospacereq() const;
  public:
  void clear_inviteuseraccounttospacereq();
  const ::ServerData::InviteUserAccountToSpaceReq& inviteuseraccounttospacereq() const;
  PROTOBUF_NODISCARD ::ServerData::InviteUserAccountToSpaceReq* release_inviteuseraccounttospacereq();
  ::ServerData::InviteUserAccountToSpaceReq* mutable_inviteuseraccounttospacereq();
  void set_allocated_inviteuseraccounttospacereq(::ServerData::InviteUserAccountToSpaceReq* inviteuseraccounttospacereq);
  private:
  const ::ServerData::InviteUserAccountToSpaceReq& _internal_inviteuseraccounttospacereq() const;
  ::ServerData::InviteUserAccountToSpaceReq* _internal_mutable_inviteuseraccounttospacereq();
  public:
  void unsafe_arena_set_allocated_inviteuseraccounttospacereq(
      ::ServerData::InviteUserAccountToSpaceReq* inviteuseraccounttospacereq);
  ::ServerData::InviteUserAccountToSpaceReq* unsafe_arena_release_inviteuseraccounttospacereq();

  // .ServerData.RemoveUserAccountFromSpaceReq RemoveUserAccountFromSpaceReq = 25;
  bool has_removeuseraccountfromspacereq() const;
  private:
  bool _internal_has_removeuseraccountfromspacereq() const;
  public:
  void clear_removeuseraccountfromspacereq();
  const ::ServerData::RemoveUserAccountFromSpaceReq& removeuseraccountfromspacereq() const;
  PROTOBUF_NODISCARD ::ServerData::RemoveUserAccountFromSpaceReq* release_removeuseraccountfromspacereq();
  ::ServerData::RemoveUserAccountFromSpaceReq* mutable_removeuseraccountfromspacereq();
  void set_allocated_removeuseraccountfromspacereq(::ServerData::RemoveUserAccountFromSpaceReq* removeuseraccountfromspacereq);
  private:
  const ::ServerData::RemoveUserAccountFromSpaceReq& _internal_removeuseraccountfromspacereq() const;
  ::ServerData::RemoveUserAccountFromSpaceReq* _internal_mutable_removeuseraccountfromspacereq();
  public:
  void unsafe_arena_set_allocated_removeuseraccountfromspacereq(
      ::ServerData::RemoveUserAccountFromSpaceReq* removeuseraccountfromspacereq);
  ::ServerData::RemoveUserAccountFromSpaceReq* unsafe_arena_release_removeuseraccountfromspacereq();

  // .ServerData.FetchAllUserRolesReq FetchAllUserRolesReq = 26;
  bool has_fetchalluserrolesreq() const;
  private:
  bool _internal_has_fetchalluserrolesreq() const;
  public:
  void clear_fetchalluserrolesreq();
  const ::ServerData::FetchAllUserRolesReq& fetchalluserrolesreq() const;
  PROTOBUF_NODISCARD ::ServerData::FetchAllUserRolesReq* release_fetchalluserrolesreq();
  ::ServerData::FetchAllUserRolesReq* mutable_fetchalluserrolesreq();
  void set_allocated_fetchalluserrolesreq(::ServerData::FetchAllUserRolesReq* fetchalluserrolesreq);
  private:
  const ::ServerData::FetchAllUserRolesReq& _internal_fetchalluserrolesreq() const;
  ::ServerData::FetchAllUserRolesReq* _internal_mutable_fetchalluserrolesreq();
  public:
  void unsafe_arena_set_allocated_fetchalluserrolesreq(
      ::ServerData::FetchAllUserRolesReq* fetchalluserrolesreq);
  ::ServerData::FetchAllUserRolesReq* unsafe_arena_release_fetchalluserrolesreq();

  // .ServerData.DeleteSpaceReq DeleteSpaceReq = 27;
  bool has_deletespacereq() const;
  private:
  bool _internal_has_deletespacereq() const;
  public:
  void clear_deletespacereq();
  const ::ServerData::DeleteSpaceReq& deletespacereq() const;
  PROTOBUF_NODISCARD ::ServerData::DeleteSpaceReq* release_deletespacereq();
  ::ServerData::DeleteSpaceReq* mutable_deletespacereq();
  void set_allocated_deletespacereq(::ServerData::DeleteSpaceReq* deletespacereq);
  private:
  const ::ServerData::DeleteSpaceReq& _internal_deletespacereq() const;
  ::ServerData::DeleteSpaceReq* _internal_mutable_deletespacereq();
  public:
  void unsafe_arena_set_allocated_deletespacereq(
      ::ServerData::DeleteSpaceReq* deletespacereq);
  ::ServerData::DeleteSpaceReq* unsafe_arena_release_deletespacereq();

  // .ServerData.RenameSpaceReq RenameSpaceReq = 28;
  bool has_renamespacereq() const;
  private:
  bool _internal_has_renamespacereq() const;
  public:
  void clear_renamespacereq();
  const ::ServerData::RenameSpaceReq& renamespacereq() const;
  PROTOBUF_NODISCARD ::ServerData::RenameSpaceReq* release_renamespacereq();
  ::ServerData::RenameSpaceReq* mutable_renamespacereq();
  void set_allocated_renamespacereq(::ServerData::RenameSpaceReq* renamespacereq);
  private:
  const ::ServerData::RenameSpaceReq& _internal_renamespacereq() const;
  ::ServerData::RenameSpaceReq* _internal_mutable_renamespacereq();
  public:
  void unsafe_arena_set_allocated_renamespacereq(
      ::ServerData::RenameSpaceReq* renamespacereq);
  ::ServerData::RenameSpaceReq* unsafe_arena_release_renamespacereq();

  // .ServerData.UpdateThumbnailForSpaceReq UpdateThumbnailForSpaceReq = 29;
  bool has_updatethumbnailforspacereq() const;
  private:
  bool _internal_has_updatethumbnailforspacereq() const;
  public:
  void clear_updatethumbnailforspacereq();
  const ::ServerData::UpdateThumbnailForSpaceReq& updatethumbnailforspacereq() const;
  PROTOBUF_NODISCARD ::ServerData::UpdateThumbnailForSpaceReq* release_updatethumbnailforspacereq();
  ::ServerData::UpdateThumbnailForSpaceReq* mutable_updatethumbnailforspacereq();
  void set_allocated_updatethumbnailforspacereq(::ServerData::UpdateThumbnailForSpaceReq* updatethumbnailforspacereq);
  private:
  const ::ServerData::UpdateThumbnailForSpaceReq& _internal_updatethumbnailforspacereq() const;
  ::ServerData::UpdateThumbnailForSpaceReq* _internal_mutable_updatethumbnailforspacereq();
  public:
  void unsafe_arena_set_allocated_updatethumbnailforspacereq(
      ::ServerData::UpdateThumbnailForSpaceReq* updatethumbnailforspacereq);
  ::ServerData::UpdateThumbnailForSpaceReq* unsafe_arena_release_updatethumbnailforspacereq();

  // .ServerData.GetAudioInputDevicesReq GetAudioInputDevicesReq = 30;
  bool has_getaudioinputdevicesreq() const;
  private:
  bool _internal_has_getaudioinputdevicesreq() const;
  public:
  void clear_getaudioinputdevicesreq();
  const ::ServerData::GetAudioInputDevicesReq& getaudioinputdevicesreq() const;
  PROTOBUF_NODISCARD ::ServerData::GetAudioInputDevicesReq* release_getaudioinputdevicesreq();
  ::ServerData::GetAudioInputDevicesReq* mutable_getaudioinputdevicesreq();
  void set_allocated_getaudioinputdevicesreq(::ServerData::GetAudioInputDevicesReq* getaudioinputdevicesreq);
  private:
  const ::ServerData::GetAudioInputDevicesReq& _internal_getaudioinputdevicesreq() const;
  ::ServerData::GetAudioInputDevicesReq* _internal_mutable_getaudioinputdevicesreq();
  public:
  void unsafe_arena_set_allocated_getaudioinputdevicesreq(
      ::ServerData::GetAudioInputDevicesReq* getaudioinputdevicesreq);
  ::ServerData::GetAudioInputDevicesReq* unsafe_arena_release_getaudioinputdevicesreq();

  // .ServerData.GetAudioOutputDevicesReq GetAudioOutputDevicesReq = 31;
  bool has_getaudiooutputdevicesreq() const;
  private:
  bool _internal_has_getaudiooutputdevicesreq() const;
  public:
  void clear_getaudiooutputdevicesreq();
  const ::ServerData::GetAudioOutputDevicesReq& getaudiooutputdevicesreq() const;
  PROTOBUF_NODISCARD ::ServerData::GetAudioOutputDevicesReq* release_getaudiooutputdevicesreq();
  ::ServerData::GetAudioOutputDevicesReq* mutable_getaudiooutputdevicesreq();
  void set_allocated_getaudiooutputdevicesreq(::ServerData::GetAudioOutputDevicesReq* getaudiooutputdevicesreq);
  private:
  const ::ServerData::GetAudioOutputDevicesReq& _internal_getaudiooutputdevicesreq() const;
  ::ServerData::GetAudioOutputDevicesReq* _internal_mutable_getaudiooutputdevicesreq();
  public:
  void unsafe_arena_set_allocated_getaudiooutputdevicesreq(
      ::ServerData::GetAudioOutputDevicesReq* getaudiooutputdevicesreq);
  ::ServerData::GetAudioOutputDevicesReq* unsafe_arena_release_getaudiooutputdevicesreq();

  // .ServerData.GetVideoInputDevicesReq GetVideoInputDevicesReq = 32;
  bool has_getvideoinputdevicesreq() const;
  private:
  bool _internal_has_getvideoinputdevicesreq() const;
  public:
  void clear_getvideoinputdevicesreq();
  const ::ServerData::GetVideoInputDevicesReq& getvideoinputdevicesreq() const;
  PROTOBUF_NODISCARD ::ServerData::GetVideoInputDevicesReq* release_getvideoinputdevicesreq();
  ::ServerData::GetVideoInputDevicesReq* mutable_getvideoinputdevicesreq();
  void set_allocated_getvideoinputdevicesreq(::ServerData::GetVideoInputDevicesReq* getvideoinputdevicesreq);
  private:
  const ::ServerData::GetVideoInputDevicesReq& _internal_getvideoinputdevicesreq() const;
  ::ServerData::GetVideoInputDevicesReq* _internal_mutable_getvideoinputdevicesreq();
  public:
  void unsafe_arena_set_allocated_getvideoinputdevicesreq(
      ::ServerData::GetVideoInputDevicesReq* getvideoinputdevicesreq);
  ::ServerData::GetVideoInputDevicesReq* unsafe_arena_release_getvideoinputdevicesreq();

  // .ServerData.SetAudioInputDeviceReq SetAudioInputDeviceReq = 33;
  bool has_setaudioinputdevicereq() const;
  private:
  bool _internal_has_setaudioinputdevicereq() const;
  public:
  void clear_setaudioinputdevicereq();
  const ::ServerData::SetAudioInputDeviceReq& setaudioinputdevicereq() const;
  PROTOBUF_NODISCARD ::ServerData::SetAudioInputDeviceReq* release_setaudioinputdevicereq();
  ::ServerData::SetAudioInputDeviceReq* mutable_setaudioinputdevicereq();
  void set_allocated_setaudioinputdevicereq(::ServerData::SetAudioInputDeviceReq* setaudioinputdevicereq);
  private:
  const ::ServerData::SetAudioInputDeviceReq& _internal_setaudioinputdevicereq() const;
  ::ServerData::SetAudioInputDeviceReq* _internal_mutable_setaudioinputdevicereq();
  public:
  void unsafe_arena_set_allocated_setaudioinputdevicereq(
      ::ServerData::SetAudioInputDeviceReq* setaudioinputdevicereq);
  ::ServerData::SetAudioInputDeviceReq* unsafe_arena_release_setaudioinputdevicereq();

  // .ServerData.SetAudioOutputDeviceReq SetAudioOutputDeviceReq = 34;
  bool has_setaudiooutputdevicereq() const;
  private:
  bool _internal_has_setaudiooutputdevicereq() const;
  public:
  void clear_setaudiooutputdevicereq();
  const ::ServerData::SetAudioOutputDeviceReq& setaudiooutputdevicereq() const;
  PROTOBUF_NODISCARD ::ServerData::SetAudioOutputDeviceReq* release_setaudiooutputdevicereq();
  ::ServerData::SetAudioOutputDeviceReq* mutable_setaudiooutputdevicereq();
  void set_allocated_setaudiooutputdevicereq(::ServerData::SetAudioOutputDeviceReq* setaudiooutputdevicereq);
  private:
  const ::ServerData::SetAudioOutputDeviceReq& _internal_setaudiooutputdevicereq() const;
  ::ServerData::SetAudioOutputDeviceReq* _internal_mutable_setaudiooutputdevicereq();
  public:
  void unsafe_arena_set_allocated_setaudiooutputdevicereq(
      ::ServerData::SetAudioOutputDeviceReq* setaudiooutputdevicereq);
  ::ServerData::SetAudioOutputDeviceReq* unsafe_arena_release_setaudiooutputdevicereq();

  // .ServerData.SetVideoInputDeviceReq SetVideoInputDeviceReq = 35;
  bool has_setvideoinputdevicereq() const;
  private:
  bool _internal_has_setvideoinputdevicereq() const;
  public:
  void clear_setvideoinputdevicereq();
  const ::ServerData::SetVideoInputDeviceReq& setvideoinputdevicereq() const;
  PROTOBUF_NODISCARD ::ServerData::SetVideoInputDeviceReq* release_setvideoinputdevicereq();
  ::ServerData::SetVideoInputDeviceReq* mutable_setvideoinputdevicereq();
  void set_allocated_setvideoinputdevicereq(::ServerData::SetVideoInputDeviceReq* setvideoinputdevicereq);
  private:
  const ::ServerData::SetVideoInputDeviceReq& _internal_setvideoinputdevicereq() const;
  ::ServerData::SetVideoInputDeviceReq* _internal_mutable_setvideoinputdevicereq();
  public:
  void unsafe_arena_set_allocated_setvideoinputdevicereq(
      ::ServerData::SetVideoInputDeviceReq* setvideoinputdevicereq);
  ::ServerData::SetVideoInputDeviceReq* unsafe_arena_release_setvideoinputdevicereq();

  // .ServerData.DefinePropertyDefaultValue DefinePropertyDefaultValue = 50;
  bool has_definepropertydefaultvalue() const;
  private:
  bool _internal_has_definepropertydefaultvalue() const;
  public:
  void clear_definepropertydefaultvalue();
  const ::ServerData::DefinePropertyDefaultValue& definepropertydefaultvalue() const;
  PROTOBUF_NODISCARD ::ServerData::DefinePropertyDefaultValue* release_definepropertydefaultvalue();
  ::ServerData::DefinePropertyDefaultValue* mutable_definepropertydefaultvalue();
  void set_allocated_definepropertydefaultvalue(::ServerData::DefinePropertyDefaultValue* definepropertydefaultvalue);
  private:
  const ::ServerData::DefinePropertyDefaultValue& _internal_definepropertydefaultvalue() const;
  ::ServerData::DefinePropertyDefaultValue* _internal_mutable_definepropertydefaultvalue();
  public:
  void unsafe_arena_set_allocated_definepropertydefaultvalue(
      ::ServerData::DefinePropertyDefaultValue* definepropertydefaultvalue);
  ::ServerData::DefinePropertyDefaultValue* unsafe_arena_release_definepropertydefaultvalue();

  // .ServerData.PostPropertyUpdate PostPropertyUpdate = 53;
  bool has_postpropertyupdate() const;
  private:
  bool _internal_has_postpropertyupdate() const;
  public:
  void clear_postpropertyupdate();
  const ::ServerData::PostPropertyUpdate& postpropertyupdate() const;
  PROTOBUF_NODISCARD ::ServerData::PostPropertyUpdate* release_postpropertyupdate();
  ::ServerData::PostPropertyUpdate* mutable_postpropertyupdate();
  void set_allocated_postpropertyupdate(::ServerData::PostPropertyUpdate* postpropertyupdate);
  private:
  const ::ServerData::PostPropertyUpdate& _internal_postpropertyupdate() const;
  ::ServerData::PostPropertyUpdate* _internal_mutable_postpropertyupdate();
  public:
  void unsafe_arena_set_allocated_postpropertyupdate(
      ::ServerData::PostPropertyUpdate* postpropertyupdate);
  ::ServerData::PostPropertyUpdate* unsafe_arena_release_postpropertyupdate();

  // .ServerData.BeginTransientPropertyUpdate BeginTransientPropertyUpdate = 54;
  bool has_begintransientpropertyupdate() const;
  private:
  bool _internal_has_begintransientpropertyupdate() const;
  public:
  void clear_begintransientpropertyupdate();
  const ::ServerData::BeginTransientPropertyUpdate& begintransientpropertyupdate() const;
  PROTOBUF_NODISCARD ::ServerData::BeginTransientPropertyUpdate* release_begintransientpropertyupdate();
  ::ServerData::BeginTransientPropertyUpdate* mutable_begintransientpropertyupdate();
  void set_allocated_begintransientpropertyupdate(::ServerData::BeginTransientPropertyUpdate* begintransientpropertyupdate);
  private:
  const ::ServerData::BeginTransientPropertyUpdate& _internal_begintransientpropertyupdate() const;
  ::ServerData::BeginTransientPropertyUpdate* _internal_mutable_begintransientpropertyupdate();
  public:
  void unsafe_arena_set_allocated_begintransientpropertyupdate(
      ::ServerData::BeginTransientPropertyUpdate* begintransientpropertyupdate);
  ::ServerData::BeginTransientPropertyUpdate* unsafe_arena_release_begintransientpropertyupdate();

  // .ServerData.ContinueTransientPropertyUpdate ContinueTransientPropertyUpdate = 55;
  bool has_continuetransientpropertyupdate() const;
  private:
  bool _internal_has_continuetransientpropertyupdate() const;
  public:
  void clear_continuetransientpropertyupdate();
  const ::ServerData::ContinueTransientPropertyUpdate& continuetransientpropertyupdate() const;
  PROTOBUF_NODISCARD ::ServerData::ContinueTransientPropertyUpdate* release_continuetransientpropertyupdate();
  ::ServerData::ContinueTransientPropertyUpdate* mutable_continuetransientpropertyupdate();
  void set_allocated_continuetransientpropertyupdate(::ServerData::ContinueTransientPropertyUpdate* continuetransientpropertyupdate);
  private:
  const ::ServerData::ContinueTransientPropertyUpdate& _internal_continuetransientpropertyupdate() const;
  ::ServerData::ContinueTransientPropertyUpdate* _internal_mutable_continuetransientpropertyupdate();
  public:
  void unsafe_arena_set_allocated_continuetransientpropertyupdate(
      ::ServerData::ContinueTransientPropertyUpdate* continuetransientpropertyupdate);
  ::ServerData::ContinueTransientPropertyUpdate* unsafe_arena_release_continuetransientpropertyupdate();

  // .ServerData.FinalizeTransientPropertyUpdate FinalizeTransientPropertyUpdate = 56;
  bool has_finalizetransientpropertyupdate() const;
  private:
  bool _internal_has_finalizetransientpropertyupdate() const;
  public:
  void clear_finalizetransientpropertyupdate();
  const ::ServerData::FinalizeTransientPropertyUpdate& finalizetransientpropertyupdate() const;
  PROTOBUF_NODISCARD ::ServerData::FinalizeTransientPropertyUpdate* release_finalizetransientpropertyupdate();
  ::ServerData::FinalizeTransientPropertyUpdate* mutable_finalizetransientpropertyupdate();
  void set_allocated_finalizetransientpropertyupdate(::ServerData::FinalizeTransientPropertyUpdate* finalizetransientpropertyupdate);
  private:
  const ::ServerData::FinalizeTransientPropertyUpdate& _internal_finalizetransientpropertyupdate() const;
  ::ServerData::FinalizeTransientPropertyUpdate* _internal_mutable_finalizetransientpropertyupdate();
  public:
  void unsafe_arena_set_allocated_finalizetransientpropertyupdate(
      ::ServerData::FinalizeTransientPropertyUpdate* finalizetransientpropertyupdate);
  ::ServerData::FinalizeTransientPropertyUpdate* unsafe_arena_release_finalizetransientpropertyupdate();

  // .ServerData.CancelTransientPropertyUpdate CancelTransientPropertyUpdate = 57;
  bool has_canceltransientpropertyupdate() const;
  private:
  bool _internal_has_canceltransientpropertyupdate() const;
  public:
  void clear_canceltransientpropertyupdate();
  const ::ServerData::CancelTransientPropertyUpdate& canceltransientpropertyupdate() const;
  PROTOBUF_NODISCARD ::ServerData::CancelTransientPropertyUpdate* release_canceltransientpropertyupdate();
  ::ServerData::CancelTransientPropertyUpdate* mutable_canceltransientpropertyupdate();
  void set_allocated_canceltransientpropertyupdate(::ServerData::CancelTransientPropertyUpdate* canceltransientpropertyupdate);
  private:
  const ::ServerData::CancelTransientPropertyUpdate& _internal_canceltransientpropertyupdate() const;
  ::ServerData::CancelTransientPropertyUpdate* _internal_mutable_canceltransientpropertyupdate();
  public:
  void unsafe_arena_set_allocated_canceltransientpropertyupdate(
      ::ServerData::CancelTransientPropertyUpdate* canceltransientpropertyupdate);
  ::ServerData::CancelTransientPropertyUpdate* unsafe_arena_release_canceltransientpropertyupdate();

  // .ServerData.UpdateLocalUserMuted UpdateLocalUserMuted = 60;
  bool has_updatelocalusermuted() const;
  private:
  bool _internal_has_updatelocalusermuted() const;
  public:
  void clear_updatelocalusermuted();
  const ::ServerData::UpdateLocalUserMuted& updatelocalusermuted() const;
  PROTOBUF_NODISCARD ::ServerData::UpdateLocalUserMuted* release_updatelocalusermuted();
  ::ServerData::UpdateLocalUserMuted* mutable_updatelocalusermuted();
  void set_allocated_updatelocalusermuted(::ServerData::UpdateLocalUserMuted* updatelocalusermuted);
  private:
  const ::ServerData::UpdateLocalUserMuted& _internal_updatelocalusermuted() const;
  ::ServerData::UpdateLocalUserMuted* _internal_mutable_updatelocalusermuted();
  public:
  void unsafe_arena_set_allocated_updatelocalusermuted(
      ::ServerData::UpdateLocalUserMuted* updatelocalusermuted);
  ::ServerData::UpdateLocalUserMuted* unsafe_arena_release_updatelocalusermuted();

  // .ServerData.UpdateLocalUserCoPresence UpdateLocalUserCoPresence = 61;
  bool has_updatelocalusercopresence() const;
  private:
  bool _internal_has_updatelocalusercopresence() const;
  public:
  void clear_updatelocalusercopresence();
  const ::ServerData::UpdateLocalUserCoPresence& updatelocalusercopresence() const;
  PROTOBUF_NODISCARD ::ServerData::UpdateLocalUserCoPresence* release_updatelocalusercopresence();
  ::ServerData::UpdateLocalUserCoPresence* mutable_updatelocalusercopresence();
  void set_allocated_updatelocalusercopresence(::ServerData::UpdateLocalUserCoPresence* updatelocalusercopresence);
  private:
  const ::ServerData::UpdateLocalUserCoPresence& _internal_updatelocalusercopresence() const;
  ::ServerData::UpdateLocalUserCoPresence* _internal_mutable_updatelocalusercopresence();
  public:
  void unsafe_arena_set_allocated_updatelocalusercopresence(
      ::ServerData::UpdateLocalUserCoPresence* updatelocalusercopresence);
  ::ServerData::UpdateLocalUserCoPresence* unsafe_arena_release_updatelocalusercopresence();

  // .ServerData.UpdateLocalUserStreamState UpdateLocalUserStreamState = 62;
  bool has_updatelocaluserstreamstate() const;
  private:
  bool _internal_has_updatelocaluserstreamstate() const;
  public:
  void clear_updatelocaluserstreamstate();
  const ::ServerData::UpdateLocalUserStreamState& updatelocaluserstreamstate() const;
  PROTOBUF_NODISCARD ::ServerData::UpdateLocalUserStreamState* release_updatelocaluserstreamstate();
  ::ServerData::UpdateLocalUserStreamState* mutable_updatelocaluserstreamstate();
  void set_allocated_updatelocaluserstreamstate(::ServerData::UpdateLocalUserStreamState* updatelocaluserstreamstate);
  private:
  const ::ServerData::UpdateLocalUserStreamState& _internal_updatelocaluserstreamstate() const;
  ::ServerData::UpdateLocalUserStreamState* _internal_mutable_updatelocaluserstreamstate();
  public:
  void unsafe_arena_set_allocated_updatelocaluserstreamstate(
      ::ServerData::UpdateLocalUserStreamState* updatelocaluserstreamstate);
  ::ServerData::UpdateLocalUserStreamState* unsafe_arena_release_updatelocaluserstreamstate();

  // .ServerData.PostCreateObject PostCreateObject = 70;
  bool has_postcreateobject() const;
  private:
  bool _internal_has_postcreateobject() const;
  public:
  void clear_postcreateobject();
  const ::ServerData::PostCreateObject& postcreateobject() const;
  PROTOBUF_NODISCARD ::ServerData::PostCreateObject* release_postcreateobject();
  ::ServerData::PostCreateObject* mutable_postcreateobject();
  void set_allocated_postcreateobject(::ServerData::PostCreateObject* postcreateobject);
  private:
  const ::ServerData::PostCreateObject& _internal_postcreateobject() const;
  ::ServerData::PostCreateObject* _internal_mutable_postcreateobject();
  public:
  void unsafe_arena_set_allocated_postcreateobject(
      ::ServerData::PostCreateObject* postcreateobject);
  ::ServerData::PostCreateObject* unsafe_arena_release_postcreateobject();

  // .ServerData.PostRemoveObject PostRemoveObject = 71;
  bool has_postremoveobject() const;
  private:
  bool _internal_has_postremoveobject() const;
  public:
  void clear_postremoveobject();
  const ::ServerData::PostRemoveObject& postremoveobject() const;
  PROTOBUF_NODISCARD ::ServerData::PostRemoveObject* release_postremoveobject();
  ::ServerData::PostRemoveObject* mutable_postremoveobject();
  void set_allocated_postremoveobject(::ServerData::PostRemoveObject* postremoveobject);
  private:
  const ::ServerData::PostRemoveObject& _internal_postremoveobject() const;
  ::ServerData::PostRemoveObject* _internal_mutable_postremoveobject();
  public:
  void unsafe_arena_set_allocated_postremoveobject(
      ::ServerData::PostRemoveObject* postremoveobject);
  ::ServerData::PostRemoveObject* unsafe_arena_release_postremoveobject();

  // .ServerData.PermissionStatusReq PermissionStatusReq = 90;
  bool has_permissionstatusreq() const;
  private:
  bool _internal_has_permissionstatusreq() const;
  public:
  void clear_permissionstatusreq();
  const ::ServerData::PermissionStatusReq& permissionstatusreq() const;
  PROTOBUF_NODISCARD ::ServerData::PermissionStatusReq* release_permissionstatusreq();
  ::ServerData::PermissionStatusReq* mutable_permissionstatusreq();
  void set_allocated_permissionstatusreq(::ServerData::PermissionStatusReq* permissionstatusreq);
  private:
  const ::ServerData::PermissionStatusReq& _internal_permissionstatusreq() const;
  ::ServerData::PermissionStatusReq* _internal_mutable_permissionstatusreq();
  public:
  void unsafe_arena_set_allocated_permissionstatusreq(
      ::ServerData::PermissionStatusReq* permissionstatusreq);
  ::ServerData::PermissionStatusReq* unsafe_arena_release_permissionstatusreq();

  // .ServerData.AllJoinableSpacesReq AllJoinableSpacesReq = 100;
  bool has_alljoinablespacesreq() const;
  private:
  bool _internal_has_alljoinablespacesreq() const;
  public:
  void clear_alljoinablespacesreq();
  const ::ServerData::AllJoinableSpacesReq& alljoinablespacesreq() const;
  PROTOBUF_NODISCARD ::ServerData::AllJoinableSpacesReq* release_alljoinablespacesreq();
  ::ServerData::AllJoinableSpacesReq* mutable_alljoinablespacesreq();
  void set_allocated_alljoinablespacesreq(::ServerData::AllJoinableSpacesReq* alljoinablespacesreq);
  private:
  const ::ServerData::AllJoinableSpacesReq& _internal_alljoinablespacesreq() const;
  ::ServerData::AllJoinableSpacesReq* _internal_mutable_alljoinablespacesreq();
  public:
  void unsafe_arena_set_allocated_alljoinablespacesreq(
      ::ServerData::AllJoinableSpacesReq* alljoinablespacesreq);
  ::ServerData::AllJoinableSpacesReq* unsafe_arena_release_alljoinablespacesreq();

  // .ServerData.GetSpaceInfoReq GetSpaceInfoReq = 101;
  bool has_getspaceinforeq() const;
  private:
  bool _internal_has_getspaceinforeq() const;
  public:
  void clear_getspaceinforeq();
  const ::ServerData::GetSpaceInfoReq& getspaceinforeq() const;
  PROTOBUF_NODISCARD ::ServerData::GetSpaceInfoReq* release_getspaceinforeq();
  ::ServerData::GetSpaceInfoReq* mutable_getspaceinforeq();
  void set_allocated_getspaceinforeq(::ServerData::GetSpaceInfoReq* getspaceinforeq);
  private:
  const ::ServerData::GetSpaceInfoReq& _internal_getspaceinforeq() const;
  ::ServerData::GetSpaceInfoReq* _internal_mutable_getspaceinforeq();
  public:
  void unsafe_arena_set_allocated_getspaceinforeq(
      ::ServerData::GetSpaceInfoReq* getspaceinforeq);
  ::ServerData::GetSpaceInfoReq* unsafe_arena_release_getspaceinforeq();

  // .ServerData.FetchFileByIdReq FetchFileByIdReq = 110;
  bool has_fetchfilebyidreq() const;
  private:
  bool _internal_has_fetchfilebyidreq() const;
  public:
  void clear_fetchfilebyidreq();
  const ::ServerData::FetchFileByIdReq& fetchfilebyidreq() const;
  PROTOBUF_NODISCARD ::ServerData::FetchFileByIdReq* release_fetchfilebyidreq();
  ::ServerData::FetchFileByIdReq* mutable_fetchfilebyidreq();
  void set_allocated_fetchfilebyidreq(::ServerData::FetchFileByIdReq* fetchfilebyidreq);
  private:
  const ::ServerData::FetchFileByIdReq& _internal_fetchfilebyidreq() const;
  ::ServerData::FetchFileByIdReq* _internal_mutable_fetchfilebyidreq();
  public:
  void unsafe_arena_set_allocated_fetchfilebyidreq(
      ::ServerData::FetchFileByIdReq* fetchfilebyidreq);
  ::ServerData::FetchFileByIdReq* unsafe_arena_release_fetchfilebyidreq();

  // .ServerData.FetchAllUploadedContentReq FetchAllUploadedContentReq = 111;
  bool has_fetchalluploadedcontentreq() const;
  private:
  bool _internal_has_fetchalluploadedcontentreq() const;
  public:
  void clear_fetchalluploadedcontentreq();
  const ::ServerData::FetchAllUploadedContentReq& fetchalluploadedcontentreq() const;
  PROTOBUF_NODISCARD ::ServerData::FetchAllUploadedContentReq* release_fetchalluploadedcontentreq();
  ::ServerData::FetchAllUploadedContentReq* mutable_fetchalluploadedcontentreq();
  void set_allocated_fetchalluploadedcontentreq(::ServerData::FetchAllUploadedContentReq* fetchalluploadedcontentreq);
  private:
  const ::ServerData::FetchAllUploadedContentReq& _internal_fetchalluploadedcontentreq() const;
  ::ServerData::FetchAllUploadedContentReq* _internal_mutable_fetchalluploadedcontentreq();
  public:
  void unsafe_arena_set_allocated_fetchalluploadedcontentreq(
      ::ServerData::FetchAllUploadedContentReq* fetchalluploadedcontentreq);
  ::ServerData::FetchAllUploadedContentReq* unsafe_arena_release_fetchalluploadedcontentreq();

  // .ServerData.UploadLocalFileReq UploadLocalFileReq = 112;
  bool has_uploadlocalfilereq() const;
  private:
  bool _internal_has_uploadlocalfilereq() const;
  public:
  void clear_uploadlocalfilereq();
  const ::ServerData::UploadLocalFileReq& uploadlocalfilereq() const;
  PROTOBUF_NODISCARD ::ServerData::UploadLocalFileReq* release_uploadlocalfilereq();
  ::ServerData::UploadLocalFileReq* mutable_uploadlocalfilereq();
  void set_allocated_uploadlocalfilereq(::ServerData::UploadLocalFileReq* uploadlocalfilereq);
  private:
  const ::ServerData::UploadLocalFileReq& _internal_uploadlocalfilereq() const;
  ::ServerData::UploadLocalFileReq* _internal_mutable_uploadlocalfilereq();
  public:
  void unsafe_arena_set_allocated_uploadlocalfilereq(
      ::ServerData::UploadLocalFileReq* uploadlocalfilereq);
  ::ServerData::UploadLocalFileReq* unsafe_arena_release_uploadlocalfilereq();

  // .ServerData.ContentDestinationFolderReq ContentDestinationFolderReq = 113;
  bool has_contentdestinationfolderreq() const;
  private:
  bool _internal_has_contentdestinationfolderreq() const;
  public:
  void clear_contentdestinationfolderreq();
  const ::ServerData::ContentDestinationFolderReq& contentdestinationfolderreq() const;
  PROTOBUF_NODISCARD ::ServerData::ContentDestinationFolderReq* release_contentdestinationfolderreq();
  ::ServerData::ContentDestinationFolderReq* mutable_contentdestinationfolderreq();
  void set_allocated_contentdestinationfolderreq(::ServerData::ContentDestinationFolderReq* contentdestinationfolderreq);
  private:
  const ::ServerData::ContentDestinationFolderReq& _internal_contentdestinationfolderreq() const;
  ::ServerData::ContentDestinationFolderReq* _internal_mutable_contentdestinationfolderreq();
  public:
  void unsafe_arena_set_allocated_contentdestinationfolderreq(
      ::ServerData::ContentDestinationFolderReq* contentdestinationfolderreq);
  ::ServerData::ContentDestinationFolderReq* unsafe_arena_release_contentdestinationfolderreq();

  // .ServerData.FetchRemoteContentInfoReq FetchRemoteContentInfoReq = 114;
  bool has_fetchremotecontentinforeq() const;
  private:
  bool _internal_has_fetchremotecontentinforeq() const;
  public:
  void clear_fetchremotecontentinforeq();
  const ::ServerData::FetchRemoteContentInfoReq& fetchremotecontentinforeq() const;
  PROTOBUF_NODISCARD ::ServerData::FetchRemoteContentInfoReq* release_fetchremotecontentinforeq();
  ::ServerData::FetchRemoteContentInfoReq* mutable_fetchremotecontentinforeq();
  void set_allocated_fetchremotecontentinforeq(::ServerData::FetchRemoteContentInfoReq* fetchremotecontentinforeq);
  private:
  const ::ServerData::FetchRemoteContentInfoReq& _internal_fetchremotecontentinforeq() const;
  ::ServerData::FetchRemoteContentInfoReq* _internal_mutable_fetchremotecontentinforeq();
  public:
  void unsafe_arena_set_allocated_fetchremotecontentinforeq(
      ::ServerData::FetchRemoteContentInfoReq* fetchremotecontentinforeq);
  ::ServerData::FetchRemoteContentInfoReq* unsafe_arena_release_fetchremotecontentinforeq();

  // .ServerData.PostChat PostChat = 120;
  bool has_postchat() const;
  private:
  bool _internal_has_postchat() const;
  public:
  void clear_postchat();
  const ::ServerData::PostChat& postchat() const;
  PROTOBUF_NODISCARD ::ServerData::PostChat* release_postchat();
  ::ServerData::PostChat* mutable_postchat();
  void set_allocated_postchat(::ServerData::PostChat* postchat);
  private:
  const ::ServerData::PostChat& _internal_postchat() const;
  ::ServerData::PostChat* _internal_mutable_postchat();
  public:
  void unsafe_arena_set_allocated_postchat(
      ::ServerData::PostChat* postchat);
  ::ServerData::PostChat* unsafe_arena_release_postchat();

  // .ServerData.QueryAiReq QueryAiReq = 130;
  bool has_queryaireq() const;
  private:
  bool _internal_has_queryaireq() const;
  public:
  void clear_queryaireq();
  const ::ServerData::QueryAiReq& queryaireq() const;
  PROTOBUF_NODISCARD ::ServerData::QueryAiReq* release_queryaireq();
  ::ServerData::QueryAiReq* mutable_queryaireq();
  void set_allocated_queryaireq(::ServerData::QueryAiReq* queryaireq);
  private:
  const ::ServerData::QueryAiReq& _internal_queryaireq() const;
  ::ServerData::QueryAiReq* _internal_mutable_queryaireq();
  public:
  void unsafe_arena_set_allocated_queryaireq(
      ::ServerData::QueryAiReq* queryaireq);
  ::ServerData::QueryAiReq* unsafe_arena_release_queryaireq();

  void clear_Msg();
  MsgCase Msg_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.RelayClientMessage)
 private:
  class _Internal;
  void set_has_keepalive();
  void set_has_updatetime();
  void set_has_setforcekeepalive();
  void set_has_endforcekeepalive();
  void set_has_postdatacacheupdate();
  void set_has_authenticatereq();
  void set_has_authenticateapikeyreq();
  void set_has_authenticateguestreq();
  void set_has_authenticatedevicecodebeginreq();
  void set_has_authenticatedevicecodeconcludereq();
  void set_has_exitallspacesandlogoutreq();
  void set_has_authenticatetokenreq();
  void set_has_checkserverstatusreq();
  void set_has_constructapikeyreq();
  void set_has_joinspacefromidreq();
  void set_has_shutdownspaceconnectionreq();
  void set_has_createspacereq();
  void set_has_fetchalluseraccountsreq();
  void set_has_inviteuseraccounttospacereq();
  void set_has_removeuseraccountfromspacereq();
  void set_has_fetchalluserrolesreq();
  void set_has_deletespacereq();
  void set_has_renamespacereq();
  void set_has_updatethumbnailforspacereq();
  void set_has_getaudioinputdevicesreq();
  void set_has_getaudiooutputdevicesreq();
  void set_has_getvideoinputdevicesreq();
  void set_has_setaudioinputdevicereq();
  void set_has_setaudiooutputdevicereq();
  void set_has_setvideoinputdevicereq();
  void set_has_definepropertydefaultvalue();
  void set_has_postpropertyupdate();
  void set_has_begintransientpropertyupdate();
  void set_has_continuetransientpropertyupdate();
  void set_has_finalizetransientpropertyupdate();
  void set_has_canceltransientpropertyupdate();
  void set_has_updatelocalusermuted();
  void set_has_updatelocalusercopresence();
  void set_has_updatelocaluserstreamstate();
  void set_has_postcreateobject();
  void set_has_postremoveobject();
  void set_has_permissionstatusreq();
  void set_has_alljoinablespacesreq();
  void set_has_getspaceinforeq();
  void set_has_fetchfilebyidreq();
  void set_has_fetchalluploadedcontentreq();
  void set_has_uploadlocalfilereq();
  void set_has_contentdestinationfolderreq();
  void set_has_fetchremotecontentinforeq();
  void set_has_postchat();
  void set_has_queryaireq();

  inline bool has_Msg() const;
  inline void clear_has_Msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MsgUnion {
      constexpr MsgUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ServerData::KeepAlive* keepalive_;
      ::ServerData::UpdateTime* updatetime_;
      ::ServerData::SetForceKeepAlive* setforcekeepalive_;
      ::ServerData::EndForceKeepAlive* endforcekeepalive_;
      ::ServerData::PostDataCacheUpdate* postdatacacheupdate_;
      ::ServerData::AuthenticateReq* authenticatereq_;
      ::ServerData::AuthenticateApiKeyReq* authenticateapikeyreq_;
      ::ServerData::AuthenticateGuestReq* authenticateguestreq_;
      ::ServerData::AuthenticateDeviceCodeBeginReq* authenticatedevicecodebeginreq_;
      ::ServerData::AuthenticateDeviceCodeConcludeReq* authenticatedevicecodeconcludereq_;
      ::ServerData::ExitAllSpacesAndLogoutReq* exitallspacesandlogoutreq_;
      ::ServerData::AuthenticateTokenReq* authenticatetokenreq_;
      ::ServerData::CheckServerStatusReq* checkserverstatusreq_;
      ::ServerData::ConstructApiKeyReq* constructapikeyreq_;
      ::ServerData::JoinSpaceFromIdReq* joinspacefromidreq_;
      ::ServerData::ShutdownSpaceConnectionReq* shutdownspaceconnectionreq_;
      ::ServerData::CreateSpaceReq* createspacereq_;
      ::ServerData::FetchAllUserAccountsReq* fetchalluseraccountsreq_;
      ::ServerData::InviteUserAccountToSpaceReq* inviteuseraccounttospacereq_;
      ::ServerData::RemoveUserAccountFromSpaceReq* removeuseraccountfromspacereq_;
      ::ServerData::FetchAllUserRolesReq* fetchalluserrolesreq_;
      ::ServerData::DeleteSpaceReq* deletespacereq_;
      ::ServerData::RenameSpaceReq* renamespacereq_;
      ::ServerData::UpdateThumbnailForSpaceReq* updatethumbnailforspacereq_;
      ::ServerData::GetAudioInputDevicesReq* getaudioinputdevicesreq_;
      ::ServerData::GetAudioOutputDevicesReq* getaudiooutputdevicesreq_;
      ::ServerData::GetVideoInputDevicesReq* getvideoinputdevicesreq_;
      ::ServerData::SetAudioInputDeviceReq* setaudioinputdevicereq_;
      ::ServerData::SetAudioOutputDeviceReq* setaudiooutputdevicereq_;
      ::ServerData::SetVideoInputDeviceReq* setvideoinputdevicereq_;
      ::ServerData::DefinePropertyDefaultValue* definepropertydefaultvalue_;
      ::ServerData::PostPropertyUpdate* postpropertyupdate_;
      ::ServerData::BeginTransientPropertyUpdate* begintransientpropertyupdate_;
      ::ServerData::ContinueTransientPropertyUpdate* continuetransientpropertyupdate_;
      ::ServerData::FinalizeTransientPropertyUpdate* finalizetransientpropertyupdate_;
      ::ServerData::CancelTransientPropertyUpdate* canceltransientpropertyupdate_;
      ::ServerData::UpdateLocalUserMuted* updatelocalusermuted_;
      ::ServerData::UpdateLocalUserCoPresence* updatelocalusercopresence_;
      ::ServerData::UpdateLocalUserStreamState* updatelocaluserstreamstate_;
      ::ServerData::PostCreateObject* postcreateobject_;
      ::ServerData::PostRemoveObject* postremoveobject_;
      ::ServerData::PermissionStatusReq* permissionstatusreq_;
      ::ServerData::AllJoinableSpacesReq* alljoinablespacesreq_;
      ::ServerData::GetSpaceInfoReq* getspaceinforeq_;
      ::ServerData::FetchFileByIdReq* fetchfilebyidreq_;
      ::ServerData::FetchAllUploadedContentReq* fetchalluploadedcontentreq_;
      ::ServerData::UploadLocalFileReq* uploadlocalfilereq_;
      ::ServerData::ContentDestinationFolderReq* contentdestinationfolderreq_;
      ::ServerData::FetchRemoteContentInfoReq* fetchremotecontentinforeq_;
      ::ServerData::PostChat* postchat_;
      ::ServerData::QueryAiReq* queryaireq_;
    } Msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class RelayRemoteMessageBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RelayRemoteMessageBatch) */ {
 public:
  inline RelayRemoteMessageBatch() : RelayRemoteMessageBatch(nullptr) {}
  ~RelayRemoteMessageBatch() override;
  explicit PROTOBUF_CONSTEXPR RelayRemoteMessageBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayRemoteMessageBatch(const RelayRemoteMessageBatch& from);
  RelayRemoteMessageBatch(RelayRemoteMessageBatch&& from) noexcept
    : RelayRemoteMessageBatch() {
    *this = ::std::move(from);
  }

  inline RelayRemoteMessageBatch& operator=(const RelayRemoteMessageBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayRemoteMessageBatch& operator=(RelayRemoteMessageBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelayRemoteMessageBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelayRemoteMessageBatch* internal_default_instance() {
    return reinterpret_cast<const RelayRemoteMessageBatch*>(
               &_RelayRemoteMessageBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RelayRemoteMessageBatch& a, RelayRemoteMessageBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayRemoteMessageBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayRemoteMessageBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayRemoteMessageBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayRemoteMessageBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelayRemoteMessageBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelayRemoteMessageBatch& from) {
    RelayRemoteMessageBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelayRemoteMessageBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RelayRemoteMessageBatch";
  }
  protected:
  explicit RelayRemoteMessageBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated .ServerData.RelayRemoteMessage Messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::ServerData::RelayRemoteMessage* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayRemoteMessage >*
      mutable_messages();
  private:
  const ::ServerData::RelayRemoteMessage& _internal_messages(int index) const;
  ::ServerData::RelayRemoteMessage* _internal_add_messages();
  public:
  const ::ServerData::RelayRemoteMessage& messages(int index) const;
  ::ServerData::RelayRemoteMessage* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayRemoteMessage >&
      messages() const;

  // @@protoc_insertion_point(class_scope:ServerData.RelayRemoteMessageBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayRemoteMessage > messages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class RelayRemoteMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RelayRemoteMessage) */ {
 public:
  inline RelayRemoteMessage() : RelayRemoteMessage(nullptr) {}
  ~RelayRemoteMessage() override;
  explicit PROTOBUF_CONSTEXPR RelayRemoteMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayRemoteMessage(const RelayRemoteMessage& from);
  RelayRemoteMessage(RelayRemoteMessage&& from) noexcept
    : RelayRemoteMessage() {
    *this = ::std::move(from);
  }

  inline RelayRemoteMessage& operator=(const RelayRemoteMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayRemoteMessage& operator=(RelayRemoteMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelayRemoteMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kMessage = 1,
    kAuthenticateResp = 2,
    kExitAllSpacesAndLogoutResp = 4,
    kRelayDataCache = 5,
    kAuthenticateDeviceCodeBeginResp = 18,
    kConstructApiKeyResp = 19,
    kGenericResponse = 6,
    kServerMessageResp = 7,
    kConnectionStatusResp = 8,
    kJoinSpaceFromIdResp = 10,
    kShutdownSpaceConnectionResp = 11,
    kCreateSpaceResp = 12,
    kCheckServerStatusResp = 17,
    kGetAudioInputDevicesResp = 20,
    kGetAudioOutputDevicesResp = 21,
    kGetVideoInputDevicesResp = 22,
    kFetchAllUserAccountsResp = 23,
    kFetchAllUserRolesResp = 26,
    kPropertyValueStatus = 50,
    kLocalPropertyHandledResp = 51,
    kPropMetadataStatus = 52,
    kUserAdded = 60,
    kUserRemoved = 61,
    kUserVideoFrame = 65,
    kSpaceAdded = 70,
    kSpaceUpdated = 71,
    kSpaceRemoved = 72,
    kObjectAdded = 80,
    kObjectRemoved = 81,
    kPermissionStatus = 90,
    kAllJoinableSpacesResp = 100,
    kGetSpaceInfoResp = 101,
    kFetchFileByIdProgressResp = 110,
    kFetchFileByIdCompletedResp = 111,
    kFetchFileByIdFailureResp = 119,
    kFetchAllUploadedContentResp = 112,
    kUploadLocalFileResp = 113,
    kContentDestinationFolderResp = 114,
    kFetchRemoteContentInfoResp = 115,
    kRemoteContentAdded = 116,
    kRemoteContentRemoved = 117,
    kUploadLocalFileProgressResp = 118,
    kChatAdded = 120,
    kChatUpdated = 121,
    kChatRemoved = 122,
    kQueryAiResp = 130,
    MSG_NOT_SET = 0,
  };

  static inline const RelayRemoteMessage* internal_default_instance() {
    return reinterpret_cast<const RelayRemoteMessage*>(
               &_RelayRemoteMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RelayRemoteMessage& a, RelayRemoteMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayRemoteMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayRemoteMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayRemoteMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayRemoteMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelayRemoteMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelayRemoteMessage& from) {
    RelayRemoteMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelayRemoteMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RelayRemoteMessage";
  }
  protected:
  explicit RelayRemoteMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kAuthenticateRespFieldNumber = 2,
    kExitAllSpacesAndLogoutRespFieldNumber = 4,
    kRelayDataCacheFieldNumber = 5,
    kAuthenticateDeviceCodeBeginRespFieldNumber = 18,
    kConstructApiKeyRespFieldNumber = 19,
    kGenericResponseFieldNumber = 6,
    kServerMessageRespFieldNumber = 7,
    kConnectionStatusRespFieldNumber = 8,
    kJoinSpaceFromIdRespFieldNumber = 10,
    kShutdownSpaceConnectionRespFieldNumber = 11,
    kCreateSpaceRespFieldNumber = 12,
    kCheckServerStatusRespFieldNumber = 17,
    kGetAudioInputDevicesRespFieldNumber = 20,
    kGetAudioOutputDevicesRespFieldNumber = 21,
    kGetVideoInputDevicesRespFieldNumber = 22,
    kFetchAllUserAccountsRespFieldNumber = 23,
    kFetchAllUserRolesRespFieldNumber = 26,
    kPropertyValueStatusFieldNumber = 50,
    kLocalPropertyHandledRespFieldNumber = 51,
    kPropMetadataStatusFieldNumber = 52,
    kUserAddedFieldNumber = 60,
    kUserRemovedFieldNumber = 61,
    kUserVideoFrameFieldNumber = 65,
    kSpaceAddedFieldNumber = 70,
    kSpaceUpdatedFieldNumber = 71,
    kSpaceRemovedFieldNumber = 72,
    kObjectAddedFieldNumber = 80,
    kObjectRemovedFieldNumber = 81,
    kPermissionStatusFieldNumber = 90,
    kAllJoinableSpacesRespFieldNumber = 100,
    kGetSpaceInfoRespFieldNumber = 101,
    kFetchFileByIdProgressRespFieldNumber = 110,
    kFetchFileByIdCompletedRespFieldNumber = 111,
    kFetchFileByIdFailureRespFieldNumber = 119,
    kFetchAllUploadedContentRespFieldNumber = 112,
    kUploadLocalFileRespFieldNumber = 113,
    kContentDestinationFolderRespFieldNumber = 114,
    kFetchRemoteContentInfoRespFieldNumber = 115,
    kRemoteContentAddedFieldNumber = 116,
    kRemoteContentRemovedFieldNumber = 117,
    kUploadLocalFileProgressRespFieldNumber = 118,
    kChatAddedFieldNumber = 120,
    kChatUpdatedFieldNumber = 121,
    kChatRemovedFieldNumber = 122,
    kQueryAiRespFieldNumber = 130,
  };
  // .ServerData.StatusMessage Message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::ServerData::StatusMessage& message() const;
  PROTOBUF_NODISCARD ::ServerData::StatusMessage* release_message();
  ::ServerData::StatusMessage* mutable_message();
  void set_allocated_message(::ServerData::StatusMessage* message);
  private:
  const ::ServerData::StatusMessage& _internal_message() const;
  ::ServerData::StatusMessage* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::ServerData::StatusMessage* message);
  ::ServerData::StatusMessage* unsafe_arena_release_message();

  // .ServerData.AuthenticateResp AuthenticateResp = 2;
  bool has_authenticateresp() const;
  private:
  bool _internal_has_authenticateresp() const;
  public:
  void clear_authenticateresp();
  const ::ServerData::AuthenticateResp& authenticateresp() const;
  PROTOBUF_NODISCARD ::ServerData::AuthenticateResp* release_authenticateresp();
  ::ServerData::AuthenticateResp* mutable_authenticateresp();
  void set_allocated_authenticateresp(::ServerData::AuthenticateResp* authenticateresp);
  private:
  const ::ServerData::AuthenticateResp& _internal_authenticateresp() const;
  ::ServerData::AuthenticateResp* _internal_mutable_authenticateresp();
  public:
  void unsafe_arena_set_allocated_authenticateresp(
      ::ServerData::AuthenticateResp* authenticateresp);
  ::ServerData::AuthenticateResp* unsafe_arena_release_authenticateresp();

  // .ServerData.ExitAllSpacesAndLogoutResp ExitAllSpacesAndLogoutResp = 4;
  bool has_exitallspacesandlogoutresp() const;
  private:
  bool _internal_has_exitallspacesandlogoutresp() const;
  public:
  void clear_exitallspacesandlogoutresp();
  const ::ServerData::ExitAllSpacesAndLogoutResp& exitallspacesandlogoutresp() const;
  PROTOBUF_NODISCARD ::ServerData::ExitAllSpacesAndLogoutResp* release_exitallspacesandlogoutresp();
  ::ServerData::ExitAllSpacesAndLogoutResp* mutable_exitallspacesandlogoutresp();
  void set_allocated_exitallspacesandlogoutresp(::ServerData::ExitAllSpacesAndLogoutResp* exitallspacesandlogoutresp);
  private:
  const ::ServerData::ExitAllSpacesAndLogoutResp& _internal_exitallspacesandlogoutresp() const;
  ::ServerData::ExitAllSpacesAndLogoutResp* _internal_mutable_exitallspacesandlogoutresp();
  public:
  void unsafe_arena_set_allocated_exitallspacesandlogoutresp(
      ::ServerData::ExitAllSpacesAndLogoutResp* exitallspacesandlogoutresp);
  ::ServerData::ExitAllSpacesAndLogoutResp* unsafe_arena_release_exitallspacesandlogoutresp();

  // .ServerData.RelayDataCache RelayDataCache = 5;
  bool has_relaydatacache() const;
  private:
  bool _internal_has_relaydatacache() const;
  public:
  void clear_relaydatacache();
  const ::ServerData::RelayDataCache& relaydatacache() const;
  PROTOBUF_NODISCARD ::ServerData::RelayDataCache* release_relaydatacache();
  ::ServerData::RelayDataCache* mutable_relaydatacache();
  void set_allocated_relaydatacache(::ServerData::RelayDataCache* relaydatacache);
  private:
  const ::ServerData::RelayDataCache& _internal_relaydatacache() const;
  ::ServerData::RelayDataCache* _internal_mutable_relaydatacache();
  public:
  void unsafe_arena_set_allocated_relaydatacache(
      ::ServerData::RelayDataCache* relaydatacache);
  ::ServerData::RelayDataCache* unsafe_arena_release_relaydatacache();

  // .ServerData.AuthenticateDeviceCodeBeginResp AuthenticateDeviceCodeBeginResp = 18;
  bool has_authenticatedevicecodebeginresp() const;
  private:
  bool _internal_has_authenticatedevicecodebeginresp() const;
  public:
  void clear_authenticatedevicecodebeginresp();
  const ::ServerData::AuthenticateDeviceCodeBeginResp& authenticatedevicecodebeginresp() const;
  PROTOBUF_NODISCARD ::ServerData::AuthenticateDeviceCodeBeginResp* release_authenticatedevicecodebeginresp();
  ::ServerData::AuthenticateDeviceCodeBeginResp* mutable_authenticatedevicecodebeginresp();
  void set_allocated_authenticatedevicecodebeginresp(::ServerData::AuthenticateDeviceCodeBeginResp* authenticatedevicecodebeginresp);
  private:
  const ::ServerData::AuthenticateDeviceCodeBeginResp& _internal_authenticatedevicecodebeginresp() const;
  ::ServerData::AuthenticateDeviceCodeBeginResp* _internal_mutable_authenticatedevicecodebeginresp();
  public:
  void unsafe_arena_set_allocated_authenticatedevicecodebeginresp(
      ::ServerData::AuthenticateDeviceCodeBeginResp* authenticatedevicecodebeginresp);
  ::ServerData::AuthenticateDeviceCodeBeginResp* unsafe_arena_release_authenticatedevicecodebeginresp();

  // .ServerData.ConstructApiKeyResp ConstructApiKeyResp = 19;
  bool has_constructapikeyresp() const;
  private:
  bool _internal_has_constructapikeyresp() const;
  public:
  void clear_constructapikeyresp();
  const ::ServerData::ConstructApiKeyResp& constructapikeyresp() const;
  PROTOBUF_NODISCARD ::ServerData::ConstructApiKeyResp* release_constructapikeyresp();
  ::ServerData::ConstructApiKeyResp* mutable_constructapikeyresp();
  void set_allocated_constructapikeyresp(::ServerData::ConstructApiKeyResp* constructapikeyresp);
  private:
  const ::ServerData::ConstructApiKeyResp& _internal_constructapikeyresp() const;
  ::ServerData::ConstructApiKeyResp* _internal_mutable_constructapikeyresp();
  public:
  void unsafe_arena_set_allocated_constructapikeyresp(
      ::ServerData::ConstructApiKeyResp* constructapikeyresp);
  ::ServerData::ConstructApiKeyResp* unsafe_arena_release_constructapikeyresp();

  // .ServerData.GenericResp GenericResponse = 6;
  bool has_genericresponse() const;
  private:
  bool _internal_has_genericresponse() const;
  public:
  void clear_genericresponse();
  const ::ServerData::GenericResp& genericresponse() const;
  PROTOBUF_NODISCARD ::ServerData::GenericResp* release_genericresponse();
  ::ServerData::GenericResp* mutable_genericresponse();
  void set_allocated_genericresponse(::ServerData::GenericResp* genericresponse);
  private:
  const ::ServerData::GenericResp& _internal_genericresponse() const;
  ::ServerData::GenericResp* _internal_mutable_genericresponse();
  public:
  void unsafe_arena_set_allocated_genericresponse(
      ::ServerData::GenericResp* genericresponse);
  ::ServerData::GenericResp* unsafe_arena_release_genericresponse();

  // .ServerData.ServerMessage ServerMessageResp = 7;
  bool has_servermessageresp() const;
  private:
  bool _internal_has_servermessageresp() const;
  public:
  void clear_servermessageresp();
  const ::ServerData::ServerMessage& servermessageresp() const;
  PROTOBUF_NODISCARD ::ServerData::ServerMessage* release_servermessageresp();
  ::ServerData::ServerMessage* mutable_servermessageresp();
  void set_allocated_servermessageresp(::ServerData::ServerMessage* servermessageresp);
  private:
  const ::ServerData::ServerMessage& _internal_servermessageresp() const;
  ::ServerData::ServerMessage* _internal_mutable_servermessageresp();
  public:
  void unsafe_arena_set_allocated_servermessageresp(
      ::ServerData::ServerMessage* servermessageresp);
  ::ServerData::ServerMessage* unsafe_arena_release_servermessageresp();

  // .ServerData.SpaceConnectionStatus ConnectionStatusResp = 8;
  bool has_connectionstatusresp() const;
  private:
  bool _internal_has_connectionstatusresp() const;
  public:
  void clear_connectionstatusresp();
  const ::ServerData::SpaceConnectionStatus& connectionstatusresp() const;
  PROTOBUF_NODISCARD ::ServerData::SpaceConnectionStatus* release_connectionstatusresp();
  ::ServerData::SpaceConnectionStatus* mutable_connectionstatusresp();
  void set_allocated_connectionstatusresp(::ServerData::SpaceConnectionStatus* connectionstatusresp);
  private:
  const ::ServerData::SpaceConnectionStatus& _internal_connectionstatusresp() const;
  ::ServerData::SpaceConnectionStatus* _internal_mutable_connectionstatusresp();
  public:
  void unsafe_arena_set_allocated_connectionstatusresp(
      ::ServerData::SpaceConnectionStatus* connectionstatusresp);
  ::ServerData::SpaceConnectionStatus* unsafe_arena_release_connectionstatusresp();

  // .ServerData.JoinSpaceFromIdResp JoinSpaceFromIdResp = 10;
  bool has_joinspacefromidresp() const;
  private:
  bool _internal_has_joinspacefromidresp() const;
  public:
  void clear_joinspacefromidresp();
  const ::ServerData::JoinSpaceFromIdResp& joinspacefromidresp() const;
  PROTOBUF_NODISCARD ::ServerData::JoinSpaceFromIdResp* release_joinspacefromidresp();
  ::ServerData::JoinSpaceFromIdResp* mutable_joinspacefromidresp();
  void set_allocated_joinspacefromidresp(::ServerData::JoinSpaceFromIdResp* joinspacefromidresp);
  private:
  const ::ServerData::JoinSpaceFromIdResp& _internal_joinspacefromidresp() const;
  ::ServerData::JoinSpaceFromIdResp* _internal_mutable_joinspacefromidresp();
  public:
  void unsafe_arena_set_allocated_joinspacefromidresp(
      ::ServerData::JoinSpaceFromIdResp* joinspacefromidresp);
  ::ServerData::JoinSpaceFromIdResp* unsafe_arena_release_joinspacefromidresp();

  // .ServerData.ShutdownSpaceConnectionResp ShutdownSpaceConnectionResp = 11;
  bool has_shutdownspaceconnectionresp() const;
  private:
  bool _internal_has_shutdownspaceconnectionresp() const;
  public:
  void clear_shutdownspaceconnectionresp();
  const ::ServerData::ShutdownSpaceConnectionResp& shutdownspaceconnectionresp() const;
  PROTOBUF_NODISCARD ::ServerData::ShutdownSpaceConnectionResp* release_shutdownspaceconnectionresp();
  ::ServerData::ShutdownSpaceConnectionResp* mutable_shutdownspaceconnectionresp();
  void set_allocated_shutdownspaceconnectionresp(::ServerData::ShutdownSpaceConnectionResp* shutdownspaceconnectionresp);
  private:
  const ::ServerData::ShutdownSpaceConnectionResp& _internal_shutdownspaceconnectionresp() const;
  ::ServerData::ShutdownSpaceConnectionResp* _internal_mutable_shutdownspaceconnectionresp();
  public:
  void unsafe_arena_set_allocated_shutdownspaceconnectionresp(
      ::ServerData::ShutdownSpaceConnectionResp* shutdownspaceconnectionresp);
  ::ServerData::ShutdownSpaceConnectionResp* unsafe_arena_release_shutdownspaceconnectionresp();

  // .ServerData.CreateSpaceResp CreateSpaceResp = 12;
  bool has_createspaceresp() const;
  private:
  bool _internal_has_createspaceresp() const;
  public:
  void clear_createspaceresp();
  const ::ServerData::CreateSpaceResp& createspaceresp() const;
  PROTOBUF_NODISCARD ::ServerData::CreateSpaceResp* release_createspaceresp();
  ::ServerData::CreateSpaceResp* mutable_createspaceresp();
  void set_allocated_createspaceresp(::ServerData::CreateSpaceResp* createspaceresp);
  private:
  const ::ServerData::CreateSpaceResp& _internal_createspaceresp() const;
  ::ServerData::CreateSpaceResp* _internal_mutable_createspaceresp();
  public:
  void unsafe_arena_set_allocated_createspaceresp(
      ::ServerData::CreateSpaceResp* createspaceresp);
  ::ServerData::CreateSpaceResp* unsafe_arena_release_createspaceresp();

  // .ServerData.CheckServerStatusResp CheckServerStatusResp = 17;
  bool has_checkserverstatusresp() const;
  private:
  bool _internal_has_checkserverstatusresp() const;
  public:
  void clear_checkserverstatusresp();
  const ::ServerData::CheckServerStatusResp& checkserverstatusresp() const;
  PROTOBUF_NODISCARD ::ServerData::CheckServerStatusResp* release_checkserverstatusresp();
  ::ServerData::CheckServerStatusResp* mutable_checkserverstatusresp();
  void set_allocated_checkserverstatusresp(::ServerData::CheckServerStatusResp* checkserverstatusresp);
  private:
  const ::ServerData::CheckServerStatusResp& _internal_checkserverstatusresp() const;
  ::ServerData::CheckServerStatusResp* _internal_mutable_checkserverstatusresp();
  public:
  void unsafe_arena_set_allocated_checkserverstatusresp(
      ::ServerData::CheckServerStatusResp* checkserverstatusresp);
  ::ServerData::CheckServerStatusResp* unsafe_arena_release_checkserverstatusresp();

  // .ServerData.GetAudioInputDevicesResp GetAudioInputDevicesResp = 20;
  bool has_getaudioinputdevicesresp() const;
  private:
  bool _internal_has_getaudioinputdevicesresp() const;
  public:
  void clear_getaudioinputdevicesresp();
  const ::ServerData::GetAudioInputDevicesResp& getaudioinputdevicesresp() const;
  PROTOBUF_NODISCARD ::ServerData::GetAudioInputDevicesResp* release_getaudioinputdevicesresp();
  ::ServerData::GetAudioInputDevicesResp* mutable_getaudioinputdevicesresp();
  void set_allocated_getaudioinputdevicesresp(::ServerData::GetAudioInputDevicesResp* getaudioinputdevicesresp);
  private:
  const ::ServerData::GetAudioInputDevicesResp& _internal_getaudioinputdevicesresp() const;
  ::ServerData::GetAudioInputDevicesResp* _internal_mutable_getaudioinputdevicesresp();
  public:
  void unsafe_arena_set_allocated_getaudioinputdevicesresp(
      ::ServerData::GetAudioInputDevicesResp* getaudioinputdevicesresp);
  ::ServerData::GetAudioInputDevicesResp* unsafe_arena_release_getaudioinputdevicesresp();

  // .ServerData.GetAudioOutputDevicesResp GetAudioOutputDevicesResp = 21;
  bool has_getaudiooutputdevicesresp() const;
  private:
  bool _internal_has_getaudiooutputdevicesresp() const;
  public:
  void clear_getaudiooutputdevicesresp();
  const ::ServerData::GetAudioOutputDevicesResp& getaudiooutputdevicesresp() const;
  PROTOBUF_NODISCARD ::ServerData::GetAudioOutputDevicesResp* release_getaudiooutputdevicesresp();
  ::ServerData::GetAudioOutputDevicesResp* mutable_getaudiooutputdevicesresp();
  void set_allocated_getaudiooutputdevicesresp(::ServerData::GetAudioOutputDevicesResp* getaudiooutputdevicesresp);
  private:
  const ::ServerData::GetAudioOutputDevicesResp& _internal_getaudiooutputdevicesresp() const;
  ::ServerData::GetAudioOutputDevicesResp* _internal_mutable_getaudiooutputdevicesresp();
  public:
  void unsafe_arena_set_allocated_getaudiooutputdevicesresp(
      ::ServerData::GetAudioOutputDevicesResp* getaudiooutputdevicesresp);
  ::ServerData::GetAudioOutputDevicesResp* unsafe_arena_release_getaudiooutputdevicesresp();

  // .ServerData.GetVideoInputDevicesResp GetVideoInputDevicesResp = 22;
  bool has_getvideoinputdevicesresp() const;
  private:
  bool _internal_has_getvideoinputdevicesresp() const;
  public:
  void clear_getvideoinputdevicesresp();
  const ::ServerData::GetVideoInputDevicesResp& getvideoinputdevicesresp() const;
  PROTOBUF_NODISCARD ::ServerData::GetVideoInputDevicesResp* release_getvideoinputdevicesresp();
  ::ServerData::GetVideoInputDevicesResp* mutable_getvideoinputdevicesresp();
  void set_allocated_getvideoinputdevicesresp(::ServerData::GetVideoInputDevicesResp* getvideoinputdevicesresp);
  private:
  const ::ServerData::GetVideoInputDevicesResp& _internal_getvideoinputdevicesresp() const;
  ::ServerData::GetVideoInputDevicesResp* _internal_mutable_getvideoinputdevicesresp();
  public:
  void unsafe_arena_set_allocated_getvideoinputdevicesresp(
      ::ServerData::GetVideoInputDevicesResp* getvideoinputdevicesresp);
  ::ServerData::GetVideoInputDevicesResp* unsafe_arena_release_getvideoinputdevicesresp();

  // .ServerData.FetchAllUserAccountsResp FetchAllUserAccountsResp = 23;
  bool has_fetchalluseraccountsresp() const;
  private:
  bool _internal_has_fetchalluseraccountsresp() const;
  public:
  void clear_fetchalluseraccountsresp();
  const ::ServerData::FetchAllUserAccountsResp& fetchalluseraccountsresp() const;
  PROTOBUF_NODISCARD ::ServerData::FetchAllUserAccountsResp* release_fetchalluseraccountsresp();
  ::ServerData::FetchAllUserAccountsResp* mutable_fetchalluseraccountsresp();
  void set_allocated_fetchalluseraccountsresp(::ServerData::FetchAllUserAccountsResp* fetchalluseraccountsresp);
  private:
  const ::ServerData::FetchAllUserAccountsResp& _internal_fetchalluseraccountsresp() const;
  ::ServerData::FetchAllUserAccountsResp* _internal_mutable_fetchalluseraccountsresp();
  public:
  void unsafe_arena_set_allocated_fetchalluseraccountsresp(
      ::ServerData::FetchAllUserAccountsResp* fetchalluseraccountsresp);
  ::ServerData::FetchAllUserAccountsResp* unsafe_arena_release_fetchalluseraccountsresp();

  // .ServerData.FetchAllUserRolesResp FetchAllUserRolesResp = 26;
  bool has_fetchalluserrolesresp() const;
  private:
  bool _internal_has_fetchalluserrolesresp() const;
  public:
  void clear_fetchalluserrolesresp();
  const ::ServerData::FetchAllUserRolesResp& fetchalluserrolesresp() const;
  PROTOBUF_NODISCARD ::ServerData::FetchAllUserRolesResp* release_fetchalluserrolesresp();
  ::ServerData::FetchAllUserRolesResp* mutable_fetchalluserrolesresp();
  void set_allocated_fetchalluserrolesresp(::ServerData::FetchAllUserRolesResp* fetchalluserrolesresp);
  private:
  const ::ServerData::FetchAllUserRolesResp& _internal_fetchalluserrolesresp() const;
  ::ServerData::FetchAllUserRolesResp* _internal_mutable_fetchalluserrolesresp();
  public:
  void unsafe_arena_set_allocated_fetchalluserrolesresp(
      ::ServerData::FetchAllUserRolesResp* fetchalluserrolesresp);
  ::ServerData::FetchAllUserRolesResp* unsafe_arena_release_fetchalluserrolesresp();

  // .ServerData.PropertyValueStatus PropertyValueStatus = 50;
  bool has_propertyvaluestatus() const;
  private:
  bool _internal_has_propertyvaluestatus() const;
  public:
  void clear_propertyvaluestatus();
  const ::ServerData::PropertyValueStatus& propertyvaluestatus() const;
  PROTOBUF_NODISCARD ::ServerData::PropertyValueStatus* release_propertyvaluestatus();
  ::ServerData::PropertyValueStatus* mutable_propertyvaluestatus();
  void set_allocated_propertyvaluestatus(::ServerData::PropertyValueStatus* propertyvaluestatus);
  private:
  const ::ServerData::PropertyValueStatus& _internal_propertyvaluestatus() const;
  ::ServerData::PropertyValueStatus* _internal_mutable_propertyvaluestatus();
  public:
  void unsafe_arena_set_allocated_propertyvaluestatus(
      ::ServerData::PropertyValueStatus* propertyvaluestatus);
  ::ServerData::PropertyValueStatus* unsafe_arena_release_propertyvaluestatus();

  // .ServerData.LocalPropertyHandledResp LocalPropertyHandledResp = 51;
  bool has_localpropertyhandledresp() const;
  private:
  bool _internal_has_localpropertyhandledresp() const;
  public:
  void clear_localpropertyhandledresp();
  const ::ServerData::LocalPropertyHandledResp& localpropertyhandledresp() const;
  PROTOBUF_NODISCARD ::ServerData::LocalPropertyHandledResp* release_localpropertyhandledresp();
  ::ServerData::LocalPropertyHandledResp* mutable_localpropertyhandledresp();
  void set_allocated_localpropertyhandledresp(::ServerData::LocalPropertyHandledResp* localpropertyhandledresp);
  private:
  const ::ServerData::LocalPropertyHandledResp& _internal_localpropertyhandledresp() const;
  ::ServerData::LocalPropertyHandledResp* _internal_mutable_localpropertyhandledresp();
  public:
  void unsafe_arena_set_allocated_localpropertyhandledresp(
      ::ServerData::LocalPropertyHandledResp* localpropertyhandledresp);
  ::ServerData::LocalPropertyHandledResp* unsafe_arena_release_localpropertyhandledresp();

  // .ServerData.PropMetadataStatus PropMetadataStatus = 52;
  bool has_propmetadatastatus() const;
  private:
  bool _internal_has_propmetadatastatus() const;
  public:
  void clear_propmetadatastatus();
  const ::ServerData::PropMetadataStatus& propmetadatastatus() const;
  PROTOBUF_NODISCARD ::ServerData::PropMetadataStatus* release_propmetadatastatus();
  ::ServerData::PropMetadataStatus* mutable_propmetadatastatus();
  void set_allocated_propmetadatastatus(::ServerData::PropMetadataStatus* propmetadatastatus);
  private:
  const ::ServerData::PropMetadataStatus& _internal_propmetadatastatus() const;
  ::ServerData::PropMetadataStatus* _internal_mutable_propmetadatastatus();
  public:
  void unsafe_arena_set_allocated_propmetadatastatus(
      ::ServerData::PropMetadataStatus* propmetadatastatus);
  ::ServerData::PropMetadataStatus* unsafe_arena_release_propmetadatastatus();

  // .ServerData.UserAdded UserAdded = 60;
  bool has_useradded() const;
  private:
  bool _internal_has_useradded() const;
  public:
  void clear_useradded();
  const ::ServerData::UserAdded& useradded() const;
  PROTOBUF_NODISCARD ::ServerData::UserAdded* release_useradded();
  ::ServerData::UserAdded* mutable_useradded();
  void set_allocated_useradded(::ServerData::UserAdded* useradded);
  private:
  const ::ServerData::UserAdded& _internal_useradded() const;
  ::ServerData::UserAdded* _internal_mutable_useradded();
  public:
  void unsafe_arena_set_allocated_useradded(
      ::ServerData::UserAdded* useradded);
  ::ServerData::UserAdded* unsafe_arena_release_useradded();

  // .ServerData.UserRemoved UserRemoved = 61;
  bool has_userremoved() const;
  private:
  bool _internal_has_userremoved() const;
  public:
  void clear_userremoved();
  const ::ServerData::UserRemoved& userremoved() const;
  PROTOBUF_NODISCARD ::ServerData::UserRemoved* release_userremoved();
  ::ServerData::UserRemoved* mutable_userremoved();
  void set_allocated_userremoved(::ServerData::UserRemoved* userremoved);
  private:
  const ::ServerData::UserRemoved& _internal_userremoved() const;
  ::ServerData::UserRemoved* _internal_mutable_userremoved();
  public:
  void unsafe_arena_set_allocated_userremoved(
      ::ServerData::UserRemoved* userremoved);
  ::ServerData::UserRemoved* unsafe_arena_release_userremoved();

  // .ServerData.UserVideoFrame UserVideoFrame = 65;
  bool has_uservideoframe() const;
  private:
  bool _internal_has_uservideoframe() const;
  public:
  void clear_uservideoframe();
  const ::ServerData::UserVideoFrame& uservideoframe() const;
  PROTOBUF_NODISCARD ::ServerData::UserVideoFrame* release_uservideoframe();
  ::ServerData::UserVideoFrame* mutable_uservideoframe();
  void set_allocated_uservideoframe(::ServerData::UserVideoFrame* uservideoframe);
  private:
  const ::ServerData::UserVideoFrame& _internal_uservideoframe() const;
  ::ServerData::UserVideoFrame* _internal_mutable_uservideoframe();
  public:
  void unsafe_arena_set_allocated_uservideoframe(
      ::ServerData::UserVideoFrame* uservideoframe);
  ::ServerData::UserVideoFrame* unsafe_arena_release_uservideoframe();

  // .ServerData.SpaceInfo SpaceAdded = 70;
  bool has_spaceadded() const;
  private:
  bool _internal_has_spaceadded() const;
  public:
  void clear_spaceadded();
  const ::ServerData::SpaceInfo& spaceadded() const;
  PROTOBUF_NODISCARD ::ServerData::SpaceInfo* release_spaceadded();
  ::ServerData::SpaceInfo* mutable_spaceadded();
  void set_allocated_spaceadded(::ServerData::SpaceInfo* spaceadded);
  private:
  const ::ServerData::SpaceInfo& _internal_spaceadded() const;
  ::ServerData::SpaceInfo* _internal_mutable_spaceadded();
  public:
  void unsafe_arena_set_allocated_spaceadded(
      ::ServerData::SpaceInfo* spaceadded);
  ::ServerData::SpaceInfo* unsafe_arena_release_spaceadded();

  // .ServerData.SpaceInfo SpaceUpdated = 71;
  bool has_spaceupdated() const;
  private:
  bool _internal_has_spaceupdated() const;
  public:
  void clear_spaceupdated();
  const ::ServerData::SpaceInfo& spaceupdated() const;
  PROTOBUF_NODISCARD ::ServerData::SpaceInfo* release_spaceupdated();
  ::ServerData::SpaceInfo* mutable_spaceupdated();
  void set_allocated_spaceupdated(::ServerData::SpaceInfo* spaceupdated);
  private:
  const ::ServerData::SpaceInfo& _internal_spaceupdated() const;
  ::ServerData::SpaceInfo* _internal_mutable_spaceupdated();
  public:
  void unsafe_arena_set_allocated_spaceupdated(
      ::ServerData::SpaceInfo* spaceupdated);
  ::ServerData::SpaceInfo* unsafe_arena_release_spaceupdated();

  // .ServerData.SpaceInfo SpaceRemoved = 72;
  bool has_spaceremoved() const;
  private:
  bool _internal_has_spaceremoved() const;
  public:
  void clear_spaceremoved();
  const ::ServerData::SpaceInfo& spaceremoved() const;
  PROTOBUF_NODISCARD ::ServerData::SpaceInfo* release_spaceremoved();
  ::ServerData::SpaceInfo* mutable_spaceremoved();
  void set_allocated_spaceremoved(::ServerData::SpaceInfo* spaceremoved);
  private:
  const ::ServerData::SpaceInfo& _internal_spaceremoved() const;
  ::ServerData::SpaceInfo* _internal_mutable_spaceremoved();
  public:
  void unsafe_arena_set_allocated_spaceremoved(
      ::ServerData::SpaceInfo* spaceremoved);
  ::ServerData::SpaceInfo* unsafe_arena_release_spaceremoved();

  // .ServerData.ObjectAdded ObjectAdded = 80;
  bool has_objectadded() const;
  private:
  bool _internal_has_objectadded() const;
  public:
  void clear_objectadded();
  const ::ServerData::ObjectAdded& objectadded() const;
  PROTOBUF_NODISCARD ::ServerData::ObjectAdded* release_objectadded();
  ::ServerData::ObjectAdded* mutable_objectadded();
  void set_allocated_objectadded(::ServerData::ObjectAdded* objectadded);
  private:
  const ::ServerData::ObjectAdded& _internal_objectadded() const;
  ::ServerData::ObjectAdded* _internal_mutable_objectadded();
  public:
  void unsafe_arena_set_allocated_objectadded(
      ::ServerData::ObjectAdded* objectadded);
  ::ServerData::ObjectAdded* unsafe_arena_release_objectadded();

  // .ServerData.ObjectRemoved ObjectRemoved = 81;
  bool has_objectremoved() const;
  private:
  bool _internal_has_objectremoved() const;
  public:
  void clear_objectremoved();
  const ::ServerData::ObjectRemoved& objectremoved() const;
  PROTOBUF_NODISCARD ::ServerData::ObjectRemoved* release_objectremoved();
  ::ServerData::ObjectRemoved* mutable_objectremoved();
  void set_allocated_objectremoved(::ServerData::ObjectRemoved* objectremoved);
  private:
  const ::ServerData::ObjectRemoved& _internal_objectremoved() const;
  ::ServerData::ObjectRemoved* _internal_mutable_objectremoved();
  public:
  void unsafe_arena_set_allocated_objectremoved(
      ::ServerData::ObjectRemoved* objectremoved);
  ::ServerData::ObjectRemoved* unsafe_arena_release_objectremoved();

  // .ServerData.PermissionStatus PermissionStatus = 90;
  bool has_permissionstatus() const;
  private:
  bool _internal_has_permissionstatus() const;
  public:
  void clear_permissionstatus();
  const ::ServerData::PermissionStatus& permissionstatus() const;
  PROTOBUF_NODISCARD ::ServerData::PermissionStatus* release_permissionstatus();
  ::ServerData::PermissionStatus* mutable_permissionstatus();
  void set_allocated_permissionstatus(::ServerData::PermissionStatus* permissionstatus);
  private:
  const ::ServerData::PermissionStatus& _internal_permissionstatus() const;
  ::ServerData::PermissionStatus* _internal_mutable_permissionstatus();
  public:
  void unsafe_arena_set_allocated_permissionstatus(
      ::ServerData::PermissionStatus* permissionstatus);
  ::ServerData::PermissionStatus* unsafe_arena_release_permissionstatus();

  // .ServerData.AllJoinableSpacesResp AllJoinableSpacesResp = 100;
  bool has_alljoinablespacesresp() const;
  private:
  bool _internal_has_alljoinablespacesresp() const;
  public:
  void clear_alljoinablespacesresp();
  const ::ServerData::AllJoinableSpacesResp& alljoinablespacesresp() const;
  PROTOBUF_NODISCARD ::ServerData::AllJoinableSpacesResp* release_alljoinablespacesresp();
  ::ServerData::AllJoinableSpacesResp* mutable_alljoinablespacesresp();
  void set_allocated_alljoinablespacesresp(::ServerData::AllJoinableSpacesResp* alljoinablespacesresp);
  private:
  const ::ServerData::AllJoinableSpacesResp& _internal_alljoinablespacesresp() const;
  ::ServerData::AllJoinableSpacesResp* _internal_mutable_alljoinablespacesresp();
  public:
  void unsafe_arena_set_allocated_alljoinablespacesresp(
      ::ServerData::AllJoinableSpacesResp* alljoinablespacesresp);
  ::ServerData::AllJoinableSpacesResp* unsafe_arena_release_alljoinablespacesresp();

  // .ServerData.GetSpaceInfoResp GetSpaceInfoResp = 101;
  bool has_getspaceinforesp() const;
  private:
  bool _internal_has_getspaceinforesp() const;
  public:
  void clear_getspaceinforesp();
  const ::ServerData::GetSpaceInfoResp& getspaceinforesp() const;
  PROTOBUF_NODISCARD ::ServerData::GetSpaceInfoResp* release_getspaceinforesp();
  ::ServerData::GetSpaceInfoResp* mutable_getspaceinforesp();
  void set_allocated_getspaceinforesp(::ServerData::GetSpaceInfoResp* getspaceinforesp);
  private:
  const ::ServerData::GetSpaceInfoResp& _internal_getspaceinforesp() const;
  ::ServerData::GetSpaceInfoResp* _internal_mutable_getspaceinforesp();
  public:
  void unsafe_arena_set_allocated_getspaceinforesp(
      ::ServerData::GetSpaceInfoResp* getspaceinforesp);
  ::ServerData::GetSpaceInfoResp* unsafe_arena_release_getspaceinforesp();

  // .ServerData.FetchFileByIdProgressResp FetchFileByIdProgressResp = 110;
  bool has_fetchfilebyidprogressresp() const;
  private:
  bool _internal_has_fetchfilebyidprogressresp() const;
  public:
  void clear_fetchfilebyidprogressresp();
  const ::ServerData::FetchFileByIdProgressResp& fetchfilebyidprogressresp() const;
  PROTOBUF_NODISCARD ::ServerData::FetchFileByIdProgressResp* release_fetchfilebyidprogressresp();
  ::ServerData::FetchFileByIdProgressResp* mutable_fetchfilebyidprogressresp();
  void set_allocated_fetchfilebyidprogressresp(::ServerData::FetchFileByIdProgressResp* fetchfilebyidprogressresp);
  private:
  const ::ServerData::FetchFileByIdProgressResp& _internal_fetchfilebyidprogressresp() const;
  ::ServerData::FetchFileByIdProgressResp* _internal_mutable_fetchfilebyidprogressresp();
  public:
  void unsafe_arena_set_allocated_fetchfilebyidprogressresp(
      ::ServerData::FetchFileByIdProgressResp* fetchfilebyidprogressresp);
  ::ServerData::FetchFileByIdProgressResp* unsafe_arena_release_fetchfilebyidprogressresp();

  // .ServerData.FetchFileByIdCompletedResp FetchFileByIdCompletedResp = 111;
  bool has_fetchfilebyidcompletedresp() const;
  private:
  bool _internal_has_fetchfilebyidcompletedresp() const;
  public:
  void clear_fetchfilebyidcompletedresp();
  const ::ServerData::FetchFileByIdCompletedResp& fetchfilebyidcompletedresp() const;
  PROTOBUF_NODISCARD ::ServerData::FetchFileByIdCompletedResp* release_fetchfilebyidcompletedresp();
  ::ServerData::FetchFileByIdCompletedResp* mutable_fetchfilebyidcompletedresp();
  void set_allocated_fetchfilebyidcompletedresp(::ServerData::FetchFileByIdCompletedResp* fetchfilebyidcompletedresp);
  private:
  const ::ServerData::FetchFileByIdCompletedResp& _internal_fetchfilebyidcompletedresp() const;
  ::ServerData::FetchFileByIdCompletedResp* _internal_mutable_fetchfilebyidcompletedresp();
  public:
  void unsafe_arena_set_allocated_fetchfilebyidcompletedresp(
      ::ServerData::FetchFileByIdCompletedResp* fetchfilebyidcompletedresp);
  ::ServerData::FetchFileByIdCompletedResp* unsafe_arena_release_fetchfilebyidcompletedresp();

  // .ServerData.FetchFileByIdFailureResp FetchFileByIdFailureResp = 119;
  bool has_fetchfilebyidfailureresp() const;
  private:
  bool _internal_has_fetchfilebyidfailureresp() const;
  public:
  void clear_fetchfilebyidfailureresp();
  const ::ServerData::FetchFileByIdFailureResp& fetchfilebyidfailureresp() const;
  PROTOBUF_NODISCARD ::ServerData::FetchFileByIdFailureResp* release_fetchfilebyidfailureresp();
  ::ServerData::FetchFileByIdFailureResp* mutable_fetchfilebyidfailureresp();
  void set_allocated_fetchfilebyidfailureresp(::ServerData::FetchFileByIdFailureResp* fetchfilebyidfailureresp);
  private:
  const ::ServerData::FetchFileByIdFailureResp& _internal_fetchfilebyidfailureresp() const;
  ::ServerData::FetchFileByIdFailureResp* _internal_mutable_fetchfilebyidfailureresp();
  public:
  void unsafe_arena_set_allocated_fetchfilebyidfailureresp(
      ::ServerData::FetchFileByIdFailureResp* fetchfilebyidfailureresp);
  ::ServerData::FetchFileByIdFailureResp* unsafe_arena_release_fetchfilebyidfailureresp();

  // .ServerData.FetchAllUploadedContentResp FetchAllUploadedContentResp = 112;
  bool has_fetchalluploadedcontentresp() const;
  private:
  bool _internal_has_fetchalluploadedcontentresp() const;
  public:
  void clear_fetchalluploadedcontentresp();
  const ::ServerData::FetchAllUploadedContentResp& fetchalluploadedcontentresp() const;
  PROTOBUF_NODISCARD ::ServerData::FetchAllUploadedContentResp* release_fetchalluploadedcontentresp();
  ::ServerData::FetchAllUploadedContentResp* mutable_fetchalluploadedcontentresp();
  void set_allocated_fetchalluploadedcontentresp(::ServerData::FetchAllUploadedContentResp* fetchalluploadedcontentresp);
  private:
  const ::ServerData::FetchAllUploadedContentResp& _internal_fetchalluploadedcontentresp() const;
  ::ServerData::FetchAllUploadedContentResp* _internal_mutable_fetchalluploadedcontentresp();
  public:
  void unsafe_arena_set_allocated_fetchalluploadedcontentresp(
      ::ServerData::FetchAllUploadedContentResp* fetchalluploadedcontentresp);
  ::ServerData::FetchAllUploadedContentResp* unsafe_arena_release_fetchalluploadedcontentresp();

  // .ServerData.UploadLocalFileResp UploadLocalFileResp = 113;
  bool has_uploadlocalfileresp() const;
  private:
  bool _internal_has_uploadlocalfileresp() const;
  public:
  void clear_uploadlocalfileresp();
  const ::ServerData::UploadLocalFileResp& uploadlocalfileresp() const;
  PROTOBUF_NODISCARD ::ServerData::UploadLocalFileResp* release_uploadlocalfileresp();
  ::ServerData::UploadLocalFileResp* mutable_uploadlocalfileresp();
  void set_allocated_uploadlocalfileresp(::ServerData::UploadLocalFileResp* uploadlocalfileresp);
  private:
  const ::ServerData::UploadLocalFileResp& _internal_uploadlocalfileresp() const;
  ::ServerData::UploadLocalFileResp* _internal_mutable_uploadlocalfileresp();
  public:
  void unsafe_arena_set_allocated_uploadlocalfileresp(
      ::ServerData::UploadLocalFileResp* uploadlocalfileresp);
  ::ServerData::UploadLocalFileResp* unsafe_arena_release_uploadlocalfileresp();

  // .ServerData.ContentDestinationFolderResp ContentDestinationFolderResp = 114;
  bool has_contentdestinationfolderresp() const;
  private:
  bool _internal_has_contentdestinationfolderresp() const;
  public:
  void clear_contentdestinationfolderresp();
  const ::ServerData::ContentDestinationFolderResp& contentdestinationfolderresp() const;
  PROTOBUF_NODISCARD ::ServerData::ContentDestinationFolderResp* release_contentdestinationfolderresp();
  ::ServerData::ContentDestinationFolderResp* mutable_contentdestinationfolderresp();
  void set_allocated_contentdestinationfolderresp(::ServerData::ContentDestinationFolderResp* contentdestinationfolderresp);
  private:
  const ::ServerData::ContentDestinationFolderResp& _internal_contentdestinationfolderresp() const;
  ::ServerData::ContentDestinationFolderResp* _internal_mutable_contentdestinationfolderresp();
  public:
  void unsafe_arena_set_allocated_contentdestinationfolderresp(
      ::ServerData::ContentDestinationFolderResp* contentdestinationfolderresp);
  ::ServerData::ContentDestinationFolderResp* unsafe_arena_release_contentdestinationfolderresp();

  // .ServerData.FetchRemoteContentInfoResp FetchRemoteContentInfoResp = 115;
  bool has_fetchremotecontentinforesp() const;
  private:
  bool _internal_has_fetchremotecontentinforesp() const;
  public:
  void clear_fetchremotecontentinforesp();
  const ::ServerData::FetchRemoteContentInfoResp& fetchremotecontentinforesp() const;
  PROTOBUF_NODISCARD ::ServerData::FetchRemoteContentInfoResp* release_fetchremotecontentinforesp();
  ::ServerData::FetchRemoteContentInfoResp* mutable_fetchremotecontentinforesp();
  void set_allocated_fetchremotecontentinforesp(::ServerData::FetchRemoteContentInfoResp* fetchremotecontentinforesp);
  private:
  const ::ServerData::FetchRemoteContentInfoResp& _internal_fetchremotecontentinforesp() const;
  ::ServerData::FetchRemoteContentInfoResp* _internal_mutable_fetchremotecontentinforesp();
  public:
  void unsafe_arena_set_allocated_fetchremotecontentinforesp(
      ::ServerData::FetchRemoteContentInfoResp* fetchremotecontentinforesp);
  ::ServerData::FetchRemoteContentInfoResp* unsafe_arena_release_fetchremotecontentinforesp();

  // .ServerData.RemoteContentAdded RemoteContentAdded = 116;
  bool has_remotecontentadded() const;
  private:
  bool _internal_has_remotecontentadded() const;
  public:
  void clear_remotecontentadded();
  const ::ServerData::RemoteContentAdded& remotecontentadded() const;
  PROTOBUF_NODISCARD ::ServerData::RemoteContentAdded* release_remotecontentadded();
  ::ServerData::RemoteContentAdded* mutable_remotecontentadded();
  void set_allocated_remotecontentadded(::ServerData::RemoteContentAdded* remotecontentadded);
  private:
  const ::ServerData::RemoteContentAdded& _internal_remotecontentadded() const;
  ::ServerData::RemoteContentAdded* _internal_mutable_remotecontentadded();
  public:
  void unsafe_arena_set_allocated_remotecontentadded(
      ::ServerData::RemoteContentAdded* remotecontentadded);
  ::ServerData::RemoteContentAdded* unsafe_arena_release_remotecontentadded();

  // .ServerData.RemoteContentRemoved RemoteContentRemoved = 117;
  bool has_remotecontentremoved() const;
  private:
  bool _internal_has_remotecontentremoved() const;
  public:
  void clear_remotecontentremoved();
  const ::ServerData::RemoteContentRemoved& remotecontentremoved() const;
  PROTOBUF_NODISCARD ::ServerData::RemoteContentRemoved* release_remotecontentremoved();
  ::ServerData::RemoteContentRemoved* mutable_remotecontentremoved();
  void set_allocated_remotecontentremoved(::ServerData::RemoteContentRemoved* remotecontentremoved);
  private:
  const ::ServerData::RemoteContentRemoved& _internal_remotecontentremoved() const;
  ::ServerData::RemoteContentRemoved* _internal_mutable_remotecontentremoved();
  public:
  void unsafe_arena_set_allocated_remotecontentremoved(
      ::ServerData::RemoteContentRemoved* remotecontentremoved);
  ::ServerData::RemoteContentRemoved* unsafe_arena_release_remotecontentremoved();

  // .ServerData.UploadLocalFileProgressResp UploadLocalFileProgressResp = 118;
  bool has_uploadlocalfileprogressresp() const;
  private:
  bool _internal_has_uploadlocalfileprogressresp() const;
  public:
  void clear_uploadlocalfileprogressresp();
  const ::ServerData::UploadLocalFileProgressResp& uploadlocalfileprogressresp() const;
  PROTOBUF_NODISCARD ::ServerData::UploadLocalFileProgressResp* release_uploadlocalfileprogressresp();
  ::ServerData::UploadLocalFileProgressResp* mutable_uploadlocalfileprogressresp();
  void set_allocated_uploadlocalfileprogressresp(::ServerData::UploadLocalFileProgressResp* uploadlocalfileprogressresp);
  private:
  const ::ServerData::UploadLocalFileProgressResp& _internal_uploadlocalfileprogressresp() const;
  ::ServerData::UploadLocalFileProgressResp* _internal_mutable_uploadlocalfileprogressresp();
  public:
  void unsafe_arena_set_allocated_uploadlocalfileprogressresp(
      ::ServerData::UploadLocalFileProgressResp* uploadlocalfileprogressresp);
  ::ServerData::UploadLocalFileProgressResp* unsafe_arena_release_uploadlocalfileprogressresp();

  // .ServerData.ChatAdded ChatAdded = 120;
  bool has_chatadded() const;
  private:
  bool _internal_has_chatadded() const;
  public:
  void clear_chatadded();
  const ::ServerData::ChatAdded& chatadded() const;
  PROTOBUF_NODISCARD ::ServerData::ChatAdded* release_chatadded();
  ::ServerData::ChatAdded* mutable_chatadded();
  void set_allocated_chatadded(::ServerData::ChatAdded* chatadded);
  private:
  const ::ServerData::ChatAdded& _internal_chatadded() const;
  ::ServerData::ChatAdded* _internal_mutable_chatadded();
  public:
  void unsafe_arena_set_allocated_chatadded(
      ::ServerData::ChatAdded* chatadded);
  ::ServerData::ChatAdded* unsafe_arena_release_chatadded();

  // .ServerData.ChatUpdated ChatUpdated = 121;
  bool has_chatupdated() const;
  private:
  bool _internal_has_chatupdated() const;
  public:
  void clear_chatupdated();
  const ::ServerData::ChatUpdated& chatupdated() const;
  PROTOBUF_NODISCARD ::ServerData::ChatUpdated* release_chatupdated();
  ::ServerData::ChatUpdated* mutable_chatupdated();
  void set_allocated_chatupdated(::ServerData::ChatUpdated* chatupdated);
  private:
  const ::ServerData::ChatUpdated& _internal_chatupdated() const;
  ::ServerData::ChatUpdated* _internal_mutable_chatupdated();
  public:
  void unsafe_arena_set_allocated_chatupdated(
      ::ServerData::ChatUpdated* chatupdated);
  ::ServerData::ChatUpdated* unsafe_arena_release_chatupdated();

  // .ServerData.ChatRemoved ChatRemoved = 122;
  bool has_chatremoved() const;
  private:
  bool _internal_has_chatremoved() const;
  public:
  void clear_chatremoved();
  const ::ServerData::ChatRemoved& chatremoved() const;
  PROTOBUF_NODISCARD ::ServerData::ChatRemoved* release_chatremoved();
  ::ServerData::ChatRemoved* mutable_chatremoved();
  void set_allocated_chatremoved(::ServerData::ChatRemoved* chatremoved);
  private:
  const ::ServerData::ChatRemoved& _internal_chatremoved() const;
  ::ServerData::ChatRemoved* _internal_mutable_chatremoved();
  public:
  void unsafe_arena_set_allocated_chatremoved(
      ::ServerData::ChatRemoved* chatremoved);
  ::ServerData::ChatRemoved* unsafe_arena_release_chatremoved();

  // .ServerData.QueryAiResp QueryAiResp = 130;
  bool has_queryairesp() const;
  private:
  bool _internal_has_queryairesp() const;
  public:
  void clear_queryairesp();
  const ::ServerData::QueryAiResp& queryairesp() const;
  PROTOBUF_NODISCARD ::ServerData::QueryAiResp* release_queryairesp();
  ::ServerData::QueryAiResp* mutable_queryairesp();
  void set_allocated_queryairesp(::ServerData::QueryAiResp* queryairesp);
  private:
  const ::ServerData::QueryAiResp& _internal_queryairesp() const;
  ::ServerData::QueryAiResp* _internal_mutable_queryairesp();
  public:
  void unsafe_arena_set_allocated_queryairesp(
      ::ServerData::QueryAiResp* queryairesp);
  ::ServerData::QueryAiResp* unsafe_arena_release_queryairesp();

  void clear_Msg();
  MsgCase Msg_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.RelayRemoteMessage)
 private:
  class _Internal;
  void set_has_message();
  void set_has_authenticateresp();
  void set_has_exitallspacesandlogoutresp();
  void set_has_relaydatacache();
  void set_has_authenticatedevicecodebeginresp();
  void set_has_constructapikeyresp();
  void set_has_genericresponse();
  void set_has_servermessageresp();
  void set_has_connectionstatusresp();
  void set_has_joinspacefromidresp();
  void set_has_shutdownspaceconnectionresp();
  void set_has_createspaceresp();
  void set_has_checkserverstatusresp();
  void set_has_getaudioinputdevicesresp();
  void set_has_getaudiooutputdevicesresp();
  void set_has_getvideoinputdevicesresp();
  void set_has_fetchalluseraccountsresp();
  void set_has_fetchalluserrolesresp();
  void set_has_propertyvaluestatus();
  void set_has_localpropertyhandledresp();
  void set_has_propmetadatastatus();
  void set_has_useradded();
  void set_has_userremoved();
  void set_has_uservideoframe();
  void set_has_spaceadded();
  void set_has_spaceupdated();
  void set_has_spaceremoved();
  void set_has_objectadded();
  void set_has_objectremoved();
  void set_has_permissionstatus();
  void set_has_alljoinablespacesresp();
  void set_has_getspaceinforesp();
  void set_has_fetchfilebyidprogressresp();
  void set_has_fetchfilebyidcompletedresp();
  void set_has_fetchfilebyidfailureresp();
  void set_has_fetchalluploadedcontentresp();
  void set_has_uploadlocalfileresp();
  void set_has_contentdestinationfolderresp();
  void set_has_fetchremotecontentinforesp();
  void set_has_remotecontentadded();
  void set_has_remotecontentremoved();
  void set_has_uploadlocalfileprogressresp();
  void set_has_chatadded();
  void set_has_chatupdated();
  void set_has_chatremoved();
  void set_has_queryairesp();

  inline bool has_Msg() const;
  inline void clear_has_Msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MsgUnion {
      constexpr MsgUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ServerData::StatusMessage* message_;
      ::ServerData::AuthenticateResp* authenticateresp_;
      ::ServerData::ExitAllSpacesAndLogoutResp* exitallspacesandlogoutresp_;
      ::ServerData::RelayDataCache* relaydatacache_;
      ::ServerData::AuthenticateDeviceCodeBeginResp* authenticatedevicecodebeginresp_;
      ::ServerData::ConstructApiKeyResp* constructapikeyresp_;
      ::ServerData::GenericResp* genericresponse_;
      ::ServerData::ServerMessage* servermessageresp_;
      ::ServerData::SpaceConnectionStatus* connectionstatusresp_;
      ::ServerData::JoinSpaceFromIdResp* joinspacefromidresp_;
      ::ServerData::ShutdownSpaceConnectionResp* shutdownspaceconnectionresp_;
      ::ServerData::CreateSpaceResp* createspaceresp_;
      ::ServerData::CheckServerStatusResp* checkserverstatusresp_;
      ::ServerData::GetAudioInputDevicesResp* getaudioinputdevicesresp_;
      ::ServerData::GetAudioOutputDevicesResp* getaudiooutputdevicesresp_;
      ::ServerData::GetVideoInputDevicesResp* getvideoinputdevicesresp_;
      ::ServerData::FetchAllUserAccountsResp* fetchalluseraccountsresp_;
      ::ServerData::FetchAllUserRolesResp* fetchalluserrolesresp_;
      ::ServerData::PropertyValueStatus* propertyvaluestatus_;
      ::ServerData::LocalPropertyHandledResp* localpropertyhandledresp_;
      ::ServerData::PropMetadataStatus* propmetadatastatus_;
      ::ServerData::UserAdded* useradded_;
      ::ServerData::UserRemoved* userremoved_;
      ::ServerData::UserVideoFrame* uservideoframe_;
      ::ServerData::SpaceInfo* spaceadded_;
      ::ServerData::SpaceInfo* spaceupdated_;
      ::ServerData::SpaceInfo* spaceremoved_;
      ::ServerData::ObjectAdded* objectadded_;
      ::ServerData::ObjectRemoved* objectremoved_;
      ::ServerData::PermissionStatus* permissionstatus_;
      ::ServerData::AllJoinableSpacesResp* alljoinablespacesresp_;
      ::ServerData::GetSpaceInfoResp* getspaceinforesp_;
      ::ServerData::FetchFileByIdProgressResp* fetchfilebyidprogressresp_;
      ::ServerData::FetchFileByIdCompletedResp* fetchfilebyidcompletedresp_;
      ::ServerData::FetchFileByIdFailureResp* fetchfilebyidfailureresp_;
      ::ServerData::FetchAllUploadedContentResp* fetchalluploadedcontentresp_;
      ::ServerData::UploadLocalFileResp* uploadlocalfileresp_;
      ::ServerData::ContentDestinationFolderResp* contentdestinationfolderresp_;
      ::ServerData::FetchRemoteContentInfoResp* fetchremotecontentinforesp_;
      ::ServerData::RemoteContentAdded* remotecontentadded_;
      ::ServerData::RemoteContentRemoved* remotecontentremoved_;
      ::ServerData::UploadLocalFileProgressResp* uploadlocalfileprogressresp_;
      ::ServerData::ChatAdded* chatadded_;
      ::ServerData::ChatUpdated* chatupdated_;
      ::ServerData::ChatRemoved* chatremoved_;
      ::ServerData::QueryAiResp* queryairesp_;
    } Msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class KeepAlive final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ServerData.KeepAlive) */ {
 public:
  inline KeepAlive() : KeepAlive(nullptr) {}
  explicit PROTOBUF_CONSTEXPR KeepAlive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeepAlive(const KeepAlive& from);
  KeepAlive(KeepAlive&& from) noexcept
    : KeepAlive() {
    *this = ::std::move(from);
  }

  inline KeepAlive& operator=(const KeepAlive& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeepAlive& operator=(KeepAlive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeepAlive& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeepAlive* internal_default_instance() {
    return reinterpret_cast<const KeepAlive*>(
               &_KeepAlive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(KeepAlive& a, KeepAlive& b) {
    a.Swap(&b);
  }
  inline void Swap(KeepAlive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeepAlive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeepAlive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeepAlive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const KeepAlive& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const KeepAlive& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.KeepAlive";
  }
  protected:
  explicit KeepAlive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ServerData.KeepAlive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UpdateTime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UpdateTime) */ {
 public:
  inline UpdateTime() : UpdateTime(nullptr) {}
  ~UpdateTime() override;
  explicit PROTOBUF_CONSTEXPR UpdateTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateTime(const UpdateTime& from);
  UpdateTime(UpdateTime&& from) noexcept
    : UpdateTime() {
    *this = ::std::move(from);
  }

  inline UpdateTime& operator=(const UpdateTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTime& operator=(UpdateTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTime* internal_default_instance() {
    return reinterpret_cast<const UpdateTime*>(
               &_UpdateTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateTime& a, UpdateTime& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateTime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateTime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateTime& from) {
    UpdateTime::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UpdateTime";
  }
  protected:
  explicit UpdateTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
  };
  // double time = 1;
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.UpdateTime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class SetForceKeepAlive final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ServerData.SetForceKeepAlive) */ {
 public:
  inline SetForceKeepAlive() : SetForceKeepAlive(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetForceKeepAlive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetForceKeepAlive(const SetForceKeepAlive& from);
  SetForceKeepAlive(SetForceKeepAlive&& from) noexcept
    : SetForceKeepAlive() {
    *this = ::std::move(from);
  }

  inline SetForceKeepAlive& operator=(const SetForceKeepAlive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetForceKeepAlive& operator=(SetForceKeepAlive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetForceKeepAlive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetForceKeepAlive* internal_default_instance() {
    return reinterpret_cast<const SetForceKeepAlive*>(
               &_SetForceKeepAlive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SetForceKeepAlive& a, SetForceKeepAlive& b) {
    a.Swap(&b);
  }
  inline void Swap(SetForceKeepAlive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetForceKeepAlive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetForceKeepAlive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetForceKeepAlive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetForceKeepAlive& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetForceKeepAlive& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.SetForceKeepAlive";
  }
  protected:
  explicit SetForceKeepAlive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ServerData.SetForceKeepAlive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class EndForceKeepAlive final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ServerData.EndForceKeepAlive) */ {
 public:
  inline EndForceKeepAlive() : EndForceKeepAlive(nullptr) {}
  explicit PROTOBUF_CONSTEXPR EndForceKeepAlive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndForceKeepAlive(const EndForceKeepAlive& from);
  EndForceKeepAlive(EndForceKeepAlive&& from) noexcept
    : EndForceKeepAlive() {
    *this = ::std::move(from);
  }

  inline EndForceKeepAlive& operator=(const EndForceKeepAlive& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndForceKeepAlive& operator=(EndForceKeepAlive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndForceKeepAlive& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndForceKeepAlive* internal_default_instance() {
    return reinterpret_cast<const EndForceKeepAlive*>(
               &_EndForceKeepAlive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EndForceKeepAlive& a, EndForceKeepAlive& b) {
    a.Swap(&b);
  }
  inline void Swap(EndForceKeepAlive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndForceKeepAlive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndForceKeepAlive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndForceKeepAlive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EndForceKeepAlive& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EndForceKeepAlive& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.EndForceKeepAlive";
  }
  protected:
  explicit EndForceKeepAlive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ServerData.EndForceKeepAlive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class StatusMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.StatusMessage) */ {
 public:
  inline StatusMessage() : StatusMessage(nullptr) {}
  ~StatusMessage() override;
  explicit PROTOBUF_CONSTEXPR StatusMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusMessage(const StatusMessage& from);
  StatusMessage(StatusMessage&& from) noexcept
    : StatusMessage() {
    *this = ::std::move(from);
  }

  inline StatusMessage& operator=(const StatusMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusMessage& operator=(StatusMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kError = 1,
    kWarning = 2,
    kLog = 3,
    MESSAGE_NOT_SET = 0,
  };

  static inline const StatusMessage* internal_default_instance() {
    return reinterpret_cast<const StatusMessage*>(
               &_StatusMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StatusMessage& a, StatusMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusMessage& from) {
    StatusMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.StatusMessage";
  }
  protected:
  explicit StatusMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kWarningFieldNumber = 2,
    kLogFieldNumber = 3,
  };
  // string error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // string warning = 2;
  bool has_warning() const;
  private:
  bool _internal_has_warning() const;
  public:
  void clear_warning();
  const std::string& warning() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_warning(ArgT0&& arg0, ArgT... args);
  std::string* mutable_warning();
  PROTOBUF_NODISCARD std::string* release_warning();
  void set_allocated_warning(std::string* warning);
  private:
  const std::string& _internal_warning() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_warning(const std::string& value);
  std::string* _internal_mutable_warning();
  public:

  // string log = 3;
  bool has_log() const;
  private:
  bool _internal_has_log() const;
  public:
  void clear_log();
  const std::string& log() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_log(ArgT0&& arg0, ArgT... args);
  std::string* mutable_log();
  PROTOBUF_NODISCARD std::string* release_log();
  void set_allocated_log(std::string* log);
  private:
  const std::string& _internal_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log(const std::string& value);
  std::string* _internal_mutable_log();
  public:

  void clear_Message();
  MessageCase Message_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.StatusMessage)
 private:
  class _Internal;
  void set_has_error();
  void set_has_warning();
  void set_has_log();

  inline bool has_Message() const;
  inline void clear_has_Message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr warning_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_;
    } Message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PostDataCacheUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PostDataCacheUpdate) */ {
 public:
  inline PostDataCacheUpdate() : PostDataCacheUpdate(nullptr) {}
  ~PostDataCacheUpdate() override;
  explicit PROTOBUF_CONSTEXPR PostDataCacheUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostDataCacheUpdate(const PostDataCacheUpdate& from);
  PostDataCacheUpdate(PostDataCacheUpdate&& from) noexcept
    : PostDataCacheUpdate() {
    *this = ::std::move(from);
  }

  inline PostDataCacheUpdate& operator=(const PostDataCacheUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostDataCacheUpdate& operator=(PostDataCacheUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostDataCacheUpdate& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kStringVal = 10,
    VALUE_NOT_SET = 0,
  };

  static inline const PostDataCacheUpdate* internal_default_instance() {
    return reinterpret_cast<const PostDataCacheUpdate*>(
               &_PostDataCacheUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PostDataCacheUpdate& a, PostDataCacheUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(PostDataCacheUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostDataCacheUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostDataCacheUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostDataCacheUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostDataCacheUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostDataCacheUpdate& from) {
    PostDataCacheUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostDataCacheUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PostDataCacheUpdate";
  }
  protected:
  explicit PostDataCacheUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kStringValFieldNumber = 10,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string stringVal = 10;
  bool has_stringval() const;
  private:
  bool _internal_has_stringval() const;
  public:
  void clear_stringval();
  const std::string& stringval() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stringval(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stringval();
  PROTOBUF_NODISCARD std::string* release_stringval();
  void set_allocated_stringval(std::string* stringval);
  private:
  const std::string& _internal_stringval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stringval(const std::string& value);
  std::string* _internal_mutable_stringval();
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.PostDataCacheUpdate)
 private:
  class _Internal;
  void set_has_stringval();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stringval_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class CheckServerStatusReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CheckServerStatusReq) */ {
 public:
  inline CheckServerStatusReq() : CheckServerStatusReq(nullptr) {}
  ~CheckServerStatusReq() override;
  explicit PROTOBUF_CONSTEXPR CheckServerStatusReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckServerStatusReq(const CheckServerStatusReq& from);
  CheckServerStatusReq(CheckServerStatusReq&& from) noexcept
    : CheckServerStatusReq() {
    *this = ::std::move(from);
  }

  inline CheckServerStatusReq& operator=(const CheckServerStatusReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckServerStatusReq& operator=(CheckServerStatusReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckServerStatusReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckServerStatusReq* internal_default_instance() {
    return reinterpret_cast<const CheckServerStatusReq*>(
               &_CheckServerStatusReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CheckServerStatusReq& a, CheckServerStatusReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckServerStatusReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckServerStatusReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckServerStatusReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckServerStatusReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckServerStatusReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckServerStatusReq& from) {
    CheckServerStatusReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckServerStatusReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CheckServerStatusReq";
  }
  protected:
  explicit CheckServerStatusReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // string server = 10;
  void clear_server();
  const std::string& server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server();
  PROTOBUF_NODISCARD std::string* release_server();
  void set_allocated_server(std::string* server);
  private:
  const std::string& _internal_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server(const std::string& value);
  std::string* _internal_mutable_server();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CheckServerStatusReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class CheckServerStatusResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CheckServerStatusResp) */ {
 public:
  inline CheckServerStatusResp() : CheckServerStatusResp(nullptr) {}
  ~CheckServerStatusResp() override;
  explicit PROTOBUF_CONSTEXPR CheckServerStatusResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckServerStatusResp(const CheckServerStatusResp& from);
  CheckServerStatusResp(CheckServerStatusResp&& from) noexcept
    : CheckServerStatusResp() {
    *this = ::std::move(from);
  }

  inline CheckServerStatusResp& operator=(const CheckServerStatusResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckServerStatusResp& operator=(CheckServerStatusResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckServerStatusResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckServerStatusResp* internal_default_instance() {
    return reinterpret_cast<const CheckServerStatusResp*>(
               &_CheckServerStatusResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CheckServerStatusResp& a, CheckServerStatusResp& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckServerStatusResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckServerStatusResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckServerStatusResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckServerStatusResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckServerStatusResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckServerStatusResp& from) {
    CheckServerStatusResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckServerStatusResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CheckServerStatusResp";
  }
  protected:
  explicit CheckServerStatusResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFailReasonFieldNumber = 12,
    kInfoFieldNumber = 11,
    kReqIdFieldNumber = 1,
    kLiveFieldNumber = 10,
  };
  // optional string failReason = 12;
  bool has_failreason() const;
  private:
  bool _internal_has_failreason() const;
  public:
  void clear_failreason();
  const std::string& failreason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_failreason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_failreason();
  PROTOBUF_NODISCARD std::string* release_failreason();
  void set_allocated_failreason(std::string* failreason);
  private:
  const std::string& _internal_failreason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failreason(const std::string& value);
  std::string* _internal_mutable_failreason();
  public:

  // optional .ServerData.OrganizationInformation info = 11;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::ServerData::OrganizationInformation& info() const;
  PROTOBUF_NODISCARD ::ServerData::OrganizationInformation* release_info();
  ::ServerData::OrganizationInformation* mutable_info();
  void set_allocated_info(::ServerData::OrganizationInformation* info);
  private:
  const ::ServerData::OrganizationInformation& _internal_info() const;
  ::ServerData::OrganizationInformation* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::ServerData::OrganizationInformation* info);
  ::ServerData::OrganizationInformation* unsafe_arena_release_info();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // bool live = 10;
  void clear_live();
  bool live() const;
  void set_live(bool value);
  private:
  bool _internal_live() const;
  void _internal_set_live(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CheckServerStatusResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failreason_;
    ::ServerData::OrganizationInformation* info_;
    int32_t reqid_;
    bool live_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateReq) */ {
 public:
  inline AuthenticateReq() : AuthenticateReq(nullptr) {}
  ~AuthenticateReq() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateReq(const AuthenticateReq& from);
  AuthenticateReq(AuthenticateReq&& from) noexcept
    : AuthenticateReq() {
    *this = ::std::move(from);
  }

  inline AuthenticateReq& operator=(const AuthenticateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateReq& operator=(AuthenticateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateReq* internal_default_instance() {
    return reinterpret_cast<const AuthenticateReq*>(
               &_AuthenticateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AuthenticateReq& a, AuthenticateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateReq& from) {
    AuthenticateReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateReq";
  }
  protected:
  explicit AuthenticateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerFieldNumber = 10,
    kEmailFieldNumber = 11,
    kPasswordFieldNumber = 12,
    kReqIdFieldNumber = 1,
  };
  // string server = 10;
  void clear_server();
  const std::string& server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server();
  PROTOBUF_NODISCARD std::string* release_server();
  void set_allocated_server(std::string* server);
  private:
  const std::string& _internal_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server(const std::string& value);
  std::string* _internal_mutable_server();
  public:

  // string email = 11;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string password = 12;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateApiKeyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateApiKeyReq) */ {
 public:
  inline AuthenticateApiKeyReq() : AuthenticateApiKeyReq(nullptr) {}
  ~AuthenticateApiKeyReq() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateApiKeyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateApiKeyReq(const AuthenticateApiKeyReq& from);
  AuthenticateApiKeyReq(AuthenticateApiKeyReq&& from) noexcept
    : AuthenticateApiKeyReq() {
    *this = ::std::move(from);
  }

  inline AuthenticateApiKeyReq& operator=(const AuthenticateApiKeyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateApiKeyReq& operator=(AuthenticateApiKeyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateApiKeyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateApiKeyReq* internal_default_instance() {
    return reinterpret_cast<const AuthenticateApiKeyReq*>(
               &_AuthenticateApiKeyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AuthenticateApiKeyReq& a, AuthenticateApiKeyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateApiKeyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateApiKeyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateApiKeyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateApiKeyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateApiKeyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateApiKeyReq& from) {
    AuthenticateApiKeyReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateApiKeyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateApiKeyReq";
  }
  protected:
  explicit AuthenticateApiKeyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerFieldNumber = 10,
    kAccessKeyFieldNumber = 11,
    kAccessTokenFieldNumber = 12,
    kReqIdFieldNumber = 1,
  };
  // optional string server = 10;
  bool has_server() const;
  private:
  bool _internal_has_server() const;
  public:
  void clear_server();
  const std::string& server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server();
  PROTOBUF_NODISCARD std::string* release_server();
  void set_allocated_server(std::string* server);
  private:
  const std::string& _internal_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server(const std::string& value);
  std::string* _internal_mutable_server();
  public:

  // string accessKey = 11;
  void clear_accesskey();
  const std::string& accesskey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accesskey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accesskey();
  PROTOBUF_NODISCARD std::string* release_accesskey();
  void set_allocated_accesskey(std::string* accesskey);
  private:
  const std::string& _internal_accesskey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accesskey(const std::string& value);
  std::string* _internal_mutable_accesskey();
  public:

  // string accessToken = 12;
  void clear_accesstoken();
  const std::string& accesstoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accesstoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accesstoken();
  PROTOBUF_NODISCARD std::string* release_accesstoken();
  void set_allocated_accesstoken(std::string* accesstoken);
  private:
  const std::string& _internal_accesstoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accesstoken(const std::string& value);
  std::string* _internal_mutable_accesstoken();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateApiKeyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accesskey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accesstoken_;
    int32_t reqid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateGuestReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateGuestReq) */ {
 public:
  inline AuthenticateGuestReq() : AuthenticateGuestReq(nullptr) {}
  ~AuthenticateGuestReq() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateGuestReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateGuestReq(const AuthenticateGuestReq& from);
  AuthenticateGuestReq(AuthenticateGuestReq&& from) noexcept
    : AuthenticateGuestReq() {
    *this = ::std::move(from);
  }

  inline AuthenticateGuestReq& operator=(const AuthenticateGuestReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateGuestReq& operator=(AuthenticateGuestReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateGuestReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateGuestReq* internal_default_instance() {
    return reinterpret_cast<const AuthenticateGuestReq*>(
               &_AuthenticateGuestReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AuthenticateGuestReq& a, AuthenticateGuestReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateGuestReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateGuestReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateGuestReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateGuestReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateGuestReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateGuestReq& from) {
    AuthenticateGuestReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateGuestReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateGuestReq";
  }
  protected:
  explicit AuthenticateGuestReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerFieldNumber = 10,
    kScreenNameFieldNumber = 11,
    kReqIdFieldNumber = 1,
  };
  // string server = 10;
  void clear_server();
  const std::string& server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server();
  PROTOBUF_NODISCARD std::string* release_server();
  void set_allocated_server(std::string* server);
  private:
  const std::string& _internal_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server(const std::string& value);
  std::string* _internal_mutable_server();
  public:

  // string screenName = 11;
  void clear_screenname();
  const std::string& screenname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_screenname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_screenname();
  PROTOBUF_NODISCARD std::string* release_screenname();
  void set_allocated_screenname(std::string* screenname);
  private:
  const std::string& _internal_screenname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_screenname(const std::string& value);
  std::string* _internal_mutable_screenname();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateGuestReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr screenname_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateDeviceCodeBeginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateDeviceCodeBeginReq) */ {
 public:
  inline AuthenticateDeviceCodeBeginReq() : AuthenticateDeviceCodeBeginReq(nullptr) {}
  ~AuthenticateDeviceCodeBeginReq() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateDeviceCodeBeginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateDeviceCodeBeginReq(const AuthenticateDeviceCodeBeginReq& from);
  AuthenticateDeviceCodeBeginReq(AuthenticateDeviceCodeBeginReq&& from) noexcept
    : AuthenticateDeviceCodeBeginReq() {
    *this = ::std::move(from);
  }

  inline AuthenticateDeviceCodeBeginReq& operator=(const AuthenticateDeviceCodeBeginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateDeviceCodeBeginReq& operator=(AuthenticateDeviceCodeBeginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateDeviceCodeBeginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateDeviceCodeBeginReq* internal_default_instance() {
    return reinterpret_cast<const AuthenticateDeviceCodeBeginReq*>(
               &_AuthenticateDeviceCodeBeginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AuthenticateDeviceCodeBeginReq& a, AuthenticateDeviceCodeBeginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateDeviceCodeBeginReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateDeviceCodeBeginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateDeviceCodeBeginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateDeviceCodeBeginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateDeviceCodeBeginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateDeviceCodeBeginReq& from) {
    AuthenticateDeviceCodeBeginReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateDeviceCodeBeginReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateDeviceCodeBeginReq";
  }
  protected:
  explicit AuthenticateDeviceCodeBeginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerFieldNumber = 10,
    kSourceFieldNumber = 11,
    kCustomActivatedMessageFieldNumber = 12,
    kReqIdFieldNumber = 1,
    kTtlSecondsFieldNumber = 13,
    kAutoOpenUrlFieldNumber = 14,
  };
  // optional string server = 10;
  bool has_server() const;
  private:
  bool _internal_has_server() const;
  public:
  void clear_server();
  const std::string& server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server();
  PROTOBUF_NODISCARD std::string* release_server();
  void set_allocated_server(std::string* server);
  private:
  const std::string& _internal_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server(const std::string& value);
  std::string* _internal_mutable_server();
  public:

  // optional string source = 11;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // optional string customActivatedMessage = 12;
  bool has_customactivatedmessage() const;
  private:
  bool _internal_has_customactivatedmessage() const;
  public:
  void clear_customactivatedmessage();
  const std::string& customactivatedmessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customactivatedmessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customactivatedmessage();
  PROTOBUF_NODISCARD std::string* release_customactivatedmessage();
  void set_allocated_customactivatedmessage(std::string* customactivatedmessage);
  private:
  const std::string& _internal_customactivatedmessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customactivatedmessage(const std::string& value);
  std::string* _internal_mutable_customactivatedmessage();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // optional int32 ttlSeconds = 13;
  bool has_ttlseconds() const;
  private:
  bool _internal_has_ttlseconds() const;
  public:
  void clear_ttlseconds();
  int32_t ttlseconds() const;
  void set_ttlseconds(int32_t value);
  private:
  int32_t _internal_ttlseconds() const;
  void _internal_set_ttlseconds(int32_t value);
  public:

  // optional bool autoOpenUrl = 14;
  bool has_autoopenurl() const;
  private:
  bool _internal_has_autoopenurl() const;
  public:
  void clear_autoopenurl();
  bool autoopenurl() const;
  void set_autoopenurl(bool value);
  private:
  bool _internal_autoopenurl() const;
  void _internal_set_autoopenurl(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateDeviceCodeBeginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customactivatedmessage_;
    int32_t reqid_;
    int32_t ttlseconds_;
    bool autoopenurl_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateDeviceCodeBeginResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateDeviceCodeBeginResp) */ {
 public:
  inline AuthenticateDeviceCodeBeginResp() : AuthenticateDeviceCodeBeginResp(nullptr) {}
  ~AuthenticateDeviceCodeBeginResp() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateDeviceCodeBeginResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateDeviceCodeBeginResp(const AuthenticateDeviceCodeBeginResp& from);
  AuthenticateDeviceCodeBeginResp(AuthenticateDeviceCodeBeginResp&& from) noexcept
    : AuthenticateDeviceCodeBeginResp() {
    *this = ::std::move(from);
  }

  inline AuthenticateDeviceCodeBeginResp& operator=(const AuthenticateDeviceCodeBeginResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateDeviceCodeBeginResp& operator=(AuthenticateDeviceCodeBeginResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateDeviceCodeBeginResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateDeviceCodeBeginResp* internal_default_instance() {
    return reinterpret_cast<const AuthenticateDeviceCodeBeginResp*>(
               &_AuthenticateDeviceCodeBeginResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AuthenticateDeviceCodeBeginResp& a, AuthenticateDeviceCodeBeginResp& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateDeviceCodeBeginResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateDeviceCodeBeginResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateDeviceCodeBeginResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateDeviceCodeBeginResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateDeviceCodeBeginResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateDeviceCodeBeginResp& from) {
    AuthenticateDeviceCodeBeginResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateDeviceCodeBeginResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateDeviceCodeBeginResp";
  }
  protected:
  explicit AuthenticateDeviceCodeBeginResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceCodeFieldNumber = 10,
    kUserCodeFieldNumber = 11,
    kVerificationUrlFieldNumber = 12,
    kReqIdFieldNumber = 1,
  };
  // string deviceCode = 10;
  void clear_devicecode();
  const std::string& devicecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicecode();
  PROTOBUF_NODISCARD std::string* release_devicecode();
  void set_allocated_devicecode(std::string* devicecode);
  private:
  const std::string& _internal_devicecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicecode(const std::string& value);
  std::string* _internal_mutable_devicecode();
  public:

  // string userCode = 11;
  void clear_usercode();
  const std::string& usercode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_usercode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_usercode();
  PROTOBUF_NODISCARD std::string* release_usercode();
  void set_allocated_usercode(std::string* usercode);
  private:
  const std::string& _internal_usercode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_usercode(const std::string& value);
  std::string* _internal_mutable_usercode();
  public:

  // string verificationUrl = 12;
  void clear_verificationurl();
  const std::string& verificationurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verificationurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verificationurl();
  PROTOBUF_NODISCARD std::string* release_verificationurl();
  void set_allocated_verificationurl(std::string* verificationurl);
  private:
  const std::string& _internal_verificationurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verificationurl(const std::string& value);
  std::string* _internal_mutable_verificationurl();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateDeviceCodeBeginResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicecode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr usercode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verificationurl_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateDeviceCodeConcludeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateDeviceCodeConcludeReq) */ {
 public:
  inline AuthenticateDeviceCodeConcludeReq() : AuthenticateDeviceCodeConcludeReq(nullptr) {}
  ~AuthenticateDeviceCodeConcludeReq() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateDeviceCodeConcludeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateDeviceCodeConcludeReq(const AuthenticateDeviceCodeConcludeReq& from);
  AuthenticateDeviceCodeConcludeReq(AuthenticateDeviceCodeConcludeReq&& from) noexcept
    : AuthenticateDeviceCodeConcludeReq() {
    *this = ::std::move(from);
  }

  inline AuthenticateDeviceCodeConcludeReq& operator=(const AuthenticateDeviceCodeConcludeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateDeviceCodeConcludeReq& operator=(AuthenticateDeviceCodeConcludeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateDeviceCodeConcludeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateDeviceCodeConcludeReq* internal_default_instance() {
    return reinterpret_cast<const AuthenticateDeviceCodeConcludeReq*>(
               &_AuthenticateDeviceCodeConcludeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AuthenticateDeviceCodeConcludeReq& a, AuthenticateDeviceCodeConcludeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateDeviceCodeConcludeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateDeviceCodeConcludeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateDeviceCodeConcludeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateDeviceCodeConcludeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateDeviceCodeConcludeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateDeviceCodeConcludeReq& from) {
    AuthenticateDeviceCodeConcludeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateDeviceCodeConcludeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateDeviceCodeConcludeReq";
  }
  protected:
  explicit AuthenticateDeviceCodeConcludeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerFieldNumber = 10,
    kDeviceCodeFieldNumber = 11,
    kUserCodeFieldNumber = 12,
    kReqIdFieldNumber = 1,
    kPollForSecondsFieldNumber = 13,
  };
  // optional string server = 10;
  bool has_server() const;
  private:
  bool _internal_has_server() const;
  public:
  void clear_server();
  const std::string& server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server();
  PROTOBUF_NODISCARD std::string* release_server();
  void set_allocated_server(std::string* server);
  private:
  const std::string& _internal_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server(const std::string& value);
  std::string* _internal_mutable_server();
  public:

  // string deviceCode = 11;
  void clear_devicecode();
  const std::string& devicecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicecode();
  PROTOBUF_NODISCARD std::string* release_devicecode();
  void set_allocated_devicecode(std::string* devicecode);
  private:
  const std::string& _internal_devicecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicecode(const std::string& value);
  std::string* _internal_mutable_devicecode();
  public:

  // string userCode = 12;
  void clear_usercode();
  const std::string& usercode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_usercode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_usercode();
  PROTOBUF_NODISCARD std::string* release_usercode();
  void set_allocated_usercode(std::string* usercode);
  private:
  const std::string& _internal_usercode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_usercode(const std::string& value);
  std::string* _internal_mutable_usercode();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // int32 pollForSeconds = 13;
  void clear_pollforseconds();
  int32_t pollforseconds() const;
  void set_pollforseconds(int32_t value);
  private:
  int32_t _internal_pollforseconds() const;
  void _internal_set_pollforseconds(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateDeviceCodeConcludeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicecode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr usercode_;
    int32_t reqid_;
    int32_t pollforseconds_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateResp) */ {
 public:
  inline AuthenticateResp() : AuthenticateResp(nullptr) {}
  ~AuthenticateResp() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateResp(const AuthenticateResp& from);
  AuthenticateResp(AuthenticateResp&& from) noexcept
    : AuthenticateResp() {
    *this = ::std::move(from);
  }

  inline AuthenticateResp& operator=(const AuthenticateResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateResp& operator=(AuthenticateResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateResp* internal_default_instance() {
    return reinterpret_cast<const AuthenticateResp*>(
               &_AuthenticateResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AuthenticateResp& a, AuthenticateResp& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateResp& from) {
    AuthenticateResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateResp";
  }
  protected:
  explicit AuthenticateResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.CavrnusAuth auth = 10;
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::ServerData::CavrnusAuth& auth() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusAuth* release_auth();
  ::ServerData::CavrnusAuth* mutable_auth();
  void set_allocated_auth(::ServerData::CavrnusAuth* auth);
  private:
  const ::ServerData::CavrnusAuth& _internal_auth() const;
  ::ServerData::CavrnusAuth* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::ServerData::CavrnusAuth* auth);
  ::ServerData::CavrnusAuth* unsafe_arena_release_auth();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusAuth* auth_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateTokenReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateTokenReq) */ {
 public:
  inline AuthenticateTokenReq() : AuthenticateTokenReq(nullptr) {}
  ~AuthenticateTokenReq() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateTokenReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateTokenReq(const AuthenticateTokenReq& from);
  AuthenticateTokenReq(AuthenticateTokenReq&& from) noexcept
    : AuthenticateTokenReq() {
    *this = ::std::move(from);
  }

  inline AuthenticateTokenReq& operator=(const AuthenticateTokenReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateTokenReq& operator=(AuthenticateTokenReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateTokenReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateTokenReq* internal_default_instance() {
    return reinterpret_cast<const AuthenticateTokenReq*>(
               &_AuthenticateTokenReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AuthenticateTokenReq& a, AuthenticateTokenReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateTokenReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateTokenReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateTokenReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateTokenReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateTokenReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateTokenReq& from) {
    AuthenticateTokenReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateTokenReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateTokenReq";
  }
  protected:
  explicit AuthenticateTokenReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerFieldNumber = 10,
    kTokenFieldNumber = 11,
    kReqIdFieldNumber = 1,
  };
  // optional string server = 10;
  bool has_server() const;
  private:
  bool _internal_has_server() const;
  public:
  void clear_server();
  const std::string& server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server();
  PROTOBUF_NODISCARD std::string* release_server();
  void set_allocated_server(std::string* server);
  private:
  const std::string& _internal_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server(const std::string& value);
  std::string* _internal_mutable_server();
  public:

  // string token = 11;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateTokenReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    int32_t reqid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateWithLinkReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateWithLinkReq) */ {
 public:
  inline AuthenticateWithLinkReq() : AuthenticateWithLinkReq(nullptr) {}
  ~AuthenticateWithLinkReq() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateWithLinkReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateWithLinkReq(const AuthenticateWithLinkReq& from);
  AuthenticateWithLinkReq(AuthenticateWithLinkReq&& from) noexcept
    : AuthenticateWithLinkReq() {
    *this = ::std::move(from);
  }

  inline AuthenticateWithLinkReq& operator=(const AuthenticateWithLinkReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateWithLinkReq& operator=(AuthenticateWithLinkReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateWithLinkReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateWithLinkReq* internal_default_instance() {
    return reinterpret_cast<const AuthenticateWithLinkReq*>(
               &_AuthenticateWithLinkReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AuthenticateWithLinkReq& a, AuthenticateWithLinkReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateWithLinkReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateWithLinkReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateWithLinkReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateWithLinkReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateWithLinkReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateWithLinkReq& from) {
    AuthenticateWithLinkReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateWithLinkReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateWithLinkReq";
  }
  protected:
  explicit AuthenticateWithLinkReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // string link = 10;
  void clear_link();
  const std::string& link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_link();
  PROTOBUF_NODISCARD std::string* release_link();
  void set_allocated_link(std::string* link);
  private:
  const std::string& _internal_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link(const std::string& value);
  std::string* _internal_mutable_link();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateWithLinkReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateWithLinkResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AuthenticateWithLinkResp) */ {
 public:
  inline AuthenticateWithLinkResp() : AuthenticateWithLinkResp(nullptr) {}
  ~AuthenticateWithLinkResp() override;
  explicit PROTOBUF_CONSTEXPR AuthenticateWithLinkResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateWithLinkResp(const AuthenticateWithLinkResp& from);
  AuthenticateWithLinkResp(AuthenticateWithLinkResp&& from) noexcept
    : AuthenticateWithLinkResp() {
    *this = ::std::move(from);
  }

  inline AuthenticateWithLinkResp& operator=(const AuthenticateWithLinkResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateWithLinkResp& operator=(AuthenticateWithLinkResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateWithLinkResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateWithLinkResp* internal_default_instance() {
    return reinterpret_cast<const AuthenticateWithLinkResp*>(
               &_AuthenticateWithLinkResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AuthenticateWithLinkResp& a, AuthenticateWithLinkResp& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateWithLinkResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateWithLinkResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateWithLinkResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateWithLinkResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateWithLinkResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateWithLinkResp& from) {
    AuthenticateWithLinkResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateWithLinkResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AuthenticateWithLinkResp";
  }
  protected:
  explicit AuthenticateWithLinkResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkAuthFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.CavrnusAuthLinkResponse linkAuth = 10;
  bool has_linkauth() const;
  private:
  bool _internal_has_linkauth() const;
  public:
  void clear_linkauth();
  const ::ServerData::CavrnusAuthLinkResponse& linkauth() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusAuthLinkResponse* release_linkauth();
  ::ServerData::CavrnusAuthLinkResponse* mutable_linkauth();
  void set_allocated_linkauth(::ServerData::CavrnusAuthLinkResponse* linkauth);
  private:
  const ::ServerData::CavrnusAuthLinkResponse& _internal_linkauth() const;
  ::ServerData::CavrnusAuthLinkResponse* _internal_mutable_linkauth();
  public:
  void unsafe_arena_set_allocated_linkauth(
      ::ServerData::CavrnusAuthLinkResponse* linkauth);
  ::ServerData::CavrnusAuthLinkResponse* unsafe_arena_release_linkauth();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AuthenticateWithLinkResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusAuthLinkResponse* linkauth_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ConstructApiKeyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ConstructApiKeyReq) */ {
 public:
  inline ConstructApiKeyReq() : ConstructApiKeyReq(nullptr) {}
  ~ConstructApiKeyReq() override;
  explicit PROTOBUF_CONSTEXPR ConstructApiKeyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConstructApiKeyReq(const ConstructApiKeyReq& from);
  ConstructApiKeyReq(ConstructApiKeyReq&& from) noexcept
    : ConstructApiKeyReq() {
    *this = ::std::move(from);
  }

  inline ConstructApiKeyReq& operator=(const ConstructApiKeyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstructApiKeyReq& operator=(ConstructApiKeyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstructApiKeyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConstructApiKeyReq* internal_default_instance() {
    return reinterpret_cast<const ConstructApiKeyReq*>(
               &_ConstructApiKeyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ConstructApiKeyReq& a, ConstructApiKeyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ConstructApiKeyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstructApiKeyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstructApiKeyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConstructApiKeyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConstructApiKeyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConstructApiKeyReq& from) {
    ConstructApiKeyReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConstructApiKeyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ConstructApiKeyReq";
  }
  protected:
  explicit ConstructApiKeyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyNameFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // optional string keyName = 10;
  bool has_keyname() const;
  private:
  bool _internal_has_keyname() const;
  public:
  void clear_keyname();
  const std::string& keyname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keyname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keyname();
  PROTOBUF_NODISCARD std::string* release_keyname();
  void set_allocated_keyname(std::string* keyname);
  private:
  const std::string& _internal_keyname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyname(const std::string& value);
  std::string* _internal_mutable_keyname();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.ConstructApiKeyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyname_;
    int32_t reqid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ConstructApiKeyResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ConstructApiKeyResp) */ {
 public:
  inline ConstructApiKeyResp() : ConstructApiKeyResp(nullptr) {}
  ~ConstructApiKeyResp() override;
  explicit PROTOBUF_CONSTEXPR ConstructApiKeyResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConstructApiKeyResp(const ConstructApiKeyResp& from);
  ConstructApiKeyResp(ConstructApiKeyResp&& from) noexcept
    : ConstructApiKeyResp() {
    *this = ::std::move(from);
  }

  inline ConstructApiKeyResp& operator=(const ConstructApiKeyResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstructApiKeyResp& operator=(ConstructApiKeyResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstructApiKeyResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConstructApiKeyResp* internal_default_instance() {
    return reinterpret_cast<const ConstructApiKeyResp*>(
               &_ConstructApiKeyResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ConstructApiKeyResp& a, ConstructApiKeyResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ConstructApiKeyResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstructApiKeyResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstructApiKeyResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConstructApiKeyResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConstructApiKeyResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConstructApiKeyResp& from) {
    ConstructApiKeyResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConstructApiKeyResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ConstructApiKeyResp";
  }
  protected:
  explicit ConstructApiKeyResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessKeyFieldNumber = 10,
    kAccessTokenFieldNumber = 11,
    kReqIdFieldNumber = 1,
  };
  // string accessKey = 10;
  void clear_accesskey();
  const std::string& accesskey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accesskey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accesskey();
  PROTOBUF_NODISCARD std::string* release_accesskey();
  void set_allocated_accesskey(std::string* accesskey);
  private:
  const std::string& _internal_accesskey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accesskey(const std::string& value);
  std::string* _internal_mutable_accesskey();
  public:

  // string accessToken = 11;
  void clear_accesstoken();
  const std::string& accesstoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accesstoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accesstoken();
  PROTOBUF_NODISCARD std::string* release_accesstoken();
  void set_allocated_accesstoken(std::string* accesstoken);
  private:
  const std::string& _internal_accesstoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accesstoken(const std::string& value);
  std::string* _internal_mutable_accesstoken();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.ConstructApiKeyResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accesskey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accesstoken_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ExitAllSpacesAndLogoutReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ExitAllSpacesAndLogoutReq) */ {
 public:
  inline ExitAllSpacesAndLogoutReq() : ExitAllSpacesAndLogoutReq(nullptr) {}
  ~ExitAllSpacesAndLogoutReq() override;
  explicit PROTOBUF_CONSTEXPR ExitAllSpacesAndLogoutReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExitAllSpacesAndLogoutReq(const ExitAllSpacesAndLogoutReq& from);
  ExitAllSpacesAndLogoutReq(ExitAllSpacesAndLogoutReq&& from) noexcept
    : ExitAllSpacesAndLogoutReq() {
    *this = ::std::move(from);
  }

  inline ExitAllSpacesAndLogoutReq& operator=(const ExitAllSpacesAndLogoutReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExitAllSpacesAndLogoutReq& operator=(ExitAllSpacesAndLogoutReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExitAllSpacesAndLogoutReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExitAllSpacesAndLogoutReq* internal_default_instance() {
    return reinterpret_cast<const ExitAllSpacesAndLogoutReq*>(
               &_ExitAllSpacesAndLogoutReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ExitAllSpacesAndLogoutReq& a, ExitAllSpacesAndLogoutReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ExitAllSpacesAndLogoutReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExitAllSpacesAndLogoutReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExitAllSpacesAndLogoutReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExitAllSpacesAndLogoutReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExitAllSpacesAndLogoutReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExitAllSpacesAndLogoutReq& from) {
    ExitAllSpacesAndLogoutReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExitAllSpacesAndLogoutReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ExitAllSpacesAndLogoutReq";
  }
  protected:
  explicit ExitAllSpacesAndLogoutReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.ExitAllSpacesAndLogoutReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ExitAllSpacesAndLogoutResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ExitAllSpacesAndLogoutResp) */ {
 public:
  inline ExitAllSpacesAndLogoutResp() : ExitAllSpacesAndLogoutResp(nullptr) {}
  ~ExitAllSpacesAndLogoutResp() override;
  explicit PROTOBUF_CONSTEXPR ExitAllSpacesAndLogoutResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExitAllSpacesAndLogoutResp(const ExitAllSpacesAndLogoutResp& from);
  ExitAllSpacesAndLogoutResp(ExitAllSpacesAndLogoutResp&& from) noexcept
    : ExitAllSpacesAndLogoutResp() {
    *this = ::std::move(from);
  }

  inline ExitAllSpacesAndLogoutResp& operator=(const ExitAllSpacesAndLogoutResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExitAllSpacesAndLogoutResp& operator=(ExitAllSpacesAndLogoutResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExitAllSpacesAndLogoutResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExitAllSpacesAndLogoutResp* internal_default_instance() {
    return reinterpret_cast<const ExitAllSpacesAndLogoutResp*>(
               &_ExitAllSpacesAndLogoutResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ExitAllSpacesAndLogoutResp& a, ExitAllSpacesAndLogoutResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ExitAllSpacesAndLogoutResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExitAllSpacesAndLogoutResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExitAllSpacesAndLogoutResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExitAllSpacesAndLogoutResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExitAllSpacesAndLogoutResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExitAllSpacesAndLogoutResp& from) {
    ExitAllSpacesAndLogoutResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExitAllSpacesAndLogoutResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ExitAllSpacesAndLogoutResp";
  }
  protected:
  explicit ExitAllSpacesAndLogoutResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpacesExitedFieldNumber = 20,
    kReqIdFieldNumber = 1,
  };
  // repeated int32 spacesExited = 20;
  int spacesexited_size() const;
  private:
  int _internal_spacesexited_size() const;
  public:
  void clear_spacesexited();
  private:
  int32_t _internal_spacesexited(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_spacesexited() const;
  void _internal_add_spacesexited(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_spacesexited();
  public:
  int32_t spacesexited(int index) const;
  void set_spacesexited(int index, int32_t value);
  void add_spacesexited(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      spacesexited() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_spacesexited();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.ExitAllSpacesAndLogoutResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > spacesexited_;
    mutable std::atomic<int> _spacesexited_cached_byte_size_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class JoinSpaceFromIdReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.JoinSpaceFromIdReq) */ {
 public:
  inline JoinSpaceFromIdReq() : JoinSpaceFromIdReq(nullptr) {}
  ~JoinSpaceFromIdReq() override;
  explicit PROTOBUF_CONSTEXPR JoinSpaceFromIdReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinSpaceFromIdReq(const JoinSpaceFromIdReq& from);
  JoinSpaceFromIdReq(JoinSpaceFromIdReq&& from) noexcept
    : JoinSpaceFromIdReq() {
    *this = ::std::move(from);
  }

  inline JoinSpaceFromIdReq& operator=(const JoinSpaceFromIdReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinSpaceFromIdReq& operator=(JoinSpaceFromIdReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinSpaceFromIdReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinSpaceFromIdReq* internal_default_instance() {
    return reinterpret_cast<const JoinSpaceFromIdReq*>(
               &_JoinSpaceFromIdReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(JoinSpaceFromIdReq& a, JoinSpaceFromIdReq& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinSpaceFromIdReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinSpaceFromIdReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinSpaceFromIdReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinSpaceFromIdReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinSpaceFromIdReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinSpaceFromIdReq& from) {
    JoinSpaceFromIdReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinSpaceFromIdReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.JoinSpaceFromIdReq";
  }
  protected:
  explicit JoinSpaceFromIdReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceIdFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // string spaceId = 10;
  void clear_spaceid();
  const std::string& spaceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spaceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spaceid();
  PROTOBUF_NODISCARD std::string* release_spaceid();
  void set_allocated_spaceid(std::string* spaceid);
  private:
  const std::string& _internal_spaceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spaceid(const std::string& value);
  std::string* _internal_mutable_spaceid();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.JoinSpaceFromIdReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spaceid_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class JoinSpaceFromIdResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.JoinSpaceFromIdResp) */ {
 public:
  inline JoinSpaceFromIdResp() : JoinSpaceFromIdResp(nullptr) {}
  ~JoinSpaceFromIdResp() override;
  explicit PROTOBUF_CONSTEXPR JoinSpaceFromIdResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinSpaceFromIdResp(const JoinSpaceFromIdResp& from);
  JoinSpaceFromIdResp(JoinSpaceFromIdResp&& from) noexcept
    : JoinSpaceFromIdResp() {
    *this = ::std::move(from);
  }

  inline JoinSpaceFromIdResp& operator=(const JoinSpaceFromIdResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinSpaceFromIdResp& operator=(JoinSpaceFromIdResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinSpaceFromIdResp& default_instance() {
    return *internal_default_instance();
  }
  enum RespCase {
    kSpaceConn = 10,
    kError = 11,
    RESP_NOT_SET = 0,
  };

  static inline const JoinSpaceFromIdResp* internal_default_instance() {
    return reinterpret_cast<const JoinSpaceFromIdResp*>(
               &_JoinSpaceFromIdResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(JoinSpaceFromIdResp& a, JoinSpaceFromIdResp& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinSpaceFromIdResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinSpaceFromIdResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinSpaceFromIdResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinSpaceFromIdResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinSpaceFromIdResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinSpaceFromIdResp& from) {
    JoinSpaceFromIdResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinSpaceFromIdResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.JoinSpaceFromIdResp";
  }
  protected:
  explicit JoinSpaceFromIdResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
    kSpaceConnFieldNumber = 10,
    kErrorFieldNumber = 11,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // .ServerData.CavrnusSpaceConnectionInfo spaceConn = 10;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnectionInfo& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnectionInfo* release_spaceconn();
  ::ServerData::CavrnusSpaceConnectionInfo* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnectionInfo* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnectionInfo& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnectionInfo* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnectionInfo* spaceconn);
  ::ServerData::CavrnusSpaceConnectionInfo* unsafe_arena_release_spaceconn();

  // string error = 11;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  void clear_Resp();
  RespCase Resp_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.JoinSpaceFromIdResp)
 private:
  class _Internal;
  void set_has_spaceconn();
  void set_has_error();

  inline bool has_Resp() const;
  inline void clear_has_Resp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    union RespUnion {
      constexpr RespUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ServerData::CavrnusSpaceConnectionInfo* spaceconn_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    } Resp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ServerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ServerMessage) */ {
 public:
  inline ServerMessage() : ServerMessage(nullptr) {}
  ~ServerMessage() override;
  explicit PROTOBUF_CONSTEXPR ServerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerMessage(const ServerMessage& from);
  ServerMessage(ServerMessage&& from) noexcept
    : ServerMessage() {
    *this = ::std::move(from);
  }

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerMessage* internal_default_instance() {
    return reinterpret_cast<const ServerMessage*>(
               &_ServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ServerMessage& a, ServerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerMessage& from) {
    ServerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ServerMessage";
  }
  protected:
  explicit ServerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ServerMessage_Category Category;
  static constexpr Category Log =
    ServerMessage_Category_Log;
  static constexpr Category UserMessage =
    ServerMessage_Category_UserMessage;
  static constexpr Category CriticalServerMessage =
    ServerMessage_Category_CriticalServerMessage;
  static constexpr Category ProgramError =
    ServerMessage_Category_ProgramError;
  static inline bool Category_IsValid(int value) {
    return ServerMessage_Category_IsValid(value);
  }
  static constexpr Category Category_MIN =
    ServerMessage_Category_Category_MIN;
  static constexpr Category Category_MAX =
    ServerMessage_Category_Category_MAX;
  static constexpr int Category_ARRAYSIZE =
    ServerMessage_Category_Category_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Category_descriptor() {
    return ServerMessage_Category_descriptor();
  }
  template<typename T>
  static inline const std::string& Category_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Category>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Category_Name.");
    return ServerMessage_Category_Name(enum_t_value);
  }
  static inline bool Category_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Category* value) {
    return ServerMessage_Category_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kMessageForConnectionFieldNumber = 1,
    kCategoryFieldNumber = 2,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .ServerData.CavrnusSpaceConnection messageForConnection = 1;
  bool has_messageforconnection() const;
  private:
  bool _internal_has_messageforconnection() const;
  public:
  void clear_messageforconnection();
  const ::ServerData::CavrnusSpaceConnection& messageforconnection() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_messageforconnection();
  ::ServerData::CavrnusSpaceConnection* mutable_messageforconnection();
  void set_allocated_messageforconnection(::ServerData::CavrnusSpaceConnection* messageforconnection);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_messageforconnection() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_messageforconnection();
  public:
  void unsafe_arena_set_allocated_messageforconnection(
      ::ServerData::CavrnusSpaceConnection* messageforconnection);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_messageforconnection();

  // .ServerData.ServerMessage.Category category = 2;
  void clear_category();
  ::ServerData::ServerMessage_Category category() const;
  void set_category(::ServerData::ServerMessage_Category value);
  private:
  ::ServerData::ServerMessage_Category _internal_category() const;
  void _internal_set_category(::ServerData::ServerMessage_Category value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.ServerMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::ServerData::CavrnusSpaceConnection* messageforconnection_;
    int category_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class SpaceConnectionStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.SpaceConnectionStatus) */ {
 public:
  inline SpaceConnectionStatus() : SpaceConnectionStatus(nullptr) {}
  ~SpaceConnectionStatus() override;
  explicit PROTOBUF_CONSTEXPR SpaceConnectionStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpaceConnectionStatus(const SpaceConnectionStatus& from);
  SpaceConnectionStatus(SpaceConnectionStatus&& from) noexcept
    : SpaceConnectionStatus() {
    *this = ::std::move(from);
  }

  inline SpaceConnectionStatus& operator=(const SpaceConnectionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpaceConnectionStatus& operator=(SpaceConnectionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpaceConnectionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpaceConnectionStatus* internal_default_instance() {
    return reinterpret_cast<const SpaceConnectionStatus*>(
               &_SpaceConnectionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SpaceConnectionStatus& a, SpaceConnectionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SpaceConnectionStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpaceConnectionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpaceConnectionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpaceConnectionStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpaceConnectionStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpaceConnectionStatus& from) {
    SpaceConnectionStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpaceConnectionStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.SpaceConnectionStatus";
  }
  protected:
  explicit SpaceConnectionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SpaceConnectionStatus_Status Status;
  static constexpr Status ReadyToConnect =
    SpaceConnectionStatus_Status_ReadyToConnect;
  static constexpr Status Connecting =
    SpaceConnectionStatus_Status_Connecting;
  static constexpr Status ProcessingInitialState =
    SpaceConnectionStatus_Status_ProcessingInitialState;
  static constexpr Status Live =
    SpaceConnectionStatus_Status_Live;
  static constexpr Status Reconnecting =
    SpaceConnectionStatus_Status_Reconnecting;
  static constexpr Status Closed =
    SpaceConnectionStatus_Status_Closed;
  static constexpr Status Error =
    SpaceConnectionStatus_Status_Error;
  static inline bool Status_IsValid(int value) {
    return SpaceConnectionStatus_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    SpaceConnectionStatus_Status_Status_MIN;
  static constexpr Status Status_MAX =
    SpaceConnectionStatus_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    SpaceConnectionStatus_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return SpaceConnectionStatus_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return SpaceConnectionStatus_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return SpaceConnectionStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLasterrorFieldNumber = 6,
    kStatusForConnectionFieldNumber = 1,
    kStatusFieldNumber = 5,
  };
  // string lasterror = 6;
  void clear_lasterror();
  const std::string& lasterror() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lasterror(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lasterror();
  PROTOBUF_NODISCARD std::string* release_lasterror();
  void set_allocated_lasterror(std::string* lasterror);
  private:
  const std::string& _internal_lasterror() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lasterror(const std::string& value);
  std::string* _internal_mutable_lasterror();
  public:

  // .ServerData.CavrnusSpaceConnection statusForConnection = 1;
  bool has_statusforconnection() const;
  private:
  bool _internal_has_statusforconnection() const;
  public:
  void clear_statusforconnection();
  const ::ServerData::CavrnusSpaceConnection& statusforconnection() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_statusforconnection();
  ::ServerData::CavrnusSpaceConnection* mutable_statusforconnection();
  void set_allocated_statusforconnection(::ServerData::CavrnusSpaceConnection* statusforconnection);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_statusforconnection() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_statusforconnection();
  public:
  void unsafe_arena_set_allocated_statusforconnection(
      ::ServerData::CavrnusSpaceConnection* statusforconnection);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_statusforconnection();

  // .ServerData.SpaceConnectionStatus.Status status = 5;
  void clear_status();
  ::ServerData::SpaceConnectionStatus_Status status() const;
  void set_status(::ServerData::SpaceConnectionStatus_Status value);
  private:
  ::ServerData::SpaceConnectionStatus_Status _internal_status() const;
  void _internal_set_status(::ServerData::SpaceConnectionStatus_Status value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.SpaceConnectionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lasterror_;
    ::ServerData::CavrnusSpaceConnection* statusforconnection_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ShutdownSpaceConnectionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ShutdownSpaceConnectionReq) */ {
 public:
  inline ShutdownSpaceConnectionReq() : ShutdownSpaceConnectionReq(nullptr) {}
  ~ShutdownSpaceConnectionReq() override;
  explicit PROTOBUF_CONSTEXPR ShutdownSpaceConnectionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShutdownSpaceConnectionReq(const ShutdownSpaceConnectionReq& from);
  ShutdownSpaceConnectionReq(ShutdownSpaceConnectionReq&& from) noexcept
    : ShutdownSpaceConnectionReq() {
    *this = ::std::move(from);
  }

  inline ShutdownSpaceConnectionReq& operator=(const ShutdownSpaceConnectionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownSpaceConnectionReq& operator=(ShutdownSpaceConnectionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShutdownSpaceConnectionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShutdownSpaceConnectionReq* internal_default_instance() {
    return reinterpret_cast<const ShutdownSpaceConnectionReq*>(
               &_ShutdownSpaceConnectionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ShutdownSpaceConnectionReq& a, ShutdownSpaceConnectionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownSpaceConnectionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownSpaceConnectionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShutdownSpaceConnectionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShutdownSpaceConnectionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShutdownSpaceConnectionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShutdownSpaceConnectionReq& from) {
    ShutdownSpaceConnectionReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShutdownSpaceConnectionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ShutdownSpaceConnectionReq";
  }
  protected:
  explicit ShutdownSpaceConnectionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnectionFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.CavrnusSpaceConnection SpaceConnection = 10;
  bool has_spaceconnection() const;
  private:
  bool _internal_has_spaceconnection() const;
  public:
  void clear_spaceconnection();
  const ::ServerData::CavrnusSpaceConnection& spaceconnection() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconnection();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconnection();
  void set_allocated_spaceconnection(::ServerData::CavrnusSpaceConnection* spaceconnection);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconnection() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconnection();
  public:
  void unsafe_arena_set_allocated_spaceconnection(
      ::ServerData::CavrnusSpaceConnection* spaceconnection);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconnection();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.ShutdownSpaceConnectionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconnection_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ShutdownSpaceConnectionResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ShutdownSpaceConnectionResp) */ {
 public:
  inline ShutdownSpaceConnectionResp() : ShutdownSpaceConnectionResp(nullptr) {}
  ~ShutdownSpaceConnectionResp() override;
  explicit PROTOBUF_CONSTEXPR ShutdownSpaceConnectionResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShutdownSpaceConnectionResp(const ShutdownSpaceConnectionResp& from);
  ShutdownSpaceConnectionResp(ShutdownSpaceConnectionResp&& from) noexcept
    : ShutdownSpaceConnectionResp() {
    *this = ::std::move(from);
  }

  inline ShutdownSpaceConnectionResp& operator=(const ShutdownSpaceConnectionResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownSpaceConnectionResp& operator=(ShutdownSpaceConnectionResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShutdownSpaceConnectionResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShutdownSpaceConnectionResp* internal_default_instance() {
    return reinterpret_cast<const ShutdownSpaceConnectionResp*>(
               &_ShutdownSpaceConnectionResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ShutdownSpaceConnectionResp& a, ShutdownSpaceConnectionResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownSpaceConnectionResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownSpaceConnectionResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShutdownSpaceConnectionResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShutdownSpaceConnectionResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShutdownSpaceConnectionResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShutdownSpaceConnectionResp& from) {
    ShutdownSpaceConnectionResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShutdownSpaceConnectionResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ShutdownSpaceConnectionResp";
  }
  protected:
  explicit ShutdownSpaceConnectionResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.CavrnusSpaceConnection spaceConn = 10;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.ShutdownSpaceConnectionResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class CreateSpaceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CreateSpaceReq) */ {
 public:
  inline CreateSpaceReq() : CreateSpaceReq(nullptr) {}
  ~CreateSpaceReq() override;
  explicit PROTOBUF_CONSTEXPR CreateSpaceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSpaceReq(const CreateSpaceReq& from);
  CreateSpaceReq(CreateSpaceReq&& from) noexcept
    : CreateSpaceReq() {
    *this = ::std::move(from);
  }

  inline CreateSpaceReq& operator=(const CreateSpaceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSpaceReq& operator=(CreateSpaceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSpaceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSpaceReq* internal_default_instance() {
    return reinterpret_cast<const CreateSpaceReq*>(
               &_CreateSpaceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CreateSpaceReq& a, CreateSpaceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSpaceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSpaceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSpaceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSpaceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSpaceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateSpaceReq& from) {
    CreateSpaceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSpaceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CreateSpaceReq";
  }
  protected:
  explicit CreateSpaceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeywordsFieldNumber = 11,
    kNewSpaceNameFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // repeated string keywords = 11;
  int keywords_size() const;
  private:
  int _internal_keywords_size() const;
  public:
  void clear_keywords();
  const std::string& keywords(int index) const;
  std::string* mutable_keywords(int index);
  void set_keywords(int index, const std::string& value);
  void set_keywords(int index, std::string&& value);
  void set_keywords(int index, const char* value);
  void set_keywords(int index, const char* value, size_t size);
  std::string* add_keywords();
  void add_keywords(const std::string& value);
  void add_keywords(std::string&& value);
  void add_keywords(const char* value);
  void add_keywords(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keywords() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keywords();
  private:
  const std::string& _internal_keywords(int index) const;
  std::string* _internal_add_keywords();
  public:

  // string newSpaceName = 10;
  void clear_newspacename();
  const std::string& newspacename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newspacename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newspacename();
  PROTOBUF_NODISCARD std::string* release_newspacename();
  void set_allocated_newspacename(std::string* newspacename);
  private:
  const std::string& _internal_newspacename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newspacename(const std::string& value);
  std::string* _internal_mutable_newspacename();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CreateSpaceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keywords_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newspacename_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class CreateSpaceResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CreateSpaceResp) */ {
 public:
  inline CreateSpaceResp() : CreateSpaceResp(nullptr) {}
  ~CreateSpaceResp() override;
  explicit PROTOBUF_CONSTEXPR CreateSpaceResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSpaceResp(const CreateSpaceResp& from);
  CreateSpaceResp(CreateSpaceResp&& from) noexcept
    : CreateSpaceResp() {
    *this = ::std::move(from);
  }

  inline CreateSpaceResp& operator=(const CreateSpaceResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSpaceResp& operator=(CreateSpaceResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSpaceResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSpaceResp* internal_default_instance() {
    return reinterpret_cast<const CreateSpaceResp*>(
               &_CreateSpaceResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CreateSpaceResp& a, CreateSpaceResp& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSpaceResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSpaceResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSpaceResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSpaceResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSpaceResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateSpaceResp& from) {
    CreateSpaceResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSpaceResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CreateSpaceResp";
  }
  protected:
  explicit CreateSpaceResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewSpaceInfoFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.SpaceInfo newSpaceInfo = 10;
  bool has_newspaceinfo() const;
  private:
  bool _internal_has_newspaceinfo() const;
  public:
  void clear_newspaceinfo();
  const ::ServerData::SpaceInfo& newspaceinfo() const;
  PROTOBUF_NODISCARD ::ServerData::SpaceInfo* release_newspaceinfo();
  ::ServerData::SpaceInfo* mutable_newspaceinfo();
  void set_allocated_newspaceinfo(::ServerData::SpaceInfo* newspaceinfo);
  private:
  const ::ServerData::SpaceInfo& _internal_newspaceinfo() const;
  ::ServerData::SpaceInfo* _internal_mutable_newspaceinfo();
  public:
  void unsafe_arena_set_allocated_newspaceinfo(
      ::ServerData::SpaceInfo* newspaceinfo);
  ::ServerData::SpaceInfo* unsafe_arena_release_newspaceinfo();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CreateSpaceResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::SpaceInfo* newspaceinfo_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchAllUserRolesReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchAllUserRolesReq) */ {
 public:
  inline FetchAllUserRolesReq() : FetchAllUserRolesReq(nullptr) {}
  ~FetchAllUserRolesReq() override;
  explicit PROTOBUF_CONSTEXPR FetchAllUserRolesReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchAllUserRolesReq(const FetchAllUserRolesReq& from);
  FetchAllUserRolesReq(FetchAllUserRolesReq&& from) noexcept
    : FetchAllUserRolesReq() {
    *this = ::std::move(from);
  }

  inline FetchAllUserRolesReq& operator=(const FetchAllUserRolesReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchAllUserRolesReq& operator=(FetchAllUserRolesReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchAllUserRolesReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchAllUserRolesReq* internal_default_instance() {
    return reinterpret_cast<const FetchAllUserRolesReq*>(
               &_FetchAllUserRolesReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(FetchAllUserRolesReq& a, FetchAllUserRolesReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchAllUserRolesReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchAllUserRolesReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchAllUserRolesReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchAllUserRolesReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchAllUserRolesReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchAllUserRolesReq& from) {
    FetchAllUserRolesReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchAllUserRolesReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchAllUserRolesReq";
  }
  protected:
  explicit FetchAllUserRolesReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchAllUserRolesReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchAllUserRolesResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchAllUserRolesResp) */ {
 public:
  inline FetchAllUserRolesResp() : FetchAllUserRolesResp(nullptr) {}
  ~FetchAllUserRolesResp() override;
  explicit PROTOBUF_CONSTEXPR FetchAllUserRolesResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchAllUserRolesResp(const FetchAllUserRolesResp& from);
  FetchAllUserRolesResp(FetchAllUserRolesResp&& from) noexcept
    : FetchAllUserRolesResp() {
    *this = ::std::move(from);
  }

  inline FetchAllUserRolesResp& operator=(const FetchAllUserRolesResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchAllUserRolesResp& operator=(FetchAllUserRolesResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchAllUserRolesResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchAllUserRolesResp* internal_default_instance() {
    return reinterpret_cast<const FetchAllUserRolesResp*>(
               &_FetchAllUserRolesResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(FetchAllUserRolesResp& a, FetchAllUserRolesResp& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchAllUserRolesResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchAllUserRolesResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchAllUserRolesResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchAllUserRolesResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchAllUserRolesResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchAllUserRolesResp& from) {
    FetchAllUserRolesResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchAllUserRolesResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchAllUserRolesResp";
  }
  protected:
  explicit FetchAllUserRolesResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllRolesFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // repeated .ServerData.CavrnusRole allRoles = 10;
  int allroles_size() const;
  private:
  int _internal_allroles_size() const;
  public:
  void clear_allroles();
  ::ServerData::CavrnusRole* mutable_allroles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRole >*
      mutable_allroles();
  private:
  const ::ServerData::CavrnusRole& _internal_allroles(int index) const;
  ::ServerData::CavrnusRole* _internal_add_allroles();
  public:
  const ::ServerData::CavrnusRole& allroles(int index) const;
  ::ServerData::CavrnusRole* add_allroles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRole >&
      allroles() const;

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchAllUserRolesResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRole > allroles_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchAllUserAccountsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchAllUserAccountsReq) */ {
 public:
  inline FetchAllUserAccountsReq() : FetchAllUserAccountsReq(nullptr) {}
  ~FetchAllUserAccountsReq() override;
  explicit PROTOBUF_CONSTEXPR FetchAllUserAccountsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchAllUserAccountsReq(const FetchAllUserAccountsReq& from);
  FetchAllUserAccountsReq(FetchAllUserAccountsReq&& from) noexcept
    : FetchAllUserAccountsReq() {
    *this = ::std::move(from);
  }

  inline FetchAllUserAccountsReq& operator=(const FetchAllUserAccountsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchAllUserAccountsReq& operator=(FetchAllUserAccountsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchAllUserAccountsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchAllUserAccountsReq* internal_default_instance() {
    return reinterpret_cast<const FetchAllUserAccountsReq*>(
               &_FetchAllUserAccountsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(FetchAllUserAccountsReq& a, FetchAllUserAccountsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchAllUserAccountsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchAllUserAccountsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchAllUserAccountsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchAllUserAccountsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchAllUserAccountsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchAllUserAccountsReq& from) {
    FetchAllUserAccountsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchAllUserAccountsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchAllUserAccountsReq";
  }
  protected:
  explicit FetchAllUserAccountsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchAllUserAccountsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchAllUserAccountsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchAllUserAccountsResp) */ {
 public:
  inline FetchAllUserAccountsResp() : FetchAllUserAccountsResp(nullptr) {}
  ~FetchAllUserAccountsResp() override;
  explicit PROTOBUF_CONSTEXPR FetchAllUserAccountsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchAllUserAccountsResp(const FetchAllUserAccountsResp& from);
  FetchAllUserAccountsResp(FetchAllUserAccountsResp&& from) noexcept
    : FetchAllUserAccountsResp() {
    *this = ::std::move(from);
  }

  inline FetchAllUserAccountsResp& operator=(const FetchAllUserAccountsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchAllUserAccountsResp& operator=(FetchAllUserAccountsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchAllUserAccountsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchAllUserAccountsResp* internal_default_instance() {
    return reinterpret_cast<const FetchAllUserAccountsResp*>(
               &_FetchAllUserAccountsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(FetchAllUserAccountsResp& a, FetchAllUserAccountsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchAllUserAccountsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchAllUserAccountsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchAllUserAccountsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchAllUserAccountsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchAllUserAccountsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchAllUserAccountsResp& from) {
    FetchAllUserAccountsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchAllUserAccountsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchAllUserAccountsResp";
  }
  protected:
  explicit FetchAllUserAccountsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllUserAccountsFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // repeated .ServerData.CavrnusUserAccount allUserAccounts = 10;
  int alluseraccounts_size() const;
  private:
  int _internal_alluseraccounts_size() const;
  public:
  void clear_alluseraccounts();
  ::ServerData::CavrnusUserAccount* mutable_alluseraccounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusUserAccount >*
      mutable_alluseraccounts();
  private:
  const ::ServerData::CavrnusUserAccount& _internal_alluseraccounts(int index) const;
  ::ServerData::CavrnusUserAccount* _internal_add_alluseraccounts();
  public:
  const ::ServerData::CavrnusUserAccount& alluseraccounts(int index) const;
  ::ServerData::CavrnusUserAccount* add_alluseraccounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusUserAccount >&
      alluseraccounts() const;

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchAllUserAccountsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusUserAccount > alluseraccounts_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class InviteUserAccountToSpaceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.InviteUserAccountToSpaceReq) */ {
 public:
  inline InviteUserAccountToSpaceReq() : InviteUserAccountToSpaceReq(nullptr) {}
  ~InviteUserAccountToSpaceReq() override;
  explicit PROTOBUF_CONSTEXPR InviteUserAccountToSpaceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InviteUserAccountToSpaceReq(const InviteUserAccountToSpaceReq& from);
  InviteUserAccountToSpaceReq(InviteUserAccountToSpaceReq&& from) noexcept
    : InviteUserAccountToSpaceReq() {
    *this = ::std::move(from);
  }

  inline InviteUserAccountToSpaceReq& operator=(const InviteUserAccountToSpaceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline InviteUserAccountToSpaceReq& operator=(InviteUserAccountToSpaceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InviteUserAccountToSpaceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const InviteUserAccountToSpaceReq* internal_default_instance() {
    return reinterpret_cast<const InviteUserAccountToSpaceReq*>(
               &_InviteUserAccountToSpaceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(InviteUserAccountToSpaceReq& a, InviteUserAccountToSpaceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(InviteUserAccountToSpaceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InviteUserAccountToSpaceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InviteUserAccountToSpaceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InviteUserAccountToSpaceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InviteUserAccountToSpaceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InviteUserAccountToSpaceReq& from) {
    InviteUserAccountToSpaceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InviteUserAccountToSpaceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.InviteUserAccountToSpaceReq";
  }
  protected:
  explicit InviteUserAccountToSpaceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserEmailFieldNumber = 10,
    kSpaceIdFieldNumber = 11,
    kRoleIdFieldNumber = 12,
    kReqIdFieldNumber = 1,
  };
  // string userEmail = 10;
  void clear_useremail();
  const std::string& useremail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_useremail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_useremail();
  PROTOBUF_NODISCARD std::string* release_useremail();
  void set_allocated_useremail(std::string* useremail);
  private:
  const std::string& _internal_useremail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_useremail(const std::string& value);
  std::string* _internal_mutable_useremail();
  public:

  // string spaceId = 11;
  void clear_spaceid();
  const std::string& spaceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spaceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spaceid();
  PROTOBUF_NODISCARD std::string* release_spaceid();
  void set_allocated_spaceid(std::string* spaceid);
  private:
  const std::string& _internal_spaceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spaceid(const std::string& value);
  std::string* _internal_mutable_spaceid();
  public:

  // optional string roleId = 12;
  bool has_roleid() const;
  private:
  bool _internal_has_roleid() const;
  public:
  void clear_roleid();
  const std::string& roleid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roleid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roleid();
  PROTOBUF_NODISCARD std::string* release_roleid();
  void set_allocated_roleid(std::string* roleid);
  private:
  const std::string& _internal_roleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roleid(const std::string& value);
  std::string* _internal_mutable_roleid();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.InviteUserAccountToSpaceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr useremail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spaceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roleid_;
    int32_t reqid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class RemoveUserAccountFromSpaceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RemoveUserAccountFromSpaceReq) */ {
 public:
  inline RemoveUserAccountFromSpaceReq() : RemoveUserAccountFromSpaceReq(nullptr) {}
  ~RemoveUserAccountFromSpaceReq() override;
  explicit PROTOBUF_CONSTEXPR RemoveUserAccountFromSpaceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveUserAccountFromSpaceReq(const RemoveUserAccountFromSpaceReq& from);
  RemoveUserAccountFromSpaceReq(RemoveUserAccountFromSpaceReq&& from) noexcept
    : RemoveUserAccountFromSpaceReq() {
    *this = ::std::move(from);
  }

  inline RemoveUserAccountFromSpaceReq& operator=(const RemoveUserAccountFromSpaceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveUserAccountFromSpaceReq& operator=(RemoveUserAccountFromSpaceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveUserAccountFromSpaceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveUserAccountFromSpaceReq* internal_default_instance() {
    return reinterpret_cast<const RemoveUserAccountFromSpaceReq*>(
               &_RemoveUserAccountFromSpaceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(RemoveUserAccountFromSpaceReq& a, RemoveUserAccountFromSpaceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveUserAccountFromSpaceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveUserAccountFromSpaceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveUserAccountFromSpaceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveUserAccountFromSpaceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveUserAccountFromSpaceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveUserAccountFromSpaceReq& from) {
    RemoveUserAccountFromSpaceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveUserAccountFromSpaceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RemoveUserAccountFromSpaceReq";
  }
  protected:
  explicit RemoveUserAccountFromSpaceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserAccountIdFieldNumber = 10,
    kSpaceIdFieldNumber = 11,
    kReqIdFieldNumber = 1,
  };
  // string userAccountId = 10;
  void clear_useraccountid();
  const std::string& useraccountid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_useraccountid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_useraccountid();
  PROTOBUF_NODISCARD std::string* release_useraccountid();
  void set_allocated_useraccountid(std::string* useraccountid);
  private:
  const std::string& _internal_useraccountid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_useraccountid(const std::string& value);
  std::string* _internal_mutable_useraccountid();
  public:

  // string spaceId = 11;
  void clear_spaceid();
  const std::string& spaceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spaceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spaceid();
  PROTOBUF_NODISCARD std::string* release_spaceid();
  void set_allocated_spaceid(std::string* spaceid);
  private:
  const std::string& _internal_spaceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spaceid(const std::string& value);
  std::string* _internal_mutable_spaceid();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.RemoveUserAccountFromSpaceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr useraccountid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spaceid_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PropertyValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PropertyValue) */ {
 public:
  inline PropertyValue() : PropertyValue(nullptr) {}
  ~PropertyValue() override;
  explicit PROTOBUF_CONSTEXPR PropertyValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropertyValue(const PropertyValue& from);
  PropertyValue(PropertyValue&& from) noexcept
    : PropertyValue() {
    *this = ::std::move(from);
  }

  inline PropertyValue& operator=(const PropertyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropertyValue& operator=(PropertyValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropertyValue& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kBoolVal = 10,
    kStringVal = 11,
    kScalarVal = 12,
    kVectorVal = 13,
    kColorVal = 14,
    kTransformVal = 17,
    kLinkVal = 15,
    VALUE_NOT_SET = 0,
  };

  static inline const PropertyValue* internal_default_instance() {
    return reinterpret_cast<const PropertyValue*>(
               &_PropertyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(PropertyValue& a, PropertyValue& b) {
    a.Swap(&b);
  }
  inline void Swap(PropertyValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropertyValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropertyValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropertyValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PropertyValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PropertyValue& from) {
    PropertyValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropertyValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PropertyValue";
  }
  protected:
  explicit PropertyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoolValFieldNumber = 10,
    kStringValFieldNumber = 11,
    kScalarValFieldNumber = 12,
    kVectorValFieldNumber = 13,
    kColorValFieldNumber = 14,
    kTransformValFieldNumber = 17,
    kLinkValFieldNumber = 15,
  };
  // bool boolVal = 10;
  bool has_boolval() const;
  private:
  bool _internal_has_boolval() const;
  public:
  void clear_boolval();
  bool boolval() const;
  void set_boolval(bool value);
  private:
  bool _internal_boolval() const;
  void _internal_set_boolval(bool value);
  public:

  // string stringVal = 11;
  bool has_stringval() const;
  private:
  bool _internal_has_stringval() const;
  public:
  void clear_stringval();
  const std::string& stringval() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stringval(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stringval();
  PROTOBUF_NODISCARD std::string* release_stringval();
  void set_allocated_stringval(std::string* stringval);
  private:
  const std::string& _internal_stringval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stringval(const std::string& value);
  std::string* _internal_mutable_stringval();
  public:

  // float scalarVal = 12;
  bool has_scalarval() const;
  private:
  bool _internal_has_scalarval() const;
  public:
  void clear_scalarval();
  float scalarval() const;
  void set_scalarval(float value);
  private:
  float _internal_scalarval() const;
  void _internal_set_scalarval(float value);
  public:

  // .Common.Float4 vectorVal = 13;
  bool has_vectorval() const;
  private:
  bool _internal_has_vectorval() const;
  public:
  void clear_vectorval();
  const ::Common::Float4& vectorval() const;
  PROTOBUF_NODISCARD ::Common::Float4* release_vectorval();
  ::Common::Float4* mutable_vectorval();
  void set_allocated_vectorval(::Common::Float4* vectorval);
  private:
  const ::Common::Float4& _internal_vectorval() const;
  ::Common::Float4* _internal_mutable_vectorval();
  public:
  void unsafe_arena_set_allocated_vectorval(
      ::Common::Float4* vectorval);
  ::Common::Float4* unsafe_arena_release_vectorval();

  // .Common.Color4 colorVal = 14;
  bool has_colorval() const;
  private:
  bool _internal_has_colorval() const;
  public:
  void clear_colorval();
  const ::Common::Color4& colorval() const;
  PROTOBUF_NODISCARD ::Common::Color4* release_colorval();
  ::Common::Color4* mutable_colorval();
  void set_allocated_colorval(::Common::Color4* colorval);
  private:
  const ::Common::Color4& _internal_colorval() const;
  ::Common::Color4* _internal_mutable_colorval();
  public:
  void unsafe_arena_set_allocated_colorval(
      ::Common::Color4* colorval);
  ::Common::Color4* unsafe_arena_release_colorval();

  // .ServerData.TransformPropertyValue transformVal = 17;
  bool has_transformval() const;
  private:
  bool _internal_has_transformval() const;
  public:
  void clear_transformval();
  const ::ServerData::TransformPropertyValue& transformval() const;
  PROTOBUF_NODISCARD ::ServerData::TransformPropertyValue* release_transformval();
  ::ServerData::TransformPropertyValue* mutable_transformval();
  void set_allocated_transformval(::ServerData::TransformPropertyValue* transformval);
  private:
  const ::ServerData::TransformPropertyValue& _internal_transformval() const;
  ::ServerData::TransformPropertyValue* _internal_mutable_transformval();
  public:
  void unsafe_arena_set_allocated_transformval(
      ::ServerData::TransformPropertyValue* transformval);
  ::ServerData::TransformPropertyValue* unsafe_arena_release_transformval();

  // .Property.PropertyIdentifier linkVal = 15;
  bool has_linkval() const;
  private:
  bool _internal_has_linkval() const;
  public:
  void clear_linkval();
  const ::Property::PropertyIdentifier& linkval() const;
  PROTOBUF_NODISCARD ::Property::PropertyIdentifier* release_linkval();
  ::Property::PropertyIdentifier* mutable_linkval();
  void set_allocated_linkval(::Property::PropertyIdentifier* linkval);
  private:
  const ::Property::PropertyIdentifier& _internal_linkval() const;
  ::Property::PropertyIdentifier* _internal_mutable_linkval();
  public:
  void unsafe_arena_set_allocated_linkval(
      ::Property::PropertyIdentifier* linkval);
  ::Property::PropertyIdentifier* unsafe_arena_release_linkval();

  void clear_Value();
  ValueCase Value_case() const;
  // @@protoc_insertion_point(class_scope:ServerData.PropertyValue)
 private:
  class _Internal;
  void set_has_boolval();
  void set_has_stringval();
  void set_has_scalarval();
  void set_has_vectorval();
  void set_has_colorval();
  void set_has_transformval();
  void set_has_linkval();

  inline bool has_Value() const;
  inline void clear_has_Value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool boolval_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stringval_;
      float scalarval_;
      ::Common::Float4* vectorval_;
      ::Common::Color4* colorval_;
      ::ServerData::TransformPropertyValue* transformval_;
      ::Property::PropertyIdentifier* linkval_;
    } Value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class DefinePropertyDefaultValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.DefinePropertyDefaultValue) */ {
 public:
  inline DefinePropertyDefaultValue() : DefinePropertyDefaultValue(nullptr) {}
  ~DefinePropertyDefaultValue() override;
  explicit PROTOBUF_CONSTEXPR DefinePropertyDefaultValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefinePropertyDefaultValue(const DefinePropertyDefaultValue& from);
  DefinePropertyDefaultValue(DefinePropertyDefaultValue&& from) noexcept
    : DefinePropertyDefaultValue() {
    *this = ::std::move(from);
  }

  inline DefinePropertyDefaultValue& operator=(const DefinePropertyDefaultValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefinePropertyDefaultValue& operator=(DefinePropertyDefaultValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefinePropertyDefaultValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefinePropertyDefaultValue* internal_default_instance() {
    return reinterpret_cast<const DefinePropertyDefaultValue*>(
               &_DefinePropertyDefaultValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(DefinePropertyDefaultValue& a, DefinePropertyDefaultValue& b) {
    a.Swap(&b);
  }
  inline void Swap(DefinePropertyDefaultValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefinePropertyDefaultValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefinePropertyDefaultValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefinePropertyDefaultValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefinePropertyDefaultValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DefinePropertyDefaultValue& from) {
    DefinePropertyDefaultValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefinePropertyDefaultValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.DefinePropertyDefaultValue";
  }
  protected:
  explicit DefinePropertyDefaultValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertyIdFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
    kPropertyValueFieldNumber = 10,
    kLocalChangeIdFieldNumber = 3,
  };
  // string PropertyId = 2;
  void clear_propertyid();
  const std::string& propertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_propertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_propertyid();
  PROTOBUF_NODISCARD std::string* release_propertyid();
  void set_allocated_propertyid(std::string* propertyid);
  private:
  const std::string& _internal_propertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_propertyid(const std::string& value);
  std::string* _internal_mutable_propertyid();
  public:

  // .ServerData.CavrnusSpaceConnection SpaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.PropertyValue PropertyValue = 10;
  bool has_propertyvalue() const;
  private:
  bool _internal_has_propertyvalue() const;
  public:
  void clear_propertyvalue();
  const ::ServerData::PropertyValue& propertyvalue() const;
  PROTOBUF_NODISCARD ::ServerData::PropertyValue* release_propertyvalue();
  ::ServerData::PropertyValue* mutable_propertyvalue();
  void set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue);
  private:
  const ::ServerData::PropertyValue& _internal_propertyvalue() const;
  ::ServerData::PropertyValue* _internal_mutable_propertyvalue();
  public:
  void unsafe_arena_set_allocated_propertyvalue(
      ::ServerData::PropertyValue* propertyvalue);
  ::ServerData::PropertyValue* unsafe_arena_release_propertyvalue();

  // int32 localChangeId = 3;
  void clear_localchangeid();
  int32_t localchangeid() const;
  void set_localchangeid(int32_t value);
  private:
  int32_t _internal_localchangeid() const;
  void _internal_set_localchangeid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.DefinePropertyDefaultValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr propertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::PropertyValue* propertyvalue_;
    int32_t localchangeid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PostPropertyUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PostPropertyUpdate) */ {
 public:
  inline PostPropertyUpdate() : PostPropertyUpdate(nullptr) {}
  ~PostPropertyUpdate() override;
  explicit PROTOBUF_CONSTEXPR PostPropertyUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostPropertyUpdate(const PostPropertyUpdate& from);
  PostPropertyUpdate(PostPropertyUpdate&& from) noexcept
    : PostPropertyUpdate() {
    *this = ::std::move(from);
  }

  inline PostPropertyUpdate& operator=(const PostPropertyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostPropertyUpdate& operator=(PostPropertyUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostPropertyUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostPropertyUpdate* internal_default_instance() {
    return reinterpret_cast<const PostPropertyUpdate*>(
               &_PostPropertyUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(PostPropertyUpdate& a, PostPropertyUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(PostPropertyUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostPropertyUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostPropertyUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostPropertyUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostPropertyUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostPropertyUpdate& from) {
    PostPropertyUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostPropertyUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PostPropertyUpdate";
  }
  protected:
  explicit PostPropertyUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertyIdFieldNumber = 3,
    kSpaceConnFieldNumber = 1,
    kPropertyValueFieldNumber = 10,
    kLocalChangeIdFieldNumber = 4,
    kSmoothFieldNumber = 20,
  };
  // string PropertyId = 3;
  void clear_propertyid();
  const std::string& propertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_propertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_propertyid();
  PROTOBUF_NODISCARD std::string* release_propertyid();
  void set_allocated_propertyid(std::string* propertyid);
  private:
  const std::string& _internal_propertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_propertyid(const std::string& value);
  std::string* _internal_mutable_propertyid();
  public:

  // .ServerData.CavrnusSpaceConnection SpaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.PropertyValue PropertyValue = 10;
  bool has_propertyvalue() const;
  private:
  bool _internal_has_propertyvalue() const;
  public:
  void clear_propertyvalue();
  const ::ServerData::PropertyValue& propertyvalue() const;
  PROTOBUF_NODISCARD ::ServerData::PropertyValue* release_propertyvalue();
  ::ServerData::PropertyValue* mutable_propertyvalue();
  void set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue);
  private:
  const ::ServerData::PropertyValue& _internal_propertyvalue() const;
  ::ServerData::PropertyValue* _internal_mutable_propertyvalue();
  public:
  void unsafe_arena_set_allocated_propertyvalue(
      ::ServerData::PropertyValue* propertyvalue);
  ::ServerData::PropertyValue* unsafe_arena_release_propertyvalue();

  // int32 localChangeId = 4;
  void clear_localchangeid();
  int32_t localchangeid() const;
  void set_localchangeid(int32_t value);
  private:
  int32_t _internal_localchangeid() const;
  void _internal_set_localchangeid(int32_t value);
  public:

  // bool smooth = 20;
  void clear_smooth();
  bool smooth() const;
  void set_smooth(bool value);
  private:
  bool _internal_smooth() const;
  void _internal_set_smooth(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.PostPropertyUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr propertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::PropertyValue* propertyvalue_;
    int32_t localchangeid_;
    bool smooth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class BeginTransientPropertyUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.BeginTransientPropertyUpdate) */ {
 public:
  inline BeginTransientPropertyUpdate() : BeginTransientPropertyUpdate(nullptr) {}
  ~BeginTransientPropertyUpdate() override;
  explicit PROTOBUF_CONSTEXPR BeginTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeginTransientPropertyUpdate(const BeginTransientPropertyUpdate& from);
  BeginTransientPropertyUpdate(BeginTransientPropertyUpdate&& from) noexcept
    : BeginTransientPropertyUpdate() {
    *this = ::std::move(from);
  }

  inline BeginTransientPropertyUpdate& operator=(const BeginTransientPropertyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeginTransientPropertyUpdate& operator=(BeginTransientPropertyUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeginTransientPropertyUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeginTransientPropertyUpdate* internal_default_instance() {
    return reinterpret_cast<const BeginTransientPropertyUpdate*>(
               &_BeginTransientPropertyUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(BeginTransientPropertyUpdate& a, BeginTransientPropertyUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(BeginTransientPropertyUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeginTransientPropertyUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeginTransientPropertyUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeginTransientPropertyUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeginTransientPropertyUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeginTransientPropertyUpdate& from) {
    BeginTransientPropertyUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeginTransientPropertyUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.BeginTransientPropertyUpdate";
  }
  protected:
  explicit BeginTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiveUpdaterIdFieldNumber = 2,
    kPropertyIdFieldNumber = 3,
    kSpaceConnFieldNumber = 1,
    kPropertyValueFieldNumber = 10,
    kLocalChangeIdFieldNumber = 4,
    kSmoothFieldNumber = 20,
  };
  // string LiveUpdaterId = 2;
  void clear_liveupdaterid();
  const std::string& liveupdaterid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_liveupdaterid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_liveupdaterid();
  PROTOBUF_NODISCARD std::string* release_liveupdaterid();
  void set_allocated_liveupdaterid(std::string* liveupdaterid);
  private:
  const std::string& _internal_liveupdaterid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_liveupdaterid(const std::string& value);
  std::string* _internal_mutable_liveupdaterid();
  public:

  // string PropertyId = 3;
  void clear_propertyid();
  const std::string& propertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_propertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_propertyid();
  PROTOBUF_NODISCARD std::string* release_propertyid();
  void set_allocated_propertyid(std::string* propertyid);
  private:
  const std::string& _internal_propertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_propertyid(const std::string& value);
  std::string* _internal_mutable_propertyid();
  public:

  // .ServerData.CavrnusSpaceConnection SpaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.PropertyValue PropertyValue = 10;
  bool has_propertyvalue() const;
  private:
  bool _internal_has_propertyvalue() const;
  public:
  void clear_propertyvalue();
  const ::ServerData::PropertyValue& propertyvalue() const;
  PROTOBUF_NODISCARD ::ServerData::PropertyValue* release_propertyvalue();
  ::ServerData::PropertyValue* mutable_propertyvalue();
  void set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue);
  private:
  const ::ServerData::PropertyValue& _internal_propertyvalue() const;
  ::ServerData::PropertyValue* _internal_mutable_propertyvalue();
  public:
  void unsafe_arena_set_allocated_propertyvalue(
      ::ServerData::PropertyValue* propertyvalue);
  ::ServerData::PropertyValue* unsafe_arena_release_propertyvalue();

  // int32 localChangeId = 4;
  void clear_localchangeid();
  int32_t localchangeid() const;
  void set_localchangeid(int32_t value);
  private:
  int32_t _internal_localchangeid() const;
  void _internal_set_localchangeid(int32_t value);
  public:

  // bool smooth = 20;
  void clear_smooth();
  bool smooth() const;
  void set_smooth(bool value);
  private:
  bool _internal_smooth() const;
  void _internal_set_smooth(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.BeginTransientPropertyUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr liveupdaterid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr propertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::PropertyValue* propertyvalue_;
    int32_t localchangeid_;
    bool smooth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ContinueTransientPropertyUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ContinueTransientPropertyUpdate) */ {
 public:
  inline ContinueTransientPropertyUpdate() : ContinueTransientPropertyUpdate(nullptr) {}
  ~ContinueTransientPropertyUpdate() override;
  explicit PROTOBUF_CONSTEXPR ContinueTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContinueTransientPropertyUpdate(const ContinueTransientPropertyUpdate& from);
  ContinueTransientPropertyUpdate(ContinueTransientPropertyUpdate&& from) noexcept
    : ContinueTransientPropertyUpdate() {
    *this = ::std::move(from);
  }

  inline ContinueTransientPropertyUpdate& operator=(const ContinueTransientPropertyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContinueTransientPropertyUpdate& operator=(ContinueTransientPropertyUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContinueTransientPropertyUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContinueTransientPropertyUpdate* internal_default_instance() {
    return reinterpret_cast<const ContinueTransientPropertyUpdate*>(
               &_ContinueTransientPropertyUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(ContinueTransientPropertyUpdate& a, ContinueTransientPropertyUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ContinueTransientPropertyUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContinueTransientPropertyUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContinueTransientPropertyUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContinueTransientPropertyUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContinueTransientPropertyUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContinueTransientPropertyUpdate& from) {
    ContinueTransientPropertyUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContinueTransientPropertyUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ContinueTransientPropertyUpdate";
  }
  protected:
  explicit ContinueTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiveUpdaterIdFieldNumber = 2,
    kPropertyIdFieldNumber = 3,
    kSpaceConnFieldNumber = 1,
    kPropertyValueFieldNumber = 10,
    kLocalChangeIdFieldNumber = 4,
    kSmoothFieldNumber = 20,
  };
  // string LiveUpdaterId = 2;
  void clear_liveupdaterid();
  const std::string& liveupdaterid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_liveupdaterid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_liveupdaterid();
  PROTOBUF_NODISCARD std::string* release_liveupdaterid();
  void set_allocated_liveupdaterid(std::string* liveupdaterid);
  private:
  const std::string& _internal_liveupdaterid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_liveupdaterid(const std::string& value);
  std::string* _internal_mutable_liveupdaterid();
  public:

  // string PropertyId = 3;
  void clear_propertyid();
  const std::string& propertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_propertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_propertyid();
  PROTOBUF_NODISCARD std::string* release_propertyid();
  void set_allocated_propertyid(std::string* propertyid);
  private:
  const std::string& _internal_propertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_propertyid(const std::string& value);
  std::string* _internal_mutable_propertyid();
  public:

  // .ServerData.CavrnusSpaceConnection SpaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.PropertyValue PropertyValue = 10;
  bool has_propertyvalue() const;
  private:
  bool _internal_has_propertyvalue() const;
  public:
  void clear_propertyvalue();
  const ::ServerData::PropertyValue& propertyvalue() const;
  PROTOBUF_NODISCARD ::ServerData::PropertyValue* release_propertyvalue();
  ::ServerData::PropertyValue* mutable_propertyvalue();
  void set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue);
  private:
  const ::ServerData::PropertyValue& _internal_propertyvalue() const;
  ::ServerData::PropertyValue* _internal_mutable_propertyvalue();
  public:
  void unsafe_arena_set_allocated_propertyvalue(
      ::ServerData::PropertyValue* propertyvalue);
  ::ServerData::PropertyValue* unsafe_arena_release_propertyvalue();

  // int32 localChangeId = 4;
  void clear_localchangeid();
  int32_t localchangeid() const;
  void set_localchangeid(int32_t value);
  private:
  int32_t _internal_localchangeid() const;
  void _internal_set_localchangeid(int32_t value);
  public:

  // bool smooth = 20;
  void clear_smooth();
  bool smooth() const;
  void set_smooth(bool value);
  private:
  bool _internal_smooth() const;
  void _internal_set_smooth(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.ContinueTransientPropertyUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr liveupdaterid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr propertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::PropertyValue* propertyvalue_;
    int32_t localchangeid_;
    bool smooth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FinalizeTransientPropertyUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FinalizeTransientPropertyUpdate) */ {
 public:
  inline FinalizeTransientPropertyUpdate() : FinalizeTransientPropertyUpdate(nullptr) {}
  ~FinalizeTransientPropertyUpdate() override;
  explicit PROTOBUF_CONSTEXPR FinalizeTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FinalizeTransientPropertyUpdate(const FinalizeTransientPropertyUpdate& from);
  FinalizeTransientPropertyUpdate(FinalizeTransientPropertyUpdate&& from) noexcept
    : FinalizeTransientPropertyUpdate() {
    *this = ::std::move(from);
  }

  inline FinalizeTransientPropertyUpdate& operator=(const FinalizeTransientPropertyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinalizeTransientPropertyUpdate& operator=(FinalizeTransientPropertyUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FinalizeTransientPropertyUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const FinalizeTransientPropertyUpdate* internal_default_instance() {
    return reinterpret_cast<const FinalizeTransientPropertyUpdate*>(
               &_FinalizeTransientPropertyUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(FinalizeTransientPropertyUpdate& a, FinalizeTransientPropertyUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(FinalizeTransientPropertyUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinalizeTransientPropertyUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FinalizeTransientPropertyUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FinalizeTransientPropertyUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FinalizeTransientPropertyUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FinalizeTransientPropertyUpdate& from) {
    FinalizeTransientPropertyUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinalizeTransientPropertyUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FinalizeTransientPropertyUpdate";
  }
  protected:
  explicit FinalizeTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiveUpdaterIdFieldNumber = 2,
    kPropertyIdFieldNumber = 3,
    kSpaceConnFieldNumber = 1,
    kPropertyValueFieldNumber = 10,
    kLocalChangeIdFieldNumber = 4,
    kSmoothFieldNumber = 20,
  };
  // string LiveUpdaterId = 2;
  void clear_liveupdaterid();
  const std::string& liveupdaterid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_liveupdaterid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_liveupdaterid();
  PROTOBUF_NODISCARD std::string* release_liveupdaterid();
  void set_allocated_liveupdaterid(std::string* liveupdaterid);
  private:
  const std::string& _internal_liveupdaterid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_liveupdaterid(const std::string& value);
  std::string* _internal_mutable_liveupdaterid();
  public:

  // string PropertyId = 3;
  void clear_propertyid();
  const std::string& propertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_propertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_propertyid();
  PROTOBUF_NODISCARD std::string* release_propertyid();
  void set_allocated_propertyid(std::string* propertyid);
  private:
  const std::string& _internal_propertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_propertyid(const std::string& value);
  std::string* _internal_mutable_propertyid();
  public:

  // .ServerData.CavrnusSpaceConnection SpaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.PropertyValue PropertyValue = 10;
  bool has_propertyvalue() const;
  private:
  bool _internal_has_propertyvalue() const;
  public:
  void clear_propertyvalue();
  const ::ServerData::PropertyValue& propertyvalue() const;
  PROTOBUF_NODISCARD ::ServerData::PropertyValue* release_propertyvalue();
  ::ServerData::PropertyValue* mutable_propertyvalue();
  void set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue);
  private:
  const ::ServerData::PropertyValue& _internal_propertyvalue() const;
  ::ServerData::PropertyValue* _internal_mutable_propertyvalue();
  public:
  void unsafe_arena_set_allocated_propertyvalue(
      ::ServerData::PropertyValue* propertyvalue);
  ::ServerData::PropertyValue* unsafe_arena_release_propertyvalue();

  // int32 localChangeId = 4;
  void clear_localchangeid();
  int32_t localchangeid() const;
  void set_localchangeid(int32_t value);
  private:
  int32_t _internal_localchangeid() const;
  void _internal_set_localchangeid(int32_t value);
  public:

  // bool smooth = 20;
  void clear_smooth();
  bool smooth() const;
  void set_smooth(bool value);
  private:
  bool _internal_smooth() const;
  void _internal_set_smooth(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FinalizeTransientPropertyUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr liveupdaterid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr propertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::PropertyValue* propertyvalue_;
    int32_t localchangeid_;
    bool smooth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class CancelTransientPropertyUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CancelTransientPropertyUpdate) */ {
 public:
  inline CancelTransientPropertyUpdate() : CancelTransientPropertyUpdate(nullptr) {}
  ~CancelTransientPropertyUpdate() override;
  explicit PROTOBUF_CONSTEXPR CancelTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelTransientPropertyUpdate(const CancelTransientPropertyUpdate& from);
  CancelTransientPropertyUpdate(CancelTransientPropertyUpdate&& from) noexcept
    : CancelTransientPropertyUpdate() {
    *this = ::std::move(from);
  }

  inline CancelTransientPropertyUpdate& operator=(const CancelTransientPropertyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelTransientPropertyUpdate& operator=(CancelTransientPropertyUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelTransientPropertyUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelTransientPropertyUpdate* internal_default_instance() {
    return reinterpret_cast<const CancelTransientPropertyUpdate*>(
               &_CancelTransientPropertyUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(CancelTransientPropertyUpdate& a, CancelTransientPropertyUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelTransientPropertyUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelTransientPropertyUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelTransientPropertyUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelTransientPropertyUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelTransientPropertyUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelTransientPropertyUpdate& from) {
    CancelTransientPropertyUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelTransientPropertyUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CancelTransientPropertyUpdate";
  }
  protected:
  explicit CancelTransientPropertyUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiveUpdaterIdFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
  };
  // string LiveUpdaterId = 2;
  void clear_liveupdaterid();
  const std::string& liveupdaterid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_liveupdaterid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_liveupdaterid();
  PROTOBUF_NODISCARD std::string* release_liveupdaterid();
  void set_allocated_liveupdaterid(std::string* liveupdaterid);
  private:
  const std::string& _internal_liveupdaterid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_liveupdaterid(const std::string& value);
  std::string* _internal_mutable_liveupdaterid();
  public:

  // .ServerData.CavrnusSpaceConnection SpaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // @@protoc_insertion_point(class_scope:ServerData.CancelTransientPropertyUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr liveupdaterid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class TransformPropertyValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.TransformPropertyValue) */ {
 public:
  inline TransformPropertyValue() : TransformPropertyValue(nullptr) {}
  ~TransformPropertyValue() override;
  explicit PROTOBUF_CONSTEXPR TransformPropertyValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransformPropertyValue(const TransformPropertyValue& from);
  TransformPropertyValue(TransformPropertyValue&& from) noexcept
    : TransformPropertyValue() {
    *this = ::std::move(from);
  }

  inline TransformPropertyValue& operator=(const TransformPropertyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransformPropertyValue& operator=(TransformPropertyValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransformPropertyValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransformPropertyValue* internal_default_instance() {
    return reinterpret_cast<const TransformPropertyValue*>(
               &_TransformPropertyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(TransformPropertyValue& a, TransformPropertyValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TransformPropertyValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransformPropertyValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransformPropertyValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransformPropertyValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransformPropertyValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransformPropertyValue& from) {
    TransformPropertyValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformPropertyValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.TransformPropertyValue";
  }
  protected:
  explicit TransformPropertyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kRotFieldNumber = 2,
    kSclFieldNumber = 3,
  };
  // .Common.Float3 pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::Common::Float3& pos() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_pos();
  ::Common::Float3* mutable_pos();
  void set_allocated_pos(::Common::Float3* pos);
  private:
  const ::Common::Float3& _internal_pos() const;
  ::Common::Float3* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::Common::Float3* pos);
  ::Common::Float3* unsafe_arena_release_pos();

  // .Common.Float3 rot = 2;
  bool has_rot() const;
  private:
  bool _internal_has_rot() const;
  public:
  void clear_rot();
  const ::Common::Float3& rot() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_rot();
  ::Common::Float3* mutable_rot();
  void set_allocated_rot(::Common::Float3* rot);
  private:
  const ::Common::Float3& _internal_rot() const;
  ::Common::Float3* _internal_mutable_rot();
  public:
  void unsafe_arena_set_allocated_rot(
      ::Common::Float3* rot);
  ::Common::Float3* unsafe_arena_release_rot();

  // .Common.Float3 scl = 3;
  bool has_scl() const;
  private:
  bool _internal_has_scl() const;
  public:
  void clear_scl();
  const ::Common::Float3& scl() const;
  PROTOBUF_NODISCARD ::Common::Float3* release_scl();
  ::Common::Float3* mutable_scl();
  void set_allocated_scl(::Common::Float3* scl);
  private:
  const ::Common::Float3& _internal_scl() const;
  ::Common::Float3* _internal_mutable_scl();
  public:
  void unsafe_arena_set_allocated_scl(
      ::Common::Float3* scl);
  ::Common::Float3* unsafe_arena_release_scl();

  // @@protoc_insertion_point(class_scope:ServerData.TransformPropertyValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Common::Float3* pos_;
    ::Common::Float3* rot_;
    ::Common::Float3* scl_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class GetAudioInputDevicesReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.GetAudioInputDevicesReq) */ {
 public:
  inline GetAudioInputDevicesReq() : GetAudioInputDevicesReq(nullptr) {}
  ~GetAudioInputDevicesReq() override;
  explicit PROTOBUF_CONSTEXPR GetAudioInputDevicesReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAudioInputDevicesReq(const GetAudioInputDevicesReq& from);
  GetAudioInputDevicesReq(GetAudioInputDevicesReq&& from) noexcept
    : GetAudioInputDevicesReq() {
    *this = ::std::move(from);
  }

  inline GetAudioInputDevicesReq& operator=(const GetAudioInputDevicesReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAudioInputDevicesReq& operator=(GetAudioInputDevicesReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAudioInputDevicesReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAudioInputDevicesReq* internal_default_instance() {
    return reinterpret_cast<const GetAudioInputDevicesReq*>(
               &_GetAudioInputDevicesReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(GetAudioInputDevicesReq& a, GetAudioInputDevicesReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAudioInputDevicesReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAudioInputDevicesReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAudioInputDevicesReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAudioInputDevicesReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAudioInputDevicesReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAudioInputDevicesReq& from) {
    GetAudioInputDevicesReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAudioInputDevicesReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.GetAudioInputDevicesReq";
  }
  protected:
  explicit GetAudioInputDevicesReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.GetAudioInputDevicesReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class GetAudioOutputDevicesReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.GetAudioOutputDevicesReq) */ {
 public:
  inline GetAudioOutputDevicesReq() : GetAudioOutputDevicesReq(nullptr) {}
  ~GetAudioOutputDevicesReq() override;
  explicit PROTOBUF_CONSTEXPR GetAudioOutputDevicesReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAudioOutputDevicesReq(const GetAudioOutputDevicesReq& from);
  GetAudioOutputDevicesReq(GetAudioOutputDevicesReq&& from) noexcept
    : GetAudioOutputDevicesReq() {
    *this = ::std::move(from);
  }

  inline GetAudioOutputDevicesReq& operator=(const GetAudioOutputDevicesReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAudioOutputDevicesReq& operator=(GetAudioOutputDevicesReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAudioOutputDevicesReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAudioOutputDevicesReq* internal_default_instance() {
    return reinterpret_cast<const GetAudioOutputDevicesReq*>(
               &_GetAudioOutputDevicesReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(GetAudioOutputDevicesReq& a, GetAudioOutputDevicesReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAudioOutputDevicesReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAudioOutputDevicesReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAudioOutputDevicesReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAudioOutputDevicesReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAudioOutputDevicesReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAudioOutputDevicesReq& from) {
    GetAudioOutputDevicesReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAudioOutputDevicesReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.GetAudioOutputDevicesReq";
  }
  protected:
  explicit GetAudioOutputDevicesReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.GetAudioOutputDevicesReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class GetVideoInputDevicesReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.GetVideoInputDevicesReq) */ {
 public:
  inline GetVideoInputDevicesReq() : GetVideoInputDevicesReq(nullptr) {}
  ~GetVideoInputDevicesReq() override;
  explicit PROTOBUF_CONSTEXPR GetVideoInputDevicesReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVideoInputDevicesReq(const GetVideoInputDevicesReq& from);
  GetVideoInputDevicesReq(GetVideoInputDevicesReq&& from) noexcept
    : GetVideoInputDevicesReq() {
    *this = ::std::move(from);
  }

  inline GetVideoInputDevicesReq& operator=(const GetVideoInputDevicesReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVideoInputDevicesReq& operator=(GetVideoInputDevicesReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVideoInputDevicesReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVideoInputDevicesReq* internal_default_instance() {
    return reinterpret_cast<const GetVideoInputDevicesReq*>(
               &_GetVideoInputDevicesReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(GetVideoInputDevicesReq& a, GetVideoInputDevicesReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVideoInputDevicesReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVideoInputDevicesReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVideoInputDevicesReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVideoInputDevicesReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetVideoInputDevicesReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetVideoInputDevicesReq& from) {
    GetVideoInputDevicesReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVideoInputDevicesReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.GetVideoInputDevicesReq";
  }
  protected:
  explicit GetVideoInputDevicesReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.GetVideoInputDevicesReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class GetAudioInputDevicesResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.GetAudioInputDevicesResp) */ {
 public:
  inline GetAudioInputDevicesResp() : GetAudioInputDevicesResp(nullptr) {}
  ~GetAudioInputDevicesResp() override;
  explicit PROTOBUF_CONSTEXPR GetAudioInputDevicesResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAudioInputDevicesResp(const GetAudioInputDevicesResp& from);
  GetAudioInputDevicesResp(GetAudioInputDevicesResp&& from) noexcept
    : GetAudioInputDevicesResp() {
    *this = ::std::move(from);
  }

  inline GetAudioInputDevicesResp& operator=(const GetAudioInputDevicesResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAudioInputDevicesResp& operator=(GetAudioInputDevicesResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAudioInputDevicesResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAudioInputDevicesResp* internal_default_instance() {
    return reinterpret_cast<const GetAudioInputDevicesResp*>(
               &_GetAudioInputDevicesResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(GetAudioInputDevicesResp& a, GetAudioInputDevicesResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAudioInputDevicesResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAudioInputDevicesResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAudioInputDevicesResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAudioInputDevicesResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAudioInputDevicesResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAudioInputDevicesResp& from) {
    GetAudioInputDevicesResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAudioInputDevicesResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.GetAudioInputDevicesResp";
  }
  protected:
  explicit GetAudioInputDevicesResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.RtcAudioInputDeviceList Devices = 10;
  bool has_devices() const;
  private:
  bool _internal_has_devices() const;
  public:
  void clear_devices();
  const ::ServerData::RtcAudioInputDeviceList& devices() const;
  PROTOBUF_NODISCARD ::ServerData::RtcAudioInputDeviceList* release_devices();
  ::ServerData::RtcAudioInputDeviceList* mutable_devices();
  void set_allocated_devices(::ServerData::RtcAudioInputDeviceList* devices);
  private:
  const ::ServerData::RtcAudioInputDeviceList& _internal_devices() const;
  ::ServerData::RtcAudioInputDeviceList* _internal_mutable_devices();
  public:
  void unsafe_arena_set_allocated_devices(
      ::ServerData::RtcAudioInputDeviceList* devices);
  ::ServerData::RtcAudioInputDeviceList* unsafe_arena_release_devices();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.GetAudioInputDevicesResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::RtcAudioInputDeviceList* devices_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class GetAudioOutputDevicesResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.GetAudioOutputDevicesResp) */ {
 public:
  inline GetAudioOutputDevicesResp() : GetAudioOutputDevicesResp(nullptr) {}
  ~GetAudioOutputDevicesResp() override;
  explicit PROTOBUF_CONSTEXPR GetAudioOutputDevicesResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAudioOutputDevicesResp(const GetAudioOutputDevicesResp& from);
  GetAudioOutputDevicesResp(GetAudioOutputDevicesResp&& from) noexcept
    : GetAudioOutputDevicesResp() {
    *this = ::std::move(from);
  }

  inline GetAudioOutputDevicesResp& operator=(const GetAudioOutputDevicesResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAudioOutputDevicesResp& operator=(GetAudioOutputDevicesResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAudioOutputDevicesResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAudioOutputDevicesResp* internal_default_instance() {
    return reinterpret_cast<const GetAudioOutputDevicesResp*>(
               &_GetAudioOutputDevicesResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(GetAudioOutputDevicesResp& a, GetAudioOutputDevicesResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAudioOutputDevicesResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAudioOutputDevicesResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAudioOutputDevicesResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAudioOutputDevicesResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAudioOutputDevicesResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAudioOutputDevicesResp& from) {
    GetAudioOutputDevicesResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAudioOutputDevicesResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.GetAudioOutputDevicesResp";
  }
  protected:
  explicit GetAudioOutputDevicesResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.RtcAudioOutputDeviceList Devices = 10;
  bool has_devices() const;
  private:
  bool _internal_has_devices() const;
  public:
  void clear_devices();
  const ::ServerData::RtcAudioOutputDeviceList& devices() const;
  PROTOBUF_NODISCARD ::ServerData::RtcAudioOutputDeviceList* release_devices();
  ::ServerData::RtcAudioOutputDeviceList* mutable_devices();
  void set_allocated_devices(::ServerData::RtcAudioOutputDeviceList* devices);
  private:
  const ::ServerData::RtcAudioOutputDeviceList& _internal_devices() const;
  ::ServerData::RtcAudioOutputDeviceList* _internal_mutable_devices();
  public:
  void unsafe_arena_set_allocated_devices(
      ::ServerData::RtcAudioOutputDeviceList* devices);
  ::ServerData::RtcAudioOutputDeviceList* unsafe_arena_release_devices();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.GetAudioOutputDevicesResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::RtcAudioOutputDeviceList* devices_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class GetVideoInputDevicesResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.GetVideoInputDevicesResp) */ {
 public:
  inline GetVideoInputDevicesResp() : GetVideoInputDevicesResp(nullptr) {}
  ~GetVideoInputDevicesResp() override;
  explicit PROTOBUF_CONSTEXPR GetVideoInputDevicesResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVideoInputDevicesResp(const GetVideoInputDevicesResp& from);
  GetVideoInputDevicesResp(GetVideoInputDevicesResp&& from) noexcept
    : GetVideoInputDevicesResp() {
    *this = ::std::move(from);
  }

  inline GetVideoInputDevicesResp& operator=(const GetVideoInputDevicesResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVideoInputDevicesResp& operator=(GetVideoInputDevicesResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVideoInputDevicesResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVideoInputDevicesResp* internal_default_instance() {
    return reinterpret_cast<const GetVideoInputDevicesResp*>(
               &_GetVideoInputDevicesResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(GetVideoInputDevicesResp& a, GetVideoInputDevicesResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVideoInputDevicesResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVideoInputDevicesResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVideoInputDevicesResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVideoInputDevicesResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetVideoInputDevicesResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetVideoInputDevicesResp& from) {
    GetVideoInputDevicesResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVideoInputDevicesResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.GetVideoInputDevicesResp";
  }
  protected:
  explicit GetVideoInputDevicesResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.RtcVideoInputDeviceList Devices = 10;
  bool has_devices() const;
  private:
  bool _internal_has_devices() const;
  public:
  void clear_devices();
  const ::ServerData::RtcVideoInputDeviceList& devices() const;
  PROTOBUF_NODISCARD ::ServerData::RtcVideoInputDeviceList* release_devices();
  ::ServerData::RtcVideoInputDeviceList* mutable_devices();
  void set_allocated_devices(::ServerData::RtcVideoInputDeviceList* devices);
  private:
  const ::ServerData::RtcVideoInputDeviceList& _internal_devices() const;
  ::ServerData::RtcVideoInputDeviceList* _internal_mutable_devices();
  public:
  void unsafe_arena_set_allocated_devices(
      ::ServerData::RtcVideoInputDeviceList* devices);
  ::ServerData::RtcVideoInputDeviceList* unsafe_arena_release_devices();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.GetVideoInputDevicesResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::RtcVideoInputDeviceList* devices_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class SetAudioInputDeviceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.SetAudioInputDeviceReq) */ {
 public:
  inline SetAudioInputDeviceReq() : SetAudioInputDeviceReq(nullptr) {}
  ~SetAudioInputDeviceReq() override;
  explicit PROTOBUF_CONSTEXPR SetAudioInputDeviceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAudioInputDeviceReq(const SetAudioInputDeviceReq& from);
  SetAudioInputDeviceReq(SetAudioInputDeviceReq&& from) noexcept
    : SetAudioInputDeviceReq() {
    *this = ::std::move(from);
  }

  inline SetAudioInputDeviceReq& operator=(const SetAudioInputDeviceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAudioInputDeviceReq& operator=(SetAudioInputDeviceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAudioInputDeviceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAudioInputDeviceReq* internal_default_instance() {
    return reinterpret_cast<const SetAudioInputDeviceReq*>(
               &_SetAudioInputDeviceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(SetAudioInputDeviceReq& a, SetAudioInputDeviceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAudioInputDeviceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAudioInputDeviceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAudioInputDeviceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAudioInputDeviceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAudioInputDeviceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetAudioInputDeviceReq& from) {
    SetAudioInputDeviceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAudioInputDeviceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.SetAudioInputDeviceReq";
  }
  protected:
  explicit SetAudioInputDeviceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 2,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.RtcAudioInputDevice Device = 2;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::ServerData::RtcAudioInputDevice& device() const;
  PROTOBUF_NODISCARD ::ServerData::RtcAudioInputDevice* release_device();
  ::ServerData::RtcAudioInputDevice* mutable_device();
  void set_allocated_device(::ServerData::RtcAudioInputDevice* device);
  private:
  const ::ServerData::RtcAudioInputDevice& _internal_device() const;
  ::ServerData::RtcAudioInputDevice* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::ServerData::RtcAudioInputDevice* device);
  ::ServerData::RtcAudioInputDevice* unsafe_arena_release_device();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.SetAudioInputDeviceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::RtcAudioInputDevice* device_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class SetAudioOutputDeviceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.SetAudioOutputDeviceReq) */ {
 public:
  inline SetAudioOutputDeviceReq() : SetAudioOutputDeviceReq(nullptr) {}
  ~SetAudioOutputDeviceReq() override;
  explicit PROTOBUF_CONSTEXPR SetAudioOutputDeviceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAudioOutputDeviceReq(const SetAudioOutputDeviceReq& from);
  SetAudioOutputDeviceReq(SetAudioOutputDeviceReq&& from) noexcept
    : SetAudioOutputDeviceReq() {
    *this = ::std::move(from);
  }

  inline SetAudioOutputDeviceReq& operator=(const SetAudioOutputDeviceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAudioOutputDeviceReq& operator=(SetAudioOutputDeviceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAudioOutputDeviceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAudioOutputDeviceReq* internal_default_instance() {
    return reinterpret_cast<const SetAudioOutputDeviceReq*>(
               &_SetAudioOutputDeviceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(SetAudioOutputDeviceReq& a, SetAudioOutputDeviceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAudioOutputDeviceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAudioOutputDeviceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAudioOutputDeviceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAudioOutputDeviceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAudioOutputDeviceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetAudioOutputDeviceReq& from) {
    SetAudioOutputDeviceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAudioOutputDeviceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.SetAudioOutputDeviceReq";
  }
  protected:
  explicit SetAudioOutputDeviceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 2,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.RtcAudioOutputDevice Device = 2;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::ServerData::RtcAudioOutputDevice& device() const;
  PROTOBUF_NODISCARD ::ServerData::RtcAudioOutputDevice* release_device();
  ::ServerData::RtcAudioOutputDevice* mutable_device();
  void set_allocated_device(::ServerData::RtcAudioOutputDevice* device);
  private:
  const ::ServerData::RtcAudioOutputDevice& _internal_device() const;
  ::ServerData::RtcAudioOutputDevice* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::ServerData::RtcAudioOutputDevice* device);
  ::ServerData::RtcAudioOutputDevice* unsafe_arena_release_device();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.SetAudioOutputDeviceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::RtcAudioOutputDevice* device_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class SetVideoInputDeviceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.SetVideoInputDeviceReq) */ {
 public:
  inline SetVideoInputDeviceReq() : SetVideoInputDeviceReq(nullptr) {}
  ~SetVideoInputDeviceReq() override;
  explicit PROTOBUF_CONSTEXPR SetVideoInputDeviceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetVideoInputDeviceReq(const SetVideoInputDeviceReq& from);
  SetVideoInputDeviceReq(SetVideoInputDeviceReq&& from) noexcept
    : SetVideoInputDeviceReq() {
    *this = ::std::move(from);
  }

  inline SetVideoInputDeviceReq& operator=(const SetVideoInputDeviceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetVideoInputDeviceReq& operator=(SetVideoInputDeviceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetVideoInputDeviceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetVideoInputDeviceReq* internal_default_instance() {
    return reinterpret_cast<const SetVideoInputDeviceReq*>(
               &_SetVideoInputDeviceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(SetVideoInputDeviceReq& a, SetVideoInputDeviceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetVideoInputDeviceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetVideoInputDeviceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetVideoInputDeviceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetVideoInputDeviceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetVideoInputDeviceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetVideoInputDeviceReq& from) {
    SetVideoInputDeviceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetVideoInputDeviceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.SetVideoInputDeviceReq";
  }
  protected:
  explicit SetVideoInputDeviceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 2,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.RtcVideoInputDevice Device = 2;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::ServerData::RtcVideoInputDevice& device() const;
  PROTOBUF_NODISCARD ::ServerData::RtcVideoInputDevice* release_device();
  ::ServerData::RtcVideoInputDevice* mutable_device();
  void set_allocated_device(::ServerData::RtcVideoInputDevice* device);
  private:
  const ::ServerData::RtcVideoInputDevice& _internal_device() const;
  ::ServerData::RtcVideoInputDevice* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::ServerData::RtcVideoInputDevice* device);
  ::ServerData::RtcVideoInputDevice* unsafe_arena_release_device();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.SetVideoInputDeviceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::RtcVideoInputDevice* device_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PostCreateObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PostCreateObject) */ {
 public:
  inline PostCreateObject() : PostCreateObject(nullptr) {}
  ~PostCreateObject() override;
  explicit PROTOBUF_CONSTEXPR PostCreateObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostCreateObject(const PostCreateObject& from);
  PostCreateObject(PostCreateObject&& from) noexcept
    : PostCreateObject() {
    *this = ::std::move(from);
  }

  inline PostCreateObject& operator=(const PostCreateObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostCreateObject& operator=(PostCreateObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostCreateObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostCreateObject* internal_default_instance() {
    return reinterpret_cast<const PostCreateObject*>(
               &_PostCreateObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(PostCreateObject& a, PostCreateObject& b) {
    a.Swap(&b);
  }
  inline void Swap(PostCreateObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostCreateObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostCreateObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostCreateObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostCreateObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostCreateObject& from) {
    PostCreateObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostCreateObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PostCreateObject";
  }
  protected:
  explicit PostCreateObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewInstanceIdFieldNumber = 2,
    kUniqueObjectIdentFieldNumber = 10,
    kSpaceConnFieldNumber = 1,
    kReqIdFieldNumber = 5,
  };
  // string newInstanceId = 2;
  void clear_newinstanceid();
  const std::string& newinstanceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newinstanceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newinstanceid();
  PROTOBUF_NODISCARD std::string* release_newinstanceid();
  void set_allocated_newinstanceid(std::string* newinstanceid);
  private:
  const std::string& _internal_newinstanceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newinstanceid(const std::string& value);
  std::string* _internal_mutable_newinstanceid();
  public:

  // string uniqueObjectIdent = 10;
  void clear_uniqueobjectident();
  const std::string& uniqueobjectident() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uniqueobjectident(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uniqueobjectident();
  PROTOBUF_NODISCARD std::string* release_uniqueobjectident();
  void set_allocated_uniqueobjectident(std::string* uniqueobjectident);
  private:
  const std::string& _internal_uniqueobjectident() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uniqueobjectident(const std::string& value);
  std::string* _internal_mutable_uniqueobjectident();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // int32 reqId = 5;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.PostCreateObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newinstanceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uniqueobjectident_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PostRemoveObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PostRemoveObject) */ {
 public:
  inline PostRemoveObject() : PostRemoveObject(nullptr) {}
  ~PostRemoveObject() override;
  explicit PROTOBUF_CONSTEXPR PostRemoveObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostRemoveObject(const PostRemoveObject& from);
  PostRemoveObject(PostRemoveObject&& from) noexcept
    : PostRemoveObject() {
    *this = ::std::move(from);
  }

  inline PostRemoveObject& operator=(const PostRemoveObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostRemoveObject& operator=(PostRemoveObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostRemoveObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostRemoveObject* internal_default_instance() {
    return reinterpret_cast<const PostRemoveObject*>(
               &_PostRemoveObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(PostRemoveObject& a, PostRemoveObject& b) {
    a.Swap(&b);
  }
  inline void Swap(PostRemoveObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostRemoveObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostRemoveObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostRemoveObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostRemoveObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostRemoveObject& from) {
    PostRemoveObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostRemoveObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PostRemoveObject";
  }
  protected:
  explicit PostRemoveObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
    kReqIdFieldNumber = 5,
  };
  // string containerId = 2;
  void clear_containerid();
  const std::string& containerid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_containerid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_containerid();
  PROTOBUF_NODISCARD std::string* release_containerid();
  void set_allocated_containerid(std::string* containerid);
  private:
  const std::string& _internal_containerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_containerid(const std::string& value);
  std::string* _internal_mutable_containerid();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // int32 reqId = 5;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.PostRemoveObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr containerid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchFileByIdReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchFileByIdReq) */ {
 public:
  inline FetchFileByIdReq() : FetchFileByIdReq(nullptr) {}
  ~FetchFileByIdReq() override;
  explicit PROTOBUF_CONSTEXPR FetchFileByIdReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchFileByIdReq(const FetchFileByIdReq& from);
  FetchFileByIdReq(FetchFileByIdReq&& from) noexcept
    : FetchFileByIdReq() {
    *this = ::std::move(from);
  }

  inline FetchFileByIdReq& operator=(const FetchFileByIdReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchFileByIdReq& operator=(FetchFileByIdReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchFileByIdReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchFileByIdReq* internal_default_instance() {
    return reinterpret_cast<const FetchFileByIdReq*>(
               &_FetchFileByIdReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(FetchFileByIdReq& a, FetchFileByIdReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchFileByIdReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchFileByIdReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchFileByIdReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchFileByIdReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchFileByIdReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchFileByIdReq& from) {
    FetchFileByIdReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchFileByIdReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchFileByIdReq";
  }
  protected:
  explicit FetchFileByIdReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentIdFieldNumber = 1,
  };
  // string contentId = 1;
  void clear_contentid();
  const std::string& contentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentid();
  PROTOBUF_NODISCARD std::string* release_contentid();
  void set_allocated_contentid(std::string* contentid);
  private:
  const std::string& _internal_contentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentid(const std::string& value);
  std::string* _internal_mutable_contentid();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchFileByIdReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchFileByIdProgressResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchFileByIdProgressResp) */ {
 public:
  inline FetchFileByIdProgressResp() : FetchFileByIdProgressResp(nullptr) {}
  ~FetchFileByIdProgressResp() override;
  explicit PROTOBUF_CONSTEXPR FetchFileByIdProgressResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchFileByIdProgressResp(const FetchFileByIdProgressResp& from);
  FetchFileByIdProgressResp(FetchFileByIdProgressResp&& from) noexcept
    : FetchFileByIdProgressResp() {
    *this = ::std::move(from);
  }

  inline FetchFileByIdProgressResp& operator=(const FetchFileByIdProgressResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchFileByIdProgressResp& operator=(FetchFileByIdProgressResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchFileByIdProgressResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchFileByIdProgressResp* internal_default_instance() {
    return reinterpret_cast<const FetchFileByIdProgressResp*>(
               &_FetchFileByIdProgressResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(FetchFileByIdProgressResp& a, FetchFileByIdProgressResp& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchFileByIdProgressResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchFileByIdProgressResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchFileByIdProgressResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchFileByIdProgressResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchFileByIdProgressResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchFileByIdProgressResp& from) {
    FetchFileByIdProgressResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchFileByIdProgressResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchFileByIdProgressResp";
  }
  protected:
  explicit FetchFileByIdProgressResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentIdFieldNumber = 1,
    kProgressStepFieldNumber = 11,
    kProgressFieldNumber = 10,
  };
  // string contentId = 1;
  void clear_contentid();
  const std::string& contentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentid();
  PROTOBUF_NODISCARD std::string* release_contentid();
  void set_allocated_contentid(std::string* contentid);
  private:
  const std::string& _internal_contentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentid(const std::string& value);
  std::string* _internal_mutable_contentid();
  public:

  // string progressStep = 11;
  void clear_progressstep();
  const std::string& progressstep() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_progressstep(ArgT0&& arg0, ArgT... args);
  std::string* mutable_progressstep();
  PROTOBUF_NODISCARD std::string* release_progressstep();
  void set_allocated_progressstep(std::string* progressstep);
  private:
  const std::string& _internal_progressstep() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_progressstep(const std::string& value);
  std::string* _internal_mutable_progressstep();
  public:

  // float progress = 10;
  void clear_progress();
  float progress() const;
  void set_progress(float value);
  private:
  float _internal_progress() const;
  void _internal_set_progress(float value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchFileByIdProgressResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr progressstep_;
    float progress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchFileByIdCompletedResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchFileByIdCompletedResp) */ {
 public:
  inline FetchFileByIdCompletedResp() : FetchFileByIdCompletedResp(nullptr) {}
  ~FetchFileByIdCompletedResp() override;
  explicit PROTOBUF_CONSTEXPR FetchFileByIdCompletedResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchFileByIdCompletedResp(const FetchFileByIdCompletedResp& from);
  FetchFileByIdCompletedResp(FetchFileByIdCompletedResp&& from) noexcept
    : FetchFileByIdCompletedResp() {
    *this = ::std::move(from);
  }

  inline FetchFileByIdCompletedResp& operator=(const FetchFileByIdCompletedResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchFileByIdCompletedResp& operator=(FetchFileByIdCompletedResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchFileByIdCompletedResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchFileByIdCompletedResp* internal_default_instance() {
    return reinterpret_cast<const FetchFileByIdCompletedResp*>(
               &_FetchFileByIdCompletedResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(FetchFileByIdCompletedResp& a, FetchFileByIdCompletedResp& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchFileByIdCompletedResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchFileByIdCompletedResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchFileByIdCompletedResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchFileByIdCompletedResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchFileByIdCompletedResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchFileByIdCompletedResp& from) {
    FetchFileByIdCompletedResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchFileByIdCompletedResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchFileByIdCompletedResp";
  }
  protected:
  explicit FetchFileByIdCompletedResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentIdFieldNumber = 1,
    kFilePathFieldNumber = 10,
    kFinalFileNameWithExtensionFieldNumber = 11,
  };
  // string contentId = 1;
  void clear_contentid();
  const std::string& contentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentid();
  PROTOBUF_NODISCARD std::string* release_contentid();
  void set_allocated_contentid(std::string* contentid);
  private:
  const std::string& _internal_contentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentid(const std::string& value);
  std::string* _internal_mutable_contentid();
  public:

  // string filePath = 10;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // string finalFileNameWithExtension = 11;
  void clear_finalfilenamewithextension();
  const std::string& finalfilenamewithextension() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_finalfilenamewithextension(ArgT0&& arg0, ArgT... args);
  std::string* mutable_finalfilenamewithextension();
  PROTOBUF_NODISCARD std::string* release_finalfilenamewithextension();
  void set_allocated_finalfilenamewithextension(std::string* finalfilenamewithextension);
  private:
  const std::string& _internal_finalfilenamewithextension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_finalfilenamewithextension(const std::string& value);
  std::string* _internal_mutable_finalfilenamewithextension();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchFileByIdCompletedResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr finalfilenamewithextension_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchFileByIdFailureResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchFileByIdFailureResp) */ {
 public:
  inline FetchFileByIdFailureResp() : FetchFileByIdFailureResp(nullptr) {}
  ~FetchFileByIdFailureResp() override;
  explicit PROTOBUF_CONSTEXPR FetchFileByIdFailureResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchFileByIdFailureResp(const FetchFileByIdFailureResp& from);
  FetchFileByIdFailureResp(FetchFileByIdFailureResp&& from) noexcept
    : FetchFileByIdFailureResp() {
    *this = ::std::move(from);
  }

  inline FetchFileByIdFailureResp& operator=(const FetchFileByIdFailureResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchFileByIdFailureResp& operator=(FetchFileByIdFailureResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchFileByIdFailureResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchFileByIdFailureResp* internal_default_instance() {
    return reinterpret_cast<const FetchFileByIdFailureResp*>(
               &_FetchFileByIdFailureResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(FetchFileByIdFailureResp& a, FetchFileByIdFailureResp& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchFileByIdFailureResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchFileByIdFailureResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchFileByIdFailureResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchFileByIdFailureResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchFileByIdFailureResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchFileByIdFailureResp& from) {
    FetchFileByIdFailureResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchFileByIdFailureResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchFileByIdFailureResp";
  }
  protected:
  explicit FetchFileByIdFailureResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentIdFieldNumber = 1,
    kErrorMsgFieldNumber = 2,
  };
  // string contentId = 1;
  void clear_contentid();
  const std::string& contentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentid();
  PROTOBUF_NODISCARD std::string* release_contentid();
  void set_allocated_contentid(std::string* contentid);
  private:
  const std::string& _internal_contentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentid(const std::string& value);
  std::string* _internal_mutable_contentid();
  public:

  // string errorMsg = 2;
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchFileByIdFailureResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchAllUploadedContentReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchAllUploadedContentReq) */ {
 public:
  inline FetchAllUploadedContentReq() : FetchAllUploadedContentReq(nullptr) {}
  ~FetchAllUploadedContentReq() override;
  explicit PROTOBUF_CONSTEXPR FetchAllUploadedContentReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchAllUploadedContentReq(const FetchAllUploadedContentReq& from);
  FetchAllUploadedContentReq(FetchAllUploadedContentReq&& from) noexcept
    : FetchAllUploadedContentReq() {
    *this = ::std::move(from);
  }

  inline FetchAllUploadedContentReq& operator=(const FetchAllUploadedContentReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchAllUploadedContentReq& operator=(FetchAllUploadedContentReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchAllUploadedContentReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchAllUploadedContentReq* internal_default_instance() {
    return reinterpret_cast<const FetchAllUploadedContentReq*>(
               &_FetchAllUploadedContentReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(FetchAllUploadedContentReq& a, FetchAllUploadedContentReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchAllUploadedContentReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchAllUploadedContentReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchAllUploadedContentReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchAllUploadedContentReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchAllUploadedContentReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchAllUploadedContentReq& from) {
    FetchAllUploadedContentReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchAllUploadedContentReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchAllUploadedContentReq";
  }
  protected:
  explicit FetchAllUploadedContentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchAllUploadedContentReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UploadLocalFileResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UploadLocalFileResp) */ {
 public:
  inline UploadLocalFileResp() : UploadLocalFileResp(nullptr) {}
  ~UploadLocalFileResp() override;
  explicit PROTOBUF_CONSTEXPR UploadLocalFileResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadLocalFileResp(const UploadLocalFileResp& from);
  UploadLocalFileResp(UploadLocalFileResp&& from) noexcept
    : UploadLocalFileResp() {
    *this = ::std::move(from);
  }

  inline UploadLocalFileResp& operator=(const UploadLocalFileResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadLocalFileResp& operator=(UploadLocalFileResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadLocalFileResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadLocalFileResp* internal_default_instance() {
    return reinterpret_cast<const UploadLocalFileResp*>(
               &_UploadLocalFileResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(UploadLocalFileResp& a, UploadLocalFileResp& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadLocalFileResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadLocalFileResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadLocalFileResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadLocalFileResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadLocalFileResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadLocalFileResp& from) {
    UploadLocalFileResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadLocalFileResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UploadLocalFileResp";
  }
  protected:
  explicit UploadLocalFileResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUploadedContentFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.CavrnusRemoteContent uploadedContent = 10;
  bool has_uploadedcontent() const;
  private:
  bool _internal_has_uploadedcontent() const;
  public:
  void clear_uploadedcontent();
  const ::ServerData::CavrnusRemoteContent& uploadedcontent() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusRemoteContent* release_uploadedcontent();
  ::ServerData::CavrnusRemoteContent* mutable_uploadedcontent();
  void set_allocated_uploadedcontent(::ServerData::CavrnusRemoteContent* uploadedcontent);
  private:
  const ::ServerData::CavrnusRemoteContent& _internal_uploadedcontent() const;
  ::ServerData::CavrnusRemoteContent* _internal_mutable_uploadedcontent();
  public:
  void unsafe_arena_set_allocated_uploadedcontent(
      ::ServerData::CavrnusRemoteContent* uploadedcontent);
  ::ServerData::CavrnusRemoteContent* unsafe_arena_release_uploadedcontent();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.UploadLocalFileResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusRemoteContent* uploadedcontent_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UploadLocalFileProgressResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UploadLocalFileProgressResp) */ {
 public:
  inline UploadLocalFileProgressResp() : UploadLocalFileProgressResp(nullptr) {}
  ~UploadLocalFileProgressResp() override;
  explicit PROTOBUF_CONSTEXPR UploadLocalFileProgressResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadLocalFileProgressResp(const UploadLocalFileProgressResp& from);
  UploadLocalFileProgressResp(UploadLocalFileProgressResp&& from) noexcept
    : UploadLocalFileProgressResp() {
    *this = ::std::move(from);
  }

  inline UploadLocalFileProgressResp& operator=(const UploadLocalFileProgressResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadLocalFileProgressResp& operator=(UploadLocalFileProgressResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadLocalFileProgressResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadLocalFileProgressResp* internal_default_instance() {
    return reinterpret_cast<const UploadLocalFileProgressResp*>(
               &_UploadLocalFileProgressResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(UploadLocalFileProgressResp& a, UploadLocalFileProgressResp& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadLocalFileProgressResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadLocalFileProgressResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadLocalFileProgressResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadLocalFileProgressResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadLocalFileProgressResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadLocalFileProgressResp& from) {
    UploadLocalFileProgressResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadLocalFileProgressResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UploadLocalFileProgressResp";
  }
  protected:
  explicit UploadLocalFileProgressResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProgressStepFieldNumber = 11,
    kReqIdFieldNumber = 1,
    kProgressFieldNumber = 10,
  };
  // string progressStep = 11;
  void clear_progressstep();
  const std::string& progressstep() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_progressstep(ArgT0&& arg0, ArgT... args);
  std::string* mutable_progressstep();
  PROTOBUF_NODISCARD std::string* release_progressstep();
  void set_allocated_progressstep(std::string* progressstep);
  private:
  const std::string& _internal_progressstep() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_progressstep(const std::string& value);
  std::string* _internal_mutable_progressstep();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // float progress = 10;
  void clear_progress();
  float progress() const;
  void set_progress(float value);
  private:
  float _internal_progress() const;
  void _internal_set_progress(float value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.UploadLocalFileProgressResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr progressstep_;
    int32_t reqid_;
    float progress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UploadLocalFileReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UploadLocalFileReq) */ {
 public:
  inline UploadLocalFileReq() : UploadLocalFileReq(nullptr) {}
  ~UploadLocalFileReq() override;
  explicit PROTOBUF_CONSTEXPR UploadLocalFileReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadLocalFileReq(const UploadLocalFileReq& from);
  UploadLocalFileReq(UploadLocalFileReq&& from) noexcept
    : UploadLocalFileReq() {
    *this = ::std::move(from);
  }

  inline UploadLocalFileReq& operator=(const UploadLocalFileReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadLocalFileReq& operator=(UploadLocalFileReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadLocalFileReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadLocalFileReq* internal_default_instance() {
    return reinterpret_cast<const UploadLocalFileReq*>(
               &_UploadLocalFileReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(UploadLocalFileReq& a, UploadLocalFileReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadLocalFileReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadLocalFileReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadLocalFileReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadLocalFileReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadLocalFileReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadLocalFileReq& from) {
    UploadLocalFileReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadLocalFileReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UploadLocalFileReq";
  }
  protected:
  explicit UploadLocalFileReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagKeysFieldNumber = 11,
    kTagValuesFieldNumber = 12,
    kFilePathFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // repeated string tagKeys = 11;
  int tagkeys_size() const;
  private:
  int _internal_tagkeys_size() const;
  public:
  void clear_tagkeys();
  const std::string& tagkeys(int index) const;
  std::string* mutable_tagkeys(int index);
  void set_tagkeys(int index, const std::string& value);
  void set_tagkeys(int index, std::string&& value);
  void set_tagkeys(int index, const char* value);
  void set_tagkeys(int index, const char* value, size_t size);
  std::string* add_tagkeys();
  void add_tagkeys(const std::string& value);
  void add_tagkeys(std::string&& value);
  void add_tagkeys(const char* value);
  void add_tagkeys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tagkeys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tagkeys();
  private:
  const std::string& _internal_tagkeys(int index) const;
  std::string* _internal_add_tagkeys();
  public:

  // repeated string tagValues = 12;
  int tagvalues_size() const;
  private:
  int _internal_tagvalues_size() const;
  public:
  void clear_tagvalues();
  const std::string& tagvalues(int index) const;
  std::string* mutable_tagvalues(int index);
  void set_tagvalues(int index, const std::string& value);
  void set_tagvalues(int index, std::string&& value);
  void set_tagvalues(int index, const char* value);
  void set_tagvalues(int index, const char* value, size_t size);
  std::string* add_tagvalues();
  void add_tagvalues(const std::string& value);
  void add_tagvalues(std::string&& value);
  void add_tagvalues(const char* value);
  void add_tagvalues(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tagvalues() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tagvalues();
  private:
  const std::string& _internal_tagvalues(int index) const;
  std::string* _internal_add_tagvalues();
  public:

  // string filePath = 10;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.UploadLocalFileReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tagkeys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tagvalues_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ContentDestinationFolderReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ContentDestinationFolderReq) */ {
 public:
  inline ContentDestinationFolderReq() : ContentDestinationFolderReq(nullptr) {}
  ~ContentDestinationFolderReq() override;
  explicit PROTOBUF_CONSTEXPR ContentDestinationFolderReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContentDestinationFolderReq(const ContentDestinationFolderReq& from);
  ContentDestinationFolderReq(ContentDestinationFolderReq&& from) noexcept
    : ContentDestinationFolderReq() {
    *this = ::std::move(from);
  }

  inline ContentDestinationFolderReq& operator=(const ContentDestinationFolderReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentDestinationFolderReq& operator=(ContentDestinationFolderReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContentDestinationFolderReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContentDestinationFolderReq* internal_default_instance() {
    return reinterpret_cast<const ContentDestinationFolderReq*>(
               &_ContentDestinationFolderReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(ContentDestinationFolderReq& a, ContentDestinationFolderReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ContentDestinationFolderReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContentDestinationFolderReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContentDestinationFolderReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContentDestinationFolderReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContentDestinationFolderReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContentDestinationFolderReq& from) {
    ContentDestinationFolderReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContentDestinationFolderReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ContentDestinationFolderReq";
  }
  protected:
  explicit ContentDestinationFolderReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFolderNameFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // string folderName = 10;
  void clear_foldername();
  const std::string& foldername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_foldername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_foldername();
  PROTOBUF_NODISCARD std::string* release_foldername();
  void set_allocated_foldername(std::string* foldername);
  private:
  const std::string& _internal_foldername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_foldername(const std::string& value);
  std::string* _internal_mutable_foldername();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.ContentDestinationFolderReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr foldername_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ContentDestinationFolderResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ContentDestinationFolderResp) */ {
 public:
  inline ContentDestinationFolderResp() : ContentDestinationFolderResp(nullptr) {}
  ~ContentDestinationFolderResp() override;
  explicit PROTOBUF_CONSTEXPR ContentDestinationFolderResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContentDestinationFolderResp(const ContentDestinationFolderResp& from);
  ContentDestinationFolderResp(ContentDestinationFolderResp&& from) noexcept
    : ContentDestinationFolderResp() {
    *this = ::std::move(from);
  }

  inline ContentDestinationFolderResp& operator=(const ContentDestinationFolderResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentDestinationFolderResp& operator=(ContentDestinationFolderResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContentDestinationFolderResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContentDestinationFolderResp* internal_default_instance() {
    return reinterpret_cast<const ContentDestinationFolderResp*>(
               &_ContentDestinationFolderResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(ContentDestinationFolderResp& a, ContentDestinationFolderResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ContentDestinationFolderResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContentDestinationFolderResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContentDestinationFolderResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContentDestinationFolderResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContentDestinationFolderResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContentDestinationFolderResp& from) {
    ContentDestinationFolderResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContentDestinationFolderResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ContentDestinationFolderResp";
  }
  protected:
  explicit ContentDestinationFolderResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFullFolderNameFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // string fullFolderName = 10;
  void clear_fullfoldername();
  const std::string& fullfoldername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fullfoldername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fullfoldername();
  PROTOBUF_NODISCARD std::string* release_fullfoldername();
  void set_allocated_fullfoldername(std::string* fullfoldername);
  private:
  const std::string& _internal_fullfoldername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fullfoldername(const std::string& value);
  std::string* _internal_mutable_fullfoldername();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.ContentDestinationFolderResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fullfoldername_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchRemoteContentInfoReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchRemoteContentInfoReq) */ {
 public:
  inline FetchRemoteContentInfoReq() : FetchRemoteContentInfoReq(nullptr) {}
  ~FetchRemoteContentInfoReq() override;
  explicit PROTOBUF_CONSTEXPR FetchRemoteContentInfoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchRemoteContentInfoReq(const FetchRemoteContentInfoReq& from);
  FetchRemoteContentInfoReq(FetchRemoteContentInfoReq&& from) noexcept
    : FetchRemoteContentInfoReq() {
    *this = ::std::move(from);
  }

  inline FetchRemoteContentInfoReq& operator=(const FetchRemoteContentInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchRemoteContentInfoReq& operator=(FetchRemoteContentInfoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchRemoteContentInfoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchRemoteContentInfoReq* internal_default_instance() {
    return reinterpret_cast<const FetchRemoteContentInfoReq*>(
               &_FetchRemoteContentInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(FetchRemoteContentInfoReq& a, FetchRemoteContentInfoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchRemoteContentInfoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchRemoteContentInfoReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchRemoteContentInfoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchRemoteContentInfoReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchRemoteContentInfoReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchRemoteContentInfoReq& from) {
    FetchRemoteContentInfoReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchRemoteContentInfoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchRemoteContentInfoReq";
  }
  protected:
  explicit FetchRemoteContentInfoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentIdFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // string contentId = 10;
  void clear_contentid();
  const std::string& contentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentid();
  PROTOBUF_NODISCARD std::string* release_contentid();
  void set_allocated_contentid(std::string* contentid);
  private:
  const std::string& _internal_contentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentid(const std::string& value);
  std::string* _internal_mutable_contentid();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchRemoteContentInfoReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentid_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchRemoteContentInfoResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchRemoteContentInfoResp) */ {
 public:
  inline FetchRemoteContentInfoResp() : FetchRemoteContentInfoResp(nullptr) {}
  ~FetchRemoteContentInfoResp() override;
  explicit PROTOBUF_CONSTEXPR FetchRemoteContentInfoResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchRemoteContentInfoResp(const FetchRemoteContentInfoResp& from);
  FetchRemoteContentInfoResp(FetchRemoteContentInfoResp&& from) noexcept
    : FetchRemoteContentInfoResp() {
    *this = ::std::move(from);
  }

  inline FetchRemoteContentInfoResp& operator=(const FetchRemoteContentInfoResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchRemoteContentInfoResp& operator=(FetchRemoteContentInfoResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchRemoteContentInfoResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchRemoteContentInfoResp* internal_default_instance() {
    return reinterpret_cast<const FetchRemoteContentInfoResp*>(
               &_FetchRemoteContentInfoResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(FetchRemoteContentInfoResp& a, FetchRemoteContentInfoResp& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchRemoteContentInfoResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchRemoteContentInfoResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchRemoteContentInfoResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchRemoteContentInfoResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchRemoteContentInfoResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchRemoteContentInfoResp& from) {
    FetchRemoteContentInfoResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchRemoteContentInfoResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchRemoteContentInfoResp";
  }
  protected:
  explicit FetchRemoteContentInfoResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUploadedContentFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.CavrnusRemoteContent uploadedContent = 10;
  bool has_uploadedcontent() const;
  private:
  bool _internal_has_uploadedcontent() const;
  public:
  void clear_uploadedcontent();
  const ::ServerData::CavrnusRemoteContent& uploadedcontent() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusRemoteContent* release_uploadedcontent();
  ::ServerData::CavrnusRemoteContent* mutable_uploadedcontent();
  void set_allocated_uploadedcontent(::ServerData::CavrnusRemoteContent* uploadedcontent);
  private:
  const ::ServerData::CavrnusRemoteContent& _internal_uploadedcontent() const;
  ::ServerData::CavrnusRemoteContent* _internal_mutable_uploadedcontent();
  public:
  void unsafe_arena_set_allocated_uploadedcontent(
      ::ServerData::CavrnusRemoteContent* uploadedcontent);
  ::ServerData::CavrnusRemoteContent* unsafe_arena_release_uploadedcontent();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchRemoteContentInfoResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusRemoteContent* uploadedcontent_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class RemoteContentAdded final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RemoteContentAdded) */ {
 public:
  inline RemoteContentAdded() : RemoteContentAdded(nullptr) {}
  ~RemoteContentAdded() override;
  explicit PROTOBUF_CONSTEXPR RemoteContentAdded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoteContentAdded(const RemoteContentAdded& from);
  RemoteContentAdded(RemoteContentAdded&& from) noexcept
    : RemoteContentAdded() {
    *this = ::std::move(from);
  }

  inline RemoteContentAdded& operator=(const RemoteContentAdded& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteContentAdded& operator=(RemoteContentAdded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteContentAdded& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteContentAdded* internal_default_instance() {
    return reinterpret_cast<const RemoteContentAdded*>(
               &_RemoteContentAdded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(RemoteContentAdded& a, RemoteContentAdded& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteContentAdded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteContentAdded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteContentAdded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteContentAdded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoteContentAdded& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoteContentAdded& from) {
    RemoteContentAdded::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteContentAdded* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RemoteContentAdded";
  }
  protected:
  explicit RemoteContentAdded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteContentFieldNumber = 1,
  };
  // .ServerData.CavrnusRemoteContent remoteContent = 1;
  bool has_remotecontent() const;
  private:
  bool _internal_has_remotecontent() const;
  public:
  void clear_remotecontent();
  const ::ServerData::CavrnusRemoteContent& remotecontent() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusRemoteContent* release_remotecontent();
  ::ServerData::CavrnusRemoteContent* mutable_remotecontent();
  void set_allocated_remotecontent(::ServerData::CavrnusRemoteContent* remotecontent);
  private:
  const ::ServerData::CavrnusRemoteContent& _internal_remotecontent() const;
  ::ServerData::CavrnusRemoteContent* _internal_mutable_remotecontent();
  public:
  void unsafe_arena_set_allocated_remotecontent(
      ::ServerData::CavrnusRemoteContent* remotecontent);
  ::ServerData::CavrnusRemoteContent* unsafe_arena_release_remotecontent();

  // @@protoc_insertion_point(class_scope:ServerData.RemoteContentAdded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusRemoteContent* remotecontent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class RemoteContentRemoved final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RemoteContentRemoved) */ {
 public:
  inline RemoteContentRemoved() : RemoteContentRemoved(nullptr) {}
  ~RemoteContentRemoved() override;
  explicit PROTOBUF_CONSTEXPR RemoteContentRemoved(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoteContentRemoved(const RemoteContentRemoved& from);
  RemoteContentRemoved(RemoteContentRemoved&& from) noexcept
    : RemoteContentRemoved() {
    *this = ::std::move(from);
  }

  inline RemoteContentRemoved& operator=(const RemoteContentRemoved& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteContentRemoved& operator=(RemoteContentRemoved&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteContentRemoved& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteContentRemoved* internal_default_instance() {
    return reinterpret_cast<const RemoteContentRemoved*>(
               &_RemoteContentRemoved_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(RemoteContentRemoved& a, RemoteContentRemoved& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteContentRemoved* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteContentRemoved* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteContentRemoved* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteContentRemoved>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoteContentRemoved& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoteContentRemoved& from) {
    RemoteContentRemoved::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteContentRemoved* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RemoteContentRemoved";
  }
  protected:
  explicit RemoteContentRemoved(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.RemoteContentRemoved)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class FetchAllUploadedContentResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.FetchAllUploadedContentResp) */ {
 public:
  inline FetchAllUploadedContentResp() : FetchAllUploadedContentResp(nullptr) {}
  ~FetchAllUploadedContentResp() override;
  explicit PROTOBUF_CONSTEXPR FetchAllUploadedContentResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchAllUploadedContentResp(const FetchAllUploadedContentResp& from);
  FetchAllUploadedContentResp(FetchAllUploadedContentResp&& from) noexcept
    : FetchAllUploadedContentResp() {
    *this = ::std::move(from);
  }

  inline FetchAllUploadedContentResp& operator=(const FetchAllUploadedContentResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchAllUploadedContentResp& operator=(FetchAllUploadedContentResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchAllUploadedContentResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchAllUploadedContentResp* internal_default_instance() {
    return reinterpret_cast<const FetchAllUploadedContentResp*>(
               &_FetchAllUploadedContentResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(FetchAllUploadedContentResp& a, FetchAllUploadedContentResp& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchAllUploadedContentResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchAllUploadedContentResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchAllUploadedContentResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchAllUploadedContentResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchAllUploadedContentResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchAllUploadedContentResp& from) {
    FetchAllUploadedContentResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchAllUploadedContentResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.FetchAllUploadedContentResp";
  }
  protected:
  explicit FetchAllUploadedContentResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableContentFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // repeated .ServerData.CavrnusRemoteContent availableContent = 10;
  int availablecontent_size() const;
  private:
  int _internal_availablecontent_size() const;
  public:
  void clear_availablecontent();
  ::ServerData::CavrnusRemoteContent* mutable_availablecontent(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRemoteContent >*
      mutable_availablecontent();
  private:
  const ::ServerData::CavrnusRemoteContent& _internal_availablecontent(int index) const;
  ::ServerData::CavrnusRemoteContent* _internal_add_availablecontent();
  public:
  const ::ServerData::CavrnusRemoteContent& availablecontent(int index) const;
  ::ServerData::CavrnusRemoteContent* add_availablecontent();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRemoteContent >&
      availablecontent() const;

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.FetchAllUploadedContentResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRemoteContent > availablecontent_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PropMetadataStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PropMetadataStatus) */ {
 public:
  inline PropMetadataStatus() : PropMetadataStatus(nullptr) {}
  ~PropMetadataStatus() override;
  explicit PROTOBUF_CONSTEXPR PropMetadataStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropMetadataStatus(const PropMetadataStatus& from);
  PropMetadataStatus(PropMetadataStatus&& from) noexcept
    : PropMetadataStatus() {
    *this = ::std::move(from);
  }

  inline PropMetadataStatus& operator=(const PropMetadataStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropMetadataStatus& operator=(PropMetadataStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropMetadataStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PropMetadataStatus* internal_default_instance() {
    return reinterpret_cast<const PropMetadataStatus*>(
               &_PropMetadataStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(PropMetadataStatus& a, PropMetadataStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PropMetadataStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropMetadataStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropMetadataStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropMetadataStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PropMetadataStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PropMetadataStatus& from) {
    PropMetadataStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropMetadataStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PropMetadataStatus";
  }
  protected:
  explicit PropMetadataStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnFieldNumber = 1,
    kPropertyPathFieldNumber = 2,
    kIsReadonlyFieldNumber = 10,
  };
  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .Property.PropertyIdentifier propertyPath = 2;
  bool has_propertypath() const;
  private:
  bool _internal_has_propertypath() const;
  public:
  void clear_propertypath();
  const ::Property::PropertyIdentifier& propertypath() const;
  PROTOBUF_NODISCARD ::Property::PropertyIdentifier* release_propertypath();
  ::Property::PropertyIdentifier* mutable_propertypath();
  void set_allocated_propertypath(::Property::PropertyIdentifier* propertypath);
  private:
  const ::Property::PropertyIdentifier& _internal_propertypath() const;
  ::Property::PropertyIdentifier* _internal_mutable_propertypath();
  public:
  void unsafe_arena_set_allocated_propertypath(
      ::Property::PropertyIdentifier* propertypath);
  ::Property::PropertyIdentifier* unsafe_arena_release_propertypath();

  // bool isReadonly = 10;
  void clear_isreadonly();
  bool isreadonly() const;
  void set_isreadonly(bool value);
  private:
  bool _internal_isreadonly() const;
  void _internal_set_isreadonly(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.PropMetadataStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::Property::PropertyIdentifier* propertypath_;
    bool isreadonly_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PropertyValueStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PropertyValueStatus) */ {
 public:
  inline PropertyValueStatus() : PropertyValueStatus(nullptr) {}
  ~PropertyValueStatus() override;
  explicit PROTOBUF_CONSTEXPR PropertyValueStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropertyValueStatus(const PropertyValueStatus& from);
  PropertyValueStatus(PropertyValueStatus&& from) noexcept
    : PropertyValueStatus() {
    *this = ::std::move(from);
  }

  inline PropertyValueStatus& operator=(const PropertyValueStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropertyValueStatus& operator=(PropertyValueStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropertyValueStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PropertyValueStatus* internal_default_instance() {
    return reinterpret_cast<const PropertyValueStatus*>(
               &_PropertyValueStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(PropertyValueStatus& a, PropertyValueStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PropertyValueStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropertyValueStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropertyValueStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropertyValueStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PropertyValueStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PropertyValueStatus& from) {
    PropertyValueStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropertyValueStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PropertyValueStatus";
  }
  protected:
  explicit PropertyValueStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnFieldNumber = 1,
    kPropertyPathFieldNumber = 2,
    kPropertyValueFieldNumber = 10,
    kPriorityFieldNumber = 11,
  };
  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .Property.PropertyIdentifier propertyPath = 2;
  bool has_propertypath() const;
  private:
  bool _internal_has_propertypath() const;
  public:
  void clear_propertypath();
  const ::Property::PropertyIdentifier& propertypath() const;
  PROTOBUF_NODISCARD ::Property::PropertyIdentifier* release_propertypath();
  ::Property::PropertyIdentifier* mutable_propertypath();
  void set_allocated_propertypath(::Property::PropertyIdentifier* propertypath);
  private:
  const ::Property::PropertyIdentifier& _internal_propertypath() const;
  ::Property::PropertyIdentifier* _internal_mutable_propertypath();
  public:
  void unsafe_arena_set_allocated_propertypath(
      ::Property::PropertyIdentifier* propertypath);
  ::Property::PropertyIdentifier* unsafe_arena_release_propertypath();

  // .ServerData.PropertyValue PropertyValue = 10;
  bool has_propertyvalue() const;
  private:
  bool _internal_has_propertyvalue() const;
  public:
  void clear_propertyvalue();
  const ::ServerData::PropertyValue& propertyvalue() const;
  PROTOBUF_NODISCARD ::ServerData::PropertyValue* release_propertyvalue();
  ::ServerData::PropertyValue* mutable_propertyvalue();
  void set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue);
  private:
  const ::ServerData::PropertyValue& _internal_propertyvalue() const;
  ::ServerData::PropertyValue* _internal_mutable_propertyvalue();
  public:
  void unsafe_arena_set_allocated_propertyvalue(
      ::ServerData::PropertyValue* propertyvalue);
  ::ServerData::PropertyValue* unsafe_arena_release_propertyvalue();

  // int32 priority = 11;
  void clear_priority();
  int32_t priority() const;
  void set_priority(int32_t value);
  private:
  int32_t _internal_priority() const;
  void _internal_set_priority(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.PropertyValueStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::Property::PropertyIdentifier* propertypath_;
    ::ServerData::PropertyValue* propertyvalue_;
    int32_t priority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class LocalPropertyHandledResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.LocalPropertyHandledResp) */ {
 public:
  inline LocalPropertyHandledResp() : LocalPropertyHandledResp(nullptr) {}
  ~LocalPropertyHandledResp() override;
  explicit PROTOBUF_CONSTEXPR LocalPropertyHandledResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalPropertyHandledResp(const LocalPropertyHandledResp& from);
  LocalPropertyHandledResp(LocalPropertyHandledResp&& from) noexcept
    : LocalPropertyHandledResp() {
    *this = ::std::move(from);
  }

  inline LocalPropertyHandledResp& operator=(const LocalPropertyHandledResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalPropertyHandledResp& operator=(LocalPropertyHandledResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalPropertyHandledResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalPropertyHandledResp* internal_default_instance() {
    return reinterpret_cast<const LocalPropertyHandledResp*>(
               &_LocalPropertyHandledResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(LocalPropertyHandledResp& a, LocalPropertyHandledResp& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalPropertyHandledResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalPropertyHandledResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalPropertyHandledResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalPropertyHandledResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalPropertyHandledResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocalPropertyHandledResp& from) {
    LocalPropertyHandledResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalPropertyHandledResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.LocalPropertyHandledResp";
  }
  protected:
  explicit LocalPropertyHandledResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnFieldNumber = 1,
    kPropertyPathFieldNumber = 2,
    kLocalPropChangeIdFieldNumber = 10,
  };
  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .Property.PropertyIdentifier propertyPath = 2;
  bool has_propertypath() const;
  private:
  bool _internal_has_propertypath() const;
  public:
  void clear_propertypath();
  const ::Property::PropertyIdentifier& propertypath() const;
  PROTOBUF_NODISCARD ::Property::PropertyIdentifier* release_propertypath();
  ::Property::PropertyIdentifier* mutable_propertypath();
  void set_allocated_propertypath(::Property::PropertyIdentifier* propertypath);
  private:
  const ::Property::PropertyIdentifier& _internal_propertypath() const;
  ::Property::PropertyIdentifier* _internal_mutable_propertypath();
  public:
  void unsafe_arena_set_allocated_propertypath(
      ::Property::PropertyIdentifier* propertypath);
  ::Property::PropertyIdentifier* unsafe_arena_release_propertypath();

  // int32 localPropChangeId = 10;
  void clear_localpropchangeid();
  int32_t localpropchangeid() const;
  void set_localpropchangeid(int32_t value);
  private:
  int32_t _internal_localpropchangeid() const;
  void _internal_set_localpropchangeid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.LocalPropertyHandledResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::Property::PropertyIdentifier* propertypath_;
    int32_t localpropchangeid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UserAdded final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UserAdded) */ {
 public:
  inline UserAdded() : UserAdded(nullptr) {}
  ~UserAdded() override;
  explicit PROTOBUF_CONSTEXPR UserAdded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserAdded(const UserAdded& from);
  UserAdded(UserAdded&& from) noexcept
    : UserAdded() {
    *this = ::std::move(from);
  }

  inline UserAdded& operator=(const UserAdded& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserAdded& operator=(UserAdded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserAdded& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserAdded* internal_default_instance() {
    return reinterpret_cast<const UserAdded*>(
               &_UserAdded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(UserAdded& a, UserAdded& b) {
    a.Swap(&b);
  }
  inline void Swap(UserAdded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserAdded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserAdded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserAdded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserAdded& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserAdded& from) {
    UserAdded::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserAdded* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UserAdded";
  }
  protected:
  explicit UserAdded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnFieldNumber = 1,
    kUserFieldNumber = 2,
  };
  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.CavrnusUser user = 2;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::ServerData::CavrnusUser& user() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusUser* release_user();
  ::ServerData::CavrnusUser* mutable_user();
  void set_allocated_user(::ServerData::CavrnusUser* user);
  private:
  const ::ServerData::CavrnusUser& _internal_user() const;
  ::ServerData::CavrnusUser* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::ServerData::CavrnusUser* user);
  ::ServerData::CavrnusUser* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:ServerData.UserAdded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::CavrnusUser* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UserRemoved final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UserRemoved) */ {
 public:
  inline UserRemoved() : UserRemoved(nullptr) {}
  ~UserRemoved() override;
  explicit PROTOBUF_CONSTEXPR UserRemoved(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserRemoved(const UserRemoved& from);
  UserRemoved(UserRemoved&& from) noexcept
    : UserRemoved() {
    *this = ::std::move(from);
  }

  inline UserRemoved& operator=(const UserRemoved& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRemoved& operator=(UserRemoved&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRemoved& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRemoved* internal_default_instance() {
    return reinterpret_cast<const UserRemoved*>(
               &_UserRemoved_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(UserRemoved& a, UserRemoved& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRemoved* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRemoved* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRemoved* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserRemoved>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserRemoved& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserRemoved& from) {
    UserRemoved::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRemoved* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UserRemoved";
  }
  protected:
  explicit UserRemoved(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
  };
  // string userId = 2;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // @@protoc_insertion_point(class_scope:ServerData.UserRemoved)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UserVideoFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UserVideoFrame) */ {
 public:
  inline UserVideoFrame() : UserVideoFrame(nullptr) {}
  ~UserVideoFrame() override;
  explicit PROTOBUF_CONSTEXPR UserVideoFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserVideoFrame(const UserVideoFrame& from);
  UserVideoFrame(UserVideoFrame&& from) noexcept
    : UserVideoFrame() {
    *this = ::std::move(from);
  }

  inline UserVideoFrame& operator=(const UserVideoFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserVideoFrame& operator=(UserVideoFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserVideoFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserVideoFrame* internal_default_instance() {
    return reinterpret_cast<const UserVideoFrame*>(
               &_UserVideoFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(UserVideoFrame& a, UserVideoFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(UserVideoFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserVideoFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserVideoFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserVideoFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserVideoFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserVideoFrame& from) {
    UserVideoFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserVideoFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UserVideoFrame";
  }
  protected:
  explicit UserVideoFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 2,
    kStreamFieldNumber = 20,
    kSpaceConnFieldNumber = 1,
    kResXFieldNumber = 10,
    kResYFieldNumber = 11,
  };
  // string userId = 2;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bytes stream = 20;
  void clear_stream();
  const std::string& stream() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream();
  PROTOBUF_NODISCARD std::string* release_stream();
  void set_allocated_stream(std::string* stream);
  private:
  const std::string& _internal_stream() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream(const std::string& value);
  std::string* _internal_mutable_stream();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // int32 resX = 10;
  void clear_resx();
  int32_t resx() const;
  void set_resx(int32_t value);
  private:
  int32_t _internal_resx() const;
  void _internal_set_resx(int32_t value);
  public:

  // int32 resY = 11;
  void clear_resy();
  int32_t resy() const;
  void set_resy(int32_t value);
  private:
  int32_t _internal_resy() const;
  void _internal_set_resy(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.UserVideoFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    int32_t resx_;
    int32_t resy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ObjectAdded final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ObjectAdded) */ {
 public:
  inline ObjectAdded() : ObjectAdded(nullptr) {}
  ~ObjectAdded() override;
  explicit PROTOBUF_CONSTEXPR ObjectAdded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectAdded(const ObjectAdded& from);
  ObjectAdded(ObjectAdded&& from) noexcept
    : ObjectAdded() {
    *this = ::std::move(from);
  }

  inline ObjectAdded& operator=(const ObjectAdded& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectAdded& operator=(ObjectAdded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectAdded& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectAdded* internal_default_instance() {
    return reinterpret_cast<const ObjectAdded*>(
               &_ObjectAdded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(ObjectAdded& a, ObjectAdded& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectAdded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectAdded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectAdded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectAdded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectAdded& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectAdded& from) {
    ObjectAdded::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectAdded* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ObjectAdded";
  }
  protected:
  explicit ObjectAdded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesContainerFieldNumber = 3,
    kObjectCreatedFieldNumber = 4,
    kSpaceConnFieldNumber = 1,
    kCreatedTimeFieldNumber = 5,
  };
  // string propertiesContainer = 3;
  void clear_propertiescontainer();
  const std::string& propertiescontainer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_propertiescontainer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_propertiescontainer();
  PROTOBUF_NODISCARD std::string* release_propertiescontainer();
  void set_allocated_propertiescontainer(std::string* propertiescontainer);
  private:
  const std::string& _internal_propertiescontainer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_propertiescontainer(const std::string& value);
  std::string* _internal_mutable_propertiescontainer();
  public:

  // string objectCreated = 4;
  void clear_objectcreated();
  const std::string& objectcreated() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_objectcreated(ArgT0&& arg0, ArgT... args);
  std::string* mutable_objectcreated();
  PROTOBUF_NODISCARD std::string* release_objectcreated();
  void set_allocated_objectcreated(std::string* objectcreated);
  private:
  const std::string& _internal_objectcreated() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_objectcreated(const std::string& value);
  std::string* _internal_mutable_objectcreated();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .google.protobuf.Timestamp createdTime = 5;
  bool has_createdtime() const;
  private:
  bool _internal_has_createdtime() const;
  public:
  void clear_createdtime();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& createdtime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_createdtime();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_createdtime();
  void set_allocated_createdtime(::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_createdtime() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_createdtime();
  public:
  void unsafe_arena_set_allocated_createdtime(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_createdtime();

  // @@protoc_insertion_point(class_scope:ServerData.ObjectAdded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr propertiescontainer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr objectcreated_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ObjectRemoved final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ObjectRemoved) */ {
 public:
  inline ObjectRemoved() : ObjectRemoved(nullptr) {}
  ~ObjectRemoved() override;
  explicit PROTOBUF_CONSTEXPR ObjectRemoved(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectRemoved(const ObjectRemoved& from);
  ObjectRemoved(ObjectRemoved&& from) noexcept
    : ObjectRemoved() {
    *this = ::std::move(from);
  }

  inline ObjectRemoved& operator=(const ObjectRemoved& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectRemoved& operator=(ObjectRemoved&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectRemoved& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectRemoved* internal_default_instance() {
    return reinterpret_cast<const ObjectRemoved*>(
               &_ObjectRemoved_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(ObjectRemoved& a, ObjectRemoved& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectRemoved* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectRemoved* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectRemoved* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectRemoved>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectRemoved& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectRemoved& from) {
    ObjectRemoved::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectRemoved* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ObjectRemoved";
  }
  protected:
  explicit ObjectRemoved(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesContainerFieldNumber = 3,
    kSpaceConnFieldNumber = 1,
  };
  // string propertiesContainer = 3;
  void clear_propertiescontainer();
  const std::string& propertiescontainer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_propertiescontainer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_propertiescontainer();
  PROTOBUF_NODISCARD std::string* release_propertiescontainer();
  void set_allocated_propertiescontainer(std::string* propertiescontainer);
  private:
  const std::string& _internal_propertiescontainer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_propertiescontainer(const std::string& value);
  std::string* _internal_mutable_propertiescontainer();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // @@protoc_insertion_point(class_scope:ServerData.ObjectRemoved)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr propertiescontainer_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UpdateLocalUserMuted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UpdateLocalUserMuted) */ {
 public:
  inline UpdateLocalUserMuted() : UpdateLocalUserMuted(nullptr) {}
  ~UpdateLocalUserMuted() override;
  explicit PROTOBUF_CONSTEXPR UpdateLocalUserMuted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLocalUserMuted(const UpdateLocalUserMuted& from);
  UpdateLocalUserMuted(UpdateLocalUserMuted&& from) noexcept
    : UpdateLocalUserMuted() {
    *this = ::std::move(from);
  }

  inline UpdateLocalUserMuted& operator=(const UpdateLocalUserMuted& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocalUserMuted& operator=(UpdateLocalUserMuted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocalUserMuted& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLocalUserMuted* internal_default_instance() {
    return reinterpret_cast<const UpdateLocalUserMuted*>(
               &_UpdateLocalUserMuted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(UpdateLocalUserMuted& a, UpdateLocalUserMuted& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLocalUserMuted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocalUserMuted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocalUserMuted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLocalUserMuted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateLocalUserMuted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateLocalUserMuted& from) {
    UpdateLocalUserMuted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateLocalUserMuted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UpdateLocalUserMuted";
  }
  protected:
  explicit UpdateLocalUserMuted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnFieldNumber = 1,
    kMutedFieldNumber = 2,
  };
  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // bool muted = 2;
  void clear_muted();
  bool muted() const;
  void set_muted(bool value);
  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.UpdateLocalUserMuted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    bool muted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UpdateLocalUserCoPresence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UpdateLocalUserCoPresence) */ {
 public:
  inline UpdateLocalUserCoPresence() : UpdateLocalUserCoPresence(nullptr) {}
  ~UpdateLocalUserCoPresence() override;
  explicit PROTOBUF_CONSTEXPR UpdateLocalUserCoPresence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLocalUserCoPresence(const UpdateLocalUserCoPresence& from);
  UpdateLocalUserCoPresence(UpdateLocalUserCoPresence&& from) noexcept
    : UpdateLocalUserCoPresence() {
    *this = ::std::move(from);
  }

  inline UpdateLocalUserCoPresence& operator=(const UpdateLocalUserCoPresence& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocalUserCoPresence& operator=(UpdateLocalUserCoPresence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocalUserCoPresence& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLocalUserCoPresence* internal_default_instance() {
    return reinterpret_cast<const UpdateLocalUserCoPresence*>(
               &_UpdateLocalUserCoPresence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(UpdateLocalUserCoPresence& a, UpdateLocalUserCoPresence& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLocalUserCoPresence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocalUserCoPresence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocalUserCoPresence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLocalUserCoPresence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateLocalUserCoPresence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateLocalUserCoPresence& from) {
    UpdateLocalUserCoPresence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateLocalUserCoPresence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UpdateLocalUserCoPresence";
  }
  protected:
  explicit UpdateLocalUserCoPresence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnFieldNumber = 1,
    kLocalUserRootTransformFieldNumber = 10,
  };
  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.TransformPropertyValue localUserRootTransform = 10;
  bool has_localuserroottransform() const;
  private:
  bool _internal_has_localuserroottransform() const;
  public:
  void clear_localuserroottransform();
  const ::ServerData::TransformPropertyValue& localuserroottransform() const;
  PROTOBUF_NODISCARD ::ServerData::TransformPropertyValue* release_localuserroottransform();
  ::ServerData::TransformPropertyValue* mutable_localuserroottransform();
  void set_allocated_localuserroottransform(::ServerData::TransformPropertyValue* localuserroottransform);
  private:
  const ::ServerData::TransformPropertyValue& _internal_localuserroottransform() const;
  ::ServerData::TransformPropertyValue* _internal_mutable_localuserroottransform();
  public:
  void unsafe_arena_set_allocated_localuserroottransform(
      ::ServerData::TransformPropertyValue* localuserroottransform);
  ::ServerData::TransformPropertyValue* unsafe_arena_release_localuserroottransform();

  // @@protoc_insertion_point(class_scope:ServerData.UpdateLocalUserCoPresence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::TransformPropertyValue* localuserroottransform_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UpdateLocalUserStreamState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UpdateLocalUserStreamState) */ {
 public:
  inline UpdateLocalUserStreamState() : UpdateLocalUserStreamState(nullptr) {}
  ~UpdateLocalUserStreamState() override;
  explicit PROTOBUF_CONSTEXPR UpdateLocalUserStreamState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLocalUserStreamState(const UpdateLocalUserStreamState& from);
  UpdateLocalUserStreamState(UpdateLocalUserStreamState&& from) noexcept
    : UpdateLocalUserStreamState() {
    *this = ::std::move(from);
  }

  inline UpdateLocalUserStreamState& operator=(const UpdateLocalUserStreamState& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocalUserStreamState& operator=(UpdateLocalUserStreamState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocalUserStreamState& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLocalUserStreamState* internal_default_instance() {
    return reinterpret_cast<const UpdateLocalUserStreamState*>(
               &_UpdateLocalUserStreamState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(UpdateLocalUserStreamState& a, UpdateLocalUserStreamState& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLocalUserStreamState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocalUserStreamState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocalUserStreamState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLocalUserStreamState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateLocalUserStreamState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateLocalUserStreamState& from) {
    UpdateLocalUserStreamState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateLocalUserStreamState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UpdateLocalUserStreamState";
  }
  protected:
  explicit UpdateLocalUserStreamState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnFieldNumber = 1,
    kStreamingFieldNumber = 2,
  };
  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // bool streaming = 2;
  void clear_streaming();
  bool streaming() const;
  void set_streaming(bool value);
  private:
  bool _internal_streaming() const;
  void _internal_set_streaming(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.UpdateLocalUserStreamState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    bool streaming_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PermissionStatusReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PermissionStatusReq) */ {
 public:
  inline PermissionStatusReq() : PermissionStatusReq(nullptr) {}
  ~PermissionStatusReq() override;
  explicit PROTOBUF_CONSTEXPR PermissionStatusReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PermissionStatusReq(const PermissionStatusReq& from);
  PermissionStatusReq(PermissionStatusReq&& from) noexcept
    : PermissionStatusReq() {
    *this = ::std::move(from);
  }

  inline PermissionStatusReq& operator=(const PermissionStatusReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionStatusReq& operator=(PermissionStatusReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PermissionStatusReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PermissionStatusReq* internal_default_instance() {
    return reinterpret_cast<const PermissionStatusReq*>(
               &_PermissionStatusReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(PermissionStatusReq& a, PermissionStatusReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PermissionStatusReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionStatusReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PermissionStatusReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PermissionStatusReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PermissionStatusReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PermissionStatusReq& from) {
    PermissionStatusReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionStatusReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PermissionStatusReq";
  }
  protected:
  explicit PermissionStatusReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
  };
  // string permission = 2;
  void clear_permission();
  const std::string& permission() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission();
  PROTOBUF_NODISCARD std::string* release_permission();
  void set_allocated_permission(std::string* permission);
  private:
  const std::string& _internal_permission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission(const std::string& value);
  std::string* _internal_mutable_permission();
  public:

  // optional .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // @@protoc_insertion_point(class_scope:ServerData.PermissionStatusReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PermissionStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PermissionStatus) */ {
 public:
  inline PermissionStatus() : PermissionStatus(nullptr) {}
  ~PermissionStatus() override;
  explicit PROTOBUF_CONSTEXPR PermissionStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PermissionStatus(const PermissionStatus& from);
  PermissionStatus(PermissionStatus&& from) noexcept
    : PermissionStatus() {
    *this = ::std::move(from);
  }

  inline PermissionStatus& operator=(const PermissionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionStatus& operator=(PermissionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PermissionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PermissionStatus* internal_default_instance() {
    return reinterpret_cast<const PermissionStatus*>(
               &_PermissionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(PermissionStatus& a, PermissionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PermissionStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PermissionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PermissionStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PermissionStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PermissionStatus& from) {
    PermissionStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PermissionStatus";
  }
  protected:
  explicit PermissionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
    kValueFieldNumber = 3,
  };
  // string permission = 2;
  void clear_permission();
  const std::string& permission() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission();
  PROTOBUF_NODISCARD std::string* release_permission();
  void set_allocated_permission(std::string* permission);
  private:
  const std::string& _internal_permission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission(const std::string& value);
  std::string* _internal_mutable_permission();
  public:

  // optional .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // bool value = 3;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.PermissionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    bool value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AllJoinableSpacesReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AllJoinableSpacesReq) */ {
 public:
  inline AllJoinableSpacesReq() : AllJoinableSpacesReq(nullptr) {}
  ~AllJoinableSpacesReq() override;
  explicit PROTOBUF_CONSTEXPR AllJoinableSpacesReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllJoinableSpacesReq(const AllJoinableSpacesReq& from);
  AllJoinableSpacesReq(AllJoinableSpacesReq&& from) noexcept
    : AllJoinableSpacesReq() {
    *this = ::std::move(from);
  }

  inline AllJoinableSpacesReq& operator=(const AllJoinableSpacesReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllJoinableSpacesReq& operator=(AllJoinableSpacesReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllJoinableSpacesReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllJoinableSpacesReq* internal_default_instance() {
    return reinterpret_cast<const AllJoinableSpacesReq*>(
               &_AllJoinableSpacesReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(AllJoinableSpacesReq& a, AllJoinableSpacesReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AllJoinableSpacesReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllJoinableSpacesReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllJoinableSpacesReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllJoinableSpacesReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllJoinableSpacesReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllJoinableSpacesReq& from) {
    AllJoinableSpacesReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllJoinableSpacesReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AllJoinableSpacesReq";
  }
  protected:
  explicit AllJoinableSpacesReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AllJoinableSpacesReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class AllJoinableSpacesResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.AllJoinableSpacesResp) */ {
 public:
  inline AllJoinableSpacesResp() : AllJoinableSpacesResp(nullptr) {}
  ~AllJoinableSpacesResp() override;
  explicit PROTOBUF_CONSTEXPR AllJoinableSpacesResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllJoinableSpacesResp(const AllJoinableSpacesResp& from);
  AllJoinableSpacesResp(AllJoinableSpacesResp&& from) noexcept
    : AllJoinableSpacesResp() {
    *this = ::std::move(from);
  }

  inline AllJoinableSpacesResp& operator=(const AllJoinableSpacesResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllJoinableSpacesResp& operator=(AllJoinableSpacesResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllJoinableSpacesResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllJoinableSpacesResp* internal_default_instance() {
    return reinterpret_cast<const AllJoinableSpacesResp*>(
               &_AllJoinableSpacesResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(AllJoinableSpacesResp& a, AllJoinableSpacesResp& b) {
    a.Swap(&b);
  }
  inline void Swap(AllJoinableSpacesResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllJoinableSpacesResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllJoinableSpacesResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllJoinableSpacesResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllJoinableSpacesResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllJoinableSpacesResp& from) {
    AllJoinableSpacesResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllJoinableSpacesResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.AllJoinableSpacesResp";
  }
  protected:
  explicit AllJoinableSpacesResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableSpacesFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // repeated .ServerData.SpaceInfo availableSpaces = 10;
  int availablespaces_size() const;
  private:
  int _internal_availablespaces_size() const;
  public:
  void clear_availablespaces();
  ::ServerData::SpaceInfo* mutable_availablespaces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::SpaceInfo >*
      mutable_availablespaces();
  private:
  const ::ServerData::SpaceInfo& _internal_availablespaces(int index) const;
  ::ServerData::SpaceInfo* _internal_add_availablespaces();
  public:
  const ::ServerData::SpaceInfo& availablespaces(int index) const;
  ::ServerData::SpaceInfo* add_availablespaces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::SpaceInfo >&
      availablespaces() const;

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.AllJoinableSpacesResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::SpaceInfo > availablespaces_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class GetSpaceInfoReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.GetSpaceInfoReq) */ {
 public:
  inline GetSpaceInfoReq() : GetSpaceInfoReq(nullptr) {}
  ~GetSpaceInfoReq() override;
  explicit PROTOBUF_CONSTEXPR GetSpaceInfoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSpaceInfoReq(const GetSpaceInfoReq& from);
  GetSpaceInfoReq(GetSpaceInfoReq&& from) noexcept
    : GetSpaceInfoReq() {
    *this = ::std::move(from);
  }

  inline GetSpaceInfoReq& operator=(const GetSpaceInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSpaceInfoReq& operator=(GetSpaceInfoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSpaceInfoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSpaceInfoReq* internal_default_instance() {
    return reinterpret_cast<const GetSpaceInfoReq*>(
               &_GetSpaceInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(GetSpaceInfoReq& a, GetSpaceInfoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSpaceInfoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSpaceInfoReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSpaceInfoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSpaceInfoReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSpaceInfoReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSpaceInfoReq& from) {
    GetSpaceInfoReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSpaceInfoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.GetSpaceInfoReq";
  }
  protected:
  explicit GetSpaceInfoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceIdFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // string spaceId = 10;
  void clear_spaceid();
  const std::string& spaceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spaceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spaceid();
  PROTOBUF_NODISCARD std::string* release_spaceid();
  void set_allocated_spaceid(std::string* spaceid);
  private:
  const std::string& _internal_spaceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spaceid(const std::string& value);
  std::string* _internal_mutable_spaceid();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.GetSpaceInfoReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spaceid_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class GetSpaceInfoResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.GetSpaceInfoResp) */ {
 public:
  inline GetSpaceInfoResp() : GetSpaceInfoResp(nullptr) {}
  ~GetSpaceInfoResp() override;
  explicit PROTOBUF_CONSTEXPR GetSpaceInfoResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSpaceInfoResp(const GetSpaceInfoResp& from);
  GetSpaceInfoResp(GetSpaceInfoResp&& from) noexcept
    : GetSpaceInfoResp() {
    *this = ::std::move(from);
  }

  inline GetSpaceInfoResp& operator=(const GetSpaceInfoResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSpaceInfoResp& operator=(GetSpaceInfoResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSpaceInfoResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSpaceInfoResp* internal_default_instance() {
    return reinterpret_cast<const GetSpaceInfoResp*>(
               &_GetSpaceInfoResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(GetSpaceInfoResp& a, GetSpaceInfoResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSpaceInfoResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSpaceInfoResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSpaceInfoResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSpaceInfoResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSpaceInfoResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSpaceInfoResp& from) {
    GetSpaceInfoResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSpaceInfoResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.GetSpaceInfoResp";
  }
  protected:
  explicit GetSpaceInfoResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // .ServerData.SpaceInfo info = 10;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::ServerData::SpaceInfo& info() const;
  PROTOBUF_NODISCARD ::ServerData::SpaceInfo* release_info();
  ::ServerData::SpaceInfo* mutable_info();
  void set_allocated_info(::ServerData::SpaceInfo* info);
  private:
  const ::ServerData::SpaceInfo& _internal_info() const;
  ::ServerData::SpaceInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::ServerData::SpaceInfo* info);
  ::ServerData::SpaceInfo* unsafe_arena_release_info();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.GetSpaceInfoResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerData::SpaceInfo* info_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class DeleteSpaceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.DeleteSpaceReq) */ {
 public:
  inline DeleteSpaceReq() : DeleteSpaceReq(nullptr) {}
  ~DeleteSpaceReq() override;
  explicit PROTOBUF_CONSTEXPR DeleteSpaceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSpaceReq(const DeleteSpaceReq& from);
  DeleteSpaceReq(DeleteSpaceReq&& from) noexcept
    : DeleteSpaceReq() {
    *this = ::std::move(from);
  }

  inline DeleteSpaceReq& operator=(const DeleteSpaceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSpaceReq& operator=(DeleteSpaceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSpaceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSpaceReq* internal_default_instance() {
    return reinterpret_cast<const DeleteSpaceReq*>(
               &_DeleteSpaceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(DeleteSpaceReq& a, DeleteSpaceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSpaceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSpaceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSpaceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSpaceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteSpaceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteSpaceReq& from) {
    DeleteSpaceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSpaceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.DeleteSpaceReq";
  }
  protected:
  explicit DeleteSpaceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceIdFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // string spaceId = 10;
  void clear_spaceid();
  const std::string& spaceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spaceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spaceid();
  PROTOBUF_NODISCARD std::string* release_spaceid();
  void set_allocated_spaceid(std::string* spaceid);
  private:
  const std::string& _internal_spaceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spaceid(const std::string& value);
  std::string* _internal_mutable_spaceid();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.DeleteSpaceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spaceid_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class GenericResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.GenericResp) */ {
 public:
  inline GenericResp() : GenericResp(nullptr) {}
  ~GenericResp() override;
  explicit PROTOBUF_CONSTEXPR GenericResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericResp(const GenericResp& from);
  GenericResp(GenericResp&& from) noexcept
    : GenericResp() {
    *this = ::std::move(from);
  }

  inline GenericResp& operator=(const GenericResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericResp& operator=(GenericResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericResp* internal_default_instance() {
    return reinterpret_cast<const GenericResp*>(
               &_GenericResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(GenericResp& a, GenericResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenericResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenericResp& from) {
    GenericResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.GenericResp";
  }
  protected:
  explicit GenericResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 11,
    kReqIdFieldNumber = 1,
    kSuccessFieldNumber = 10,
  };
  // string error = 11;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // bool success = 10;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.GenericResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    int32_t reqid_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class RenameSpaceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RenameSpaceReq) */ {
 public:
  inline RenameSpaceReq() : RenameSpaceReq(nullptr) {}
  ~RenameSpaceReq() override;
  explicit PROTOBUF_CONSTEXPR RenameSpaceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameSpaceReq(const RenameSpaceReq& from);
  RenameSpaceReq(RenameSpaceReq&& from) noexcept
    : RenameSpaceReq() {
    *this = ::std::move(from);
  }

  inline RenameSpaceReq& operator=(const RenameSpaceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameSpaceReq& operator=(RenameSpaceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameSpaceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameSpaceReq* internal_default_instance() {
    return reinterpret_cast<const RenameSpaceReq*>(
               &_RenameSpaceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(RenameSpaceReq& a, RenameSpaceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameSpaceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameSpaceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameSpaceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameSpaceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameSpaceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RenameSpaceReq& from) {
    RenameSpaceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameSpaceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RenameSpaceReq";
  }
  protected:
  explicit RenameSpaceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceIdFieldNumber = 10,
    kNewNameFieldNumber = 11,
    kReqIdFieldNumber = 1,
  };
  // string spaceId = 10;
  void clear_spaceid();
  const std::string& spaceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spaceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spaceid();
  PROTOBUF_NODISCARD std::string* release_spaceid();
  void set_allocated_spaceid(std::string* spaceid);
  private:
  const std::string& _internal_spaceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spaceid(const std::string& value);
  std::string* _internal_mutable_spaceid();
  public:

  // string newName = 11;
  void clear_newname();
  const std::string& newname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newname();
  PROTOBUF_NODISCARD std::string* release_newname();
  void set_allocated_newname(std::string* newname);
  private:
  const std::string& _internal_newname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newname(const std::string& value);
  std::string* _internal_mutable_newname();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.RenameSpaceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spaceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newname_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class UpdateThumbnailForSpaceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.UpdateThumbnailForSpaceReq) */ {
 public:
  inline UpdateThumbnailForSpaceReq() : UpdateThumbnailForSpaceReq(nullptr) {}
  ~UpdateThumbnailForSpaceReq() override;
  explicit PROTOBUF_CONSTEXPR UpdateThumbnailForSpaceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateThumbnailForSpaceReq(const UpdateThumbnailForSpaceReq& from);
  UpdateThumbnailForSpaceReq(UpdateThumbnailForSpaceReq&& from) noexcept
    : UpdateThumbnailForSpaceReq() {
    *this = ::std::move(from);
  }

  inline UpdateThumbnailForSpaceReq& operator=(const UpdateThumbnailForSpaceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateThumbnailForSpaceReq& operator=(UpdateThumbnailForSpaceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateThumbnailForSpaceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateThumbnailForSpaceReq* internal_default_instance() {
    return reinterpret_cast<const UpdateThumbnailForSpaceReq*>(
               &_UpdateThumbnailForSpaceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(UpdateThumbnailForSpaceReq& a, UpdateThumbnailForSpaceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateThumbnailForSpaceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateThumbnailForSpaceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateThumbnailForSpaceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateThumbnailForSpaceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateThumbnailForSpaceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateThumbnailForSpaceReq& from) {
    UpdateThumbnailForSpaceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateThumbnailForSpaceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.UpdateThumbnailForSpaceReq";
  }
  protected:
  explicit UpdateThumbnailForSpaceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceIdFieldNumber = 10,
    kThumbnailfilenameFieldNumber = 11,
    kReqIdFieldNumber = 1,
  };
  // string spaceId = 10;
  void clear_spaceid();
  const std::string& spaceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spaceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spaceid();
  PROTOBUF_NODISCARD std::string* release_spaceid();
  void set_allocated_spaceid(std::string* spaceid);
  private:
  const std::string& _internal_spaceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spaceid(const std::string& value);
  std::string* _internal_mutable_spaceid();
  public:

  // string thumbnailfilename = 11;
  void clear_thumbnailfilename();
  const std::string& thumbnailfilename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnailfilename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnailfilename();
  PROTOBUF_NODISCARD std::string* release_thumbnailfilename();
  void set_allocated_thumbnailfilename(std::string* thumbnailfilename);
  private:
  const std::string& _internal_thumbnailfilename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnailfilename(const std::string& value);
  std::string* _internal_mutable_thumbnailfilename();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.UpdateThumbnailForSpaceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spaceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnailfilename_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ChatAdded final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ChatAdded) */ {
 public:
  inline ChatAdded() : ChatAdded(nullptr) {}
  ~ChatAdded() override;
  explicit PROTOBUF_CONSTEXPR ChatAdded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatAdded(const ChatAdded& from);
  ChatAdded(ChatAdded&& from) noexcept
    : ChatAdded() {
    *this = ::std::move(from);
  }

  inline ChatAdded& operator=(const ChatAdded& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatAdded& operator=(ChatAdded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatAdded& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatAdded* internal_default_instance() {
    return reinterpret_cast<const ChatAdded*>(
               &_ChatAdded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(ChatAdded& a, ChatAdded& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatAdded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatAdded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatAdded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatAdded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatAdded& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatAdded& from) {
    ChatAdded::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatAdded* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ChatAdded";
  }
  protected:
  explicit ChatAdded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatPropertyIdFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
    kChatDataFieldNumber = 10,
  };
  // string ChatPropertyId = 2;
  void clear_chatpropertyid();
  const std::string& chatpropertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chatpropertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chatpropertyid();
  PROTOBUF_NODISCARD std::string* release_chatpropertyid();
  void set_allocated_chatpropertyid(std::string* chatpropertyid);
  private:
  const std::string& _internal_chatpropertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chatpropertyid(const std::string& value);
  std::string* _internal_mutable_chatpropertyid();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.ChatBase ChatData = 10;
  bool has_chatdata() const;
  private:
  bool _internal_has_chatdata() const;
  public:
  void clear_chatdata();
  const ::ServerData::ChatBase& chatdata() const;
  PROTOBUF_NODISCARD ::ServerData::ChatBase* release_chatdata();
  ::ServerData::ChatBase* mutable_chatdata();
  void set_allocated_chatdata(::ServerData::ChatBase* chatdata);
  private:
  const ::ServerData::ChatBase& _internal_chatdata() const;
  ::ServerData::ChatBase* _internal_mutable_chatdata();
  public:
  void unsafe_arena_set_allocated_chatdata(
      ::ServerData::ChatBase* chatdata);
  ::ServerData::ChatBase* unsafe_arena_release_chatdata();

  // @@protoc_insertion_point(class_scope:ServerData.ChatAdded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chatpropertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::ChatBase* chatdata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ChatUpdated final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ChatUpdated) */ {
 public:
  inline ChatUpdated() : ChatUpdated(nullptr) {}
  ~ChatUpdated() override;
  explicit PROTOBUF_CONSTEXPR ChatUpdated(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatUpdated(const ChatUpdated& from);
  ChatUpdated(ChatUpdated&& from) noexcept
    : ChatUpdated() {
    *this = ::std::move(from);
  }

  inline ChatUpdated& operator=(const ChatUpdated& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatUpdated& operator=(ChatUpdated&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatUpdated& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatUpdated* internal_default_instance() {
    return reinterpret_cast<const ChatUpdated*>(
               &_ChatUpdated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(ChatUpdated& a, ChatUpdated& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatUpdated* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatUpdated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatUpdated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatUpdated>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatUpdated& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatUpdated& from) {
    ChatUpdated::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatUpdated* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ChatUpdated";
  }
  protected:
  explicit ChatUpdated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatPropertyIdFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
    kChatDataFieldNumber = 10,
  };
  // string ChatPropertyId = 2;
  void clear_chatpropertyid();
  const std::string& chatpropertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chatpropertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chatpropertyid();
  PROTOBUF_NODISCARD std::string* release_chatpropertyid();
  void set_allocated_chatpropertyid(std::string* chatpropertyid);
  private:
  const std::string& _internal_chatpropertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chatpropertyid(const std::string& value);
  std::string* _internal_mutable_chatpropertyid();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // .ServerData.ChatBase ChatData = 10;
  bool has_chatdata() const;
  private:
  bool _internal_has_chatdata() const;
  public:
  void clear_chatdata();
  const ::ServerData::ChatBase& chatdata() const;
  PROTOBUF_NODISCARD ::ServerData::ChatBase* release_chatdata();
  ::ServerData::ChatBase* mutable_chatdata();
  void set_allocated_chatdata(::ServerData::ChatBase* chatdata);
  private:
  const ::ServerData::ChatBase& _internal_chatdata() const;
  ::ServerData::ChatBase* _internal_mutable_chatdata();
  public:
  void unsafe_arena_set_allocated_chatdata(
      ::ServerData::ChatBase* chatdata);
  ::ServerData::ChatBase* unsafe_arena_release_chatdata();

  // @@protoc_insertion_point(class_scope:ServerData.ChatUpdated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chatpropertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    ::ServerData::ChatBase* chatdata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ChatRemoved final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ChatRemoved) */ {
 public:
  inline ChatRemoved() : ChatRemoved(nullptr) {}
  ~ChatRemoved() override;
  explicit PROTOBUF_CONSTEXPR ChatRemoved(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatRemoved(const ChatRemoved& from);
  ChatRemoved(ChatRemoved&& from) noexcept
    : ChatRemoved() {
    *this = ::std::move(from);
  }

  inline ChatRemoved& operator=(const ChatRemoved& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatRemoved& operator=(ChatRemoved&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatRemoved& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatRemoved* internal_default_instance() {
    return reinterpret_cast<const ChatRemoved*>(
               &_ChatRemoved_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(ChatRemoved& a, ChatRemoved& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatRemoved* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatRemoved* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatRemoved* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatRemoved>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatRemoved& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatRemoved& from) {
    ChatRemoved::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatRemoved* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ChatRemoved";
  }
  protected:
  explicit ChatRemoved(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatPropertyIdFieldNumber = 2,
    kSpaceConnFieldNumber = 1,
  };
  // string ChatPropertyId = 2;
  void clear_chatpropertyid();
  const std::string& chatpropertyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chatpropertyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chatpropertyid();
  PROTOBUF_NODISCARD std::string* release_chatpropertyid();
  void set_allocated_chatpropertyid(std::string* chatpropertyid);
  private:
  const std::string& _internal_chatpropertyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chatpropertyid(const std::string& value);
  std::string* _internal_mutable_chatpropertyid();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // @@protoc_insertion_point(class_scope:ServerData.ChatRemoved)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chatpropertyid_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class PostChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.PostChat) */ {
 public:
  inline PostChat() : PostChat(nullptr) {}
  ~PostChat() override;
  explicit PROTOBUF_CONSTEXPR PostChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostChat(const PostChat& from);
  PostChat(PostChat&& from) noexcept
    : PostChat() {
    *this = ::std::move(from);
  }

  inline PostChat& operator=(const PostChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostChat& operator=(PostChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostChat* internal_default_instance() {
    return reinterpret_cast<const PostChat*>(
               &_PostChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(PostChat& a, PostChat& b) {
    a.Swap(&b);
  }
  inline void Swap(PostChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostChat& from) {
    PostChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.PostChat";
  }
  protected:
  explicit PostChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatTextFieldNumber = 10,
    kSpaceConnFieldNumber = 1,
  };
  // string ChatText = 10;
  void clear_chattext();
  const std::string& chattext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chattext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chattext();
  PROTOBUF_NODISCARD std::string* release_chattext();
  void set_allocated_chattext(std::string* chattext);
  private:
  const std::string& _internal_chattext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chattext(const std::string& value);
  std::string* _internal_mutable_chattext();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 1;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // @@protoc_insertion_point(class_scope:ServerData.PostChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chattext_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class ChatBase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.ChatBase) */ {
 public:
  inline ChatBase() : ChatBase(nullptr) {}
  ~ChatBase() override;
  explicit PROTOBUF_CONSTEXPR ChatBase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatBase(const ChatBase& from);
  ChatBase(ChatBase&& from) noexcept
    : ChatBase() {
    *this = ::std::move(from);
  }

  inline ChatBase& operator=(const ChatBase& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatBase& operator=(ChatBase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatBase& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatBase* internal_default_instance() {
    return reinterpret_cast<const ChatBase*>(
               &_ChatBase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(ChatBase& a, ChatBase& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatBase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatBase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatBase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatBase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatBase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatBase& from) {
    ChatBase::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatBase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.ChatBase";
  }
  protected:
  explicit ChatBase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChatBase_ChatMessageSourceTypeEnum ChatMessageSourceTypeEnum;
  static constexpr ChatMessageSourceTypeEnum Chat =
    ChatBase_ChatMessageSourceTypeEnum_Chat;
  static constexpr ChatMessageSourceTypeEnum Transcription =
    ChatBase_ChatMessageSourceTypeEnum_Transcription;
  static inline bool ChatMessageSourceTypeEnum_IsValid(int value) {
    return ChatBase_ChatMessageSourceTypeEnum_IsValid(value);
  }
  static constexpr ChatMessageSourceTypeEnum ChatMessageSourceTypeEnum_MIN =
    ChatBase_ChatMessageSourceTypeEnum_ChatMessageSourceTypeEnum_MIN;
  static constexpr ChatMessageSourceTypeEnum ChatMessageSourceTypeEnum_MAX =
    ChatBase_ChatMessageSourceTypeEnum_ChatMessageSourceTypeEnum_MAX;
  static constexpr int ChatMessageSourceTypeEnum_ARRAYSIZE =
    ChatBase_ChatMessageSourceTypeEnum_ChatMessageSourceTypeEnum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ChatMessageSourceTypeEnum_descriptor() {
    return ChatBase_ChatMessageSourceTypeEnum_descriptor();
  }
  template<typename T>
  static inline const std::string& ChatMessageSourceTypeEnum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ChatMessageSourceTypeEnum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ChatMessageSourceTypeEnum_Name.");
    return ChatBase_ChatMessageSourceTypeEnum_Name(enum_t_value);
  }
  static inline bool ChatMessageSourceTypeEnum_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ChatMessageSourceTypeEnum* value) {
    return ChatBase_ChatMessageSourceTypeEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kCreatorNameFieldNumber = 11,
    kCreatorPicUrlFieldNumber = 12,
    kCreatedTimeFieldNumber = 3,
    kChatTypeFieldNumber = 1,
    kCompleteFieldNumber = 4,
    kWasTranslatedFieldNumber = 5,
    kCreatorIsLocalFieldNumber = 10,
  };
  // string Text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string CreatorName = 11;
  void clear_creatorname();
  const std::string& creatorname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creatorname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creatorname();
  PROTOBUF_NODISCARD std::string* release_creatorname();
  void set_allocated_creatorname(std::string* creatorname);
  private:
  const std::string& _internal_creatorname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creatorname(const std::string& value);
  std::string* _internal_mutable_creatorname();
  public:

  // string CreatorPicUrl = 12;
  void clear_creatorpicurl();
  const std::string& creatorpicurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creatorpicurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creatorpicurl();
  PROTOBUF_NODISCARD std::string* release_creatorpicurl();
  void set_allocated_creatorpicurl(std::string* creatorpicurl);
  private:
  const std::string& _internal_creatorpicurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creatorpicurl(const std::string& value);
  std::string* _internal_mutable_creatorpicurl();
  public:

  // .google.protobuf.Timestamp CreatedTime = 3;
  bool has_createdtime() const;
  private:
  bool _internal_has_createdtime() const;
  public:
  void clear_createdtime();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& createdtime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_createdtime();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_createdtime();
  void set_allocated_createdtime(::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_createdtime() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_createdtime();
  public:
  void unsafe_arena_set_allocated_createdtime(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_createdtime();

  // .ServerData.ChatBase.ChatMessageSourceTypeEnum ChatType = 1;
  void clear_chattype();
  ::ServerData::ChatBase_ChatMessageSourceTypeEnum chattype() const;
  void set_chattype(::ServerData::ChatBase_ChatMessageSourceTypeEnum value);
  private:
  ::ServerData::ChatBase_ChatMessageSourceTypeEnum _internal_chattype() const;
  void _internal_set_chattype(::ServerData::ChatBase_ChatMessageSourceTypeEnum value);
  public:

  // bool Complete = 4;
  void clear_complete();
  bool complete() const;
  void set_complete(bool value);
  private:
  bool _internal_complete() const;
  void _internal_set_complete(bool value);
  public:

  // bool WasTranslated = 5;
  void clear_wastranslated();
  bool wastranslated() const;
  void set_wastranslated(bool value);
  private:
  bool _internal_wastranslated() const;
  void _internal_set_wastranslated(bool value);
  public:

  // bool CreatorIsLocal = 10;
  void clear_creatorislocal();
  bool creatorislocal() const;
  void set_creatorislocal(bool value);
  private:
  bool _internal_creatorislocal() const;
  void _internal_set_creatorislocal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.ChatBase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creatorname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creatorpicurl_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime_;
    int chattype_;
    bool complete_;
    bool wastranslated_;
    bool creatorislocal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class QueryAiReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.QueryAiReq) */ {
 public:
  inline QueryAiReq() : QueryAiReq(nullptr) {}
  ~QueryAiReq() override;
  explicit PROTOBUF_CONSTEXPR QueryAiReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAiReq(const QueryAiReq& from);
  QueryAiReq(QueryAiReq&& from) noexcept
    : QueryAiReq() {
    *this = ::std::move(from);
  }

  inline QueryAiReq& operator=(const QueryAiReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAiReq& operator=(QueryAiReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAiReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAiReq* internal_default_instance() {
    return reinterpret_cast<const QueryAiReq*>(
               &_QueryAiReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(QueryAiReq& a, QueryAiReq& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAiReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAiReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAiReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAiReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAiReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAiReq& from) {
    QueryAiReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAiReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.QueryAiReq";
  }
  protected:
  explicit QueryAiReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqTextFieldNumber = 11,
    kApiKeyFieldNumber = 12,
    kSpaceConnFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // string reqText = 11;
  void clear_reqtext();
  const std::string& reqtext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reqtext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reqtext();
  PROTOBUF_NODISCARD std::string* release_reqtext();
  void set_allocated_reqtext(std::string* reqtext);
  private:
  const std::string& _internal_reqtext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reqtext(const std::string& value);
  std::string* _internal_mutable_reqtext();
  public:

  // string apiKey = 12;
  void clear_apikey();
  const std::string& apikey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_apikey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_apikey();
  PROTOBUF_NODISCARD std::string* release_apikey();
  void set_allocated_apikey(std::string* apikey);
  private:
  const std::string& _internal_apikey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_apikey(const std::string& value);
  std::string* _internal_mutable_apikey();
  public:

  // .ServerData.CavrnusSpaceConnection spaceConn = 10;
  bool has_spaceconn() const;
  private:
  bool _internal_has_spaceconn() const;
  public:
  void clear_spaceconn();
  const ::ServerData::CavrnusSpaceConnection& spaceconn() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusSpaceConnection* release_spaceconn();
  ::ServerData::CavrnusSpaceConnection* mutable_spaceconn();
  void set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn);
  private:
  const ::ServerData::CavrnusSpaceConnection& _internal_spaceconn() const;
  ::ServerData::CavrnusSpaceConnection* _internal_mutable_spaceconn();
  public:
  void unsafe_arena_set_allocated_spaceconn(
      ::ServerData::CavrnusSpaceConnection* spaceconn);
  ::ServerData::CavrnusSpaceConnection* unsafe_arena_release_spaceconn();

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.QueryAiReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reqtext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr apikey_;
    ::ServerData::CavrnusSpaceConnection* spaceconn_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// -------------------------------------------------------------------

class QueryAiResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.QueryAiResp) */ {
 public:
  inline QueryAiResp() : QueryAiResp(nullptr) {}
  ~QueryAiResp() override;
  explicit PROTOBUF_CONSTEXPR QueryAiResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAiResp(const QueryAiResp& from);
  QueryAiResp(QueryAiResp&& from) noexcept
    : QueryAiResp() {
    *this = ::std::move(from);
  }

  inline QueryAiResp& operator=(const QueryAiResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAiResp& operator=(QueryAiResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAiResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAiResp* internal_default_instance() {
    return reinterpret_cast<const QueryAiResp*>(
               &_QueryAiResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(QueryAiResp& a, QueryAiResp& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAiResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAiResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAiResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAiResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAiResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAiResp& from) {
    QueryAiResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAiResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.QueryAiResp";
  }
  protected:
  explicit QueryAiResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRespTextFieldNumber = 10,
    kReqIdFieldNumber = 1,
  };
  // string respText = 10;
  void clear_resptext();
  const std::string& resptext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resptext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resptext();
  PROTOBUF_NODISCARD std::string* release_resptext();
  void set_allocated_resptext(std::string* resptext);
  private:
  const std::string& _internal_resptext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resptext(const std::string& value);
  std::string* _internal_mutable_resptext();
  public:

  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.QueryAiResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resptext_;
    int32_t reqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RelayClientMessageBatch

// repeated .ServerData.RelayClientMessage Messages = 1;
inline int RelayClientMessageBatch::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int RelayClientMessageBatch::messages_size() const {
  return _internal_messages_size();
}
inline void RelayClientMessageBatch::clear_messages() {
  _impl_.messages_.Clear();
}
inline ::ServerData::RelayClientMessage* RelayClientMessageBatch::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessageBatch.Messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayClientMessage >*
RelayClientMessageBatch::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.RelayClientMessageBatch.Messages)
  return &_impl_.messages_;
}
inline const ::ServerData::RelayClientMessage& RelayClientMessageBatch::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::ServerData::RelayClientMessage& RelayClientMessageBatch::messages(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessageBatch.Messages)
  return _internal_messages(index);
}
inline ::ServerData::RelayClientMessage* RelayClientMessageBatch::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::ServerData::RelayClientMessage* RelayClientMessageBatch::add_messages() {
  ::ServerData::RelayClientMessage* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:ServerData.RelayClientMessageBatch.Messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayClientMessage >&
RelayClientMessageBatch::messages() const {
  // @@protoc_insertion_point(field_list:ServerData.RelayClientMessageBatch.Messages)
  return _impl_.messages_;
}

// -------------------------------------------------------------------

// RelayClientMessage

// .ServerData.KeepAlive KeepAlive = 1;
inline bool RelayClientMessage::_internal_has_keepalive() const {
  return Msg_case() == kKeepAlive;
}
inline bool RelayClientMessage::has_keepalive() const {
  return _internal_has_keepalive();
}
inline void RelayClientMessage::set_has_keepalive() {
  _impl_._oneof_case_[0] = kKeepAlive;
}
inline void RelayClientMessage::clear_keepalive() {
  if (_internal_has_keepalive()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.keepalive_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::KeepAlive* RelayClientMessage::release_keepalive() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.KeepAlive)
  if (_internal_has_keepalive()) {
    clear_has_Msg();
    ::ServerData::KeepAlive* temp = _impl_.Msg_.keepalive_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.keepalive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::KeepAlive& RelayClientMessage::_internal_keepalive() const {
  return _internal_has_keepalive()
      ? *_impl_.Msg_.keepalive_
      : reinterpret_cast< ::ServerData::KeepAlive&>(::ServerData::_KeepAlive_default_instance_);
}
inline const ::ServerData::KeepAlive& RelayClientMessage::keepalive() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.KeepAlive)
  return _internal_keepalive();
}
inline ::ServerData::KeepAlive* RelayClientMessage::unsafe_arena_release_keepalive() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.KeepAlive)
  if (_internal_has_keepalive()) {
    clear_has_Msg();
    ::ServerData::KeepAlive* temp = _impl_.Msg_.keepalive_;
    _impl_.Msg_.keepalive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_keepalive(::ServerData::KeepAlive* keepalive) {
  clear_Msg();
  if (keepalive) {
    set_has_keepalive();
    _impl_.Msg_.keepalive_ = keepalive;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.KeepAlive)
}
inline ::ServerData::KeepAlive* RelayClientMessage::_internal_mutable_keepalive() {
  if (!_internal_has_keepalive()) {
    clear_Msg();
    set_has_keepalive();
    _impl_.Msg_.keepalive_ = CreateMaybeMessage< ::ServerData::KeepAlive >(GetArenaForAllocation());
  }
  return _impl_.Msg_.keepalive_;
}
inline ::ServerData::KeepAlive* RelayClientMessage::mutable_keepalive() {
  ::ServerData::KeepAlive* _msg = _internal_mutable_keepalive();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.KeepAlive)
  return _msg;
}

// .ServerData.UpdateTime UpdateTime = 2;
inline bool RelayClientMessage::_internal_has_updatetime() const {
  return Msg_case() == kUpdateTime;
}
inline bool RelayClientMessage::has_updatetime() const {
  return _internal_has_updatetime();
}
inline void RelayClientMessage::set_has_updatetime() {
  _impl_._oneof_case_[0] = kUpdateTime;
}
inline void RelayClientMessage::clear_updatetime() {
  if (_internal_has_updatetime()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.updatetime_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UpdateTime* RelayClientMessage::release_updatetime() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.UpdateTime)
  if (_internal_has_updatetime()) {
    clear_has_Msg();
    ::ServerData::UpdateTime* temp = _impl_.Msg_.updatetime_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.updatetime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UpdateTime& RelayClientMessage::_internal_updatetime() const {
  return _internal_has_updatetime()
      ? *_impl_.Msg_.updatetime_
      : reinterpret_cast< ::ServerData::UpdateTime&>(::ServerData::_UpdateTime_default_instance_);
}
inline const ::ServerData::UpdateTime& RelayClientMessage::updatetime() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.UpdateTime)
  return _internal_updatetime();
}
inline ::ServerData::UpdateTime* RelayClientMessage::unsafe_arena_release_updatetime() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.UpdateTime)
  if (_internal_has_updatetime()) {
    clear_has_Msg();
    ::ServerData::UpdateTime* temp = _impl_.Msg_.updatetime_;
    _impl_.Msg_.updatetime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_updatetime(::ServerData::UpdateTime* updatetime) {
  clear_Msg();
  if (updatetime) {
    set_has_updatetime();
    _impl_.Msg_.updatetime_ = updatetime;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.UpdateTime)
}
inline ::ServerData::UpdateTime* RelayClientMessage::_internal_mutable_updatetime() {
  if (!_internal_has_updatetime()) {
    clear_Msg();
    set_has_updatetime();
    _impl_.Msg_.updatetime_ = CreateMaybeMessage< ::ServerData::UpdateTime >(GetArenaForAllocation());
  }
  return _impl_.Msg_.updatetime_;
}
inline ::ServerData::UpdateTime* RelayClientMessage::mutable_updatetime() {
  ::ServerData::UpdateTime* _msg = _internal_mutable_updatetime();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.UpdateTime)
  return _msg;
}

// .ServerData.SetForceKeepAlive SetForceKeepAlive = 3;
inline bool RelayClientMessage::_internal_has_setforcekeepalive() const {
  return Msg_case() == kSetForceKeepAlive;
}
inline bool RelayClientMessage::has_setforcekeepalive() const {
  return _internal_has_setforcekeepalive();
}
inline void RelayClientMessage::set_has_setforcekeepalive() {
  _impl_._oneof_case_[0] = kSetForceKeepAlive;
}
inline void RelayClientMessage::clear_setforcekeepalive() {
  if (_internal_has_setforcekeepalive()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.setforcekeepalive_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::SetForceKeepAlive* RelayClientMessage::release_setforcekeepalive() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.SetForceKeepAlive)
  if (_internal_has_setforcekeepalive()) {
    clear_has_Msg();
    ::ServerData::SetForceKeepAlive* temp = _impl_.Msg_.setforcekeepalive_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.setforcekeepalive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::SetForceKeepAlive& RelayClientMessage::_internal_setforcekeepalive() const {
  return _internal_has_setforcekeepalive()
      ? *_impl_.Msg_.setforcekeepalive_
      : reinterpret_cast< ::ServerData::SetForceKeepAlive&>(::ServerData::_SetForceKeepAlive_default_instance_);
}
inline const ::ServerData::SetForceKeepAlive& RelayClientMessage::setforcekeepalive() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.SetForceKeepAlive)
  return _internal_setforcekeepalive();
}
inline ::ServerData::SetForceKeepAlive* RelayClientMessage::unsafe_arena_release_setforcekeepalive() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.SetForceKeepAlive)
  if (_internal_has_setforcekeepalive()) {
    clear_has_Msg();
    ::ServerData::SetForceKeepAlive* temp = _impl_.Msg_.setforcekeepalive_;
    _impl_.Msg_.setforcekeepalive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_setforcekeepalive(::ServerData::SetForceKeepAlive* setforcekeepalive) {
  clear_Msg();
  if (setforcekeepalive) {
    set_has_setforcekeepalive();
    _impl_.Msg_.setforcekeepalive_ = setforcekeepalive;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.SetForceKeepAlive)
}
inline ::ServerData::SetForceKeepAlive* RelayClientMessage::_internal_mutable_setforcekeepalive() {
  if (!_internal_has_setforcekeepalive()) {
    clear_Msg();
    set_has_setforcekeepalive();
    _impl_.Msg_.setforcekeepalive_ = CreateMaybeMessage< ::ServerData::SetForceKeepAlive >(GetArenaForAllocation());
  }
  return _impl_.Msg_.setforcekeepalive_;
}
inline ::ServerData::SetForceKeepAlive* RelayClientMessage::mutable_setforcekeepalive() {
  ::ServerData::SetForceKeepAlive* _msg = _internal_mutable_setforcekeepalive();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.SetForceKeepAlive)
  return _msg;
}

// .ServerData.EndForceKeepAlive EndForceKeepAlive = 4;
inline bool RelayClientMessage::_internal_has_endforcekeepalive() const {
  return Msg_case() == kEndForceKeepAlive;
}
inline bool RelayClientMessage::has_endforcekeepalive() const {
  return _internal_has_endforcekeepalive();
}
inline void RelayClientMessage::set_has_endforcekeepalive() {
  _impl_._oneof_case_[0] = kEndForceKeepAlive;
}
inline void RelayClientMessage::clear_endforcekeepalive() {
  if (_internal_has_endforcekeepalive()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.endforcekeepalive_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::EndForceKeepAlive* RelayClientMessage::release_endforcekeepalive() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.EndForceKeepAlive)
  if (_internal_has_endforcekeepalive()) {
    clear_has_Msg();
    ::ServerData::EndForceKeepAlive* temp = _impl_.Msg_.endforcekeepalive_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.endforcekeepalive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::EndForceKeepAlive& RelayClientMessage::_internal_endforcekeepalive() const {
  return _internal_has_endforcekeepalive()
      ? *_impl_.Msg_.endforcekeepalive_
      : reinterpret_cast< ::ServerData::EndForceKeepAlive&>(::ServerData::_EndForceKeepAlive_default_instance_);
}
inline const ::ServerData::EndForceKeepAlive& RelayClientMessage::endforcekeepalive() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.EndForceKeepAlive)
  return _internal_endforcekeepalive();
}
inline ::ServerData::EndForceKeepAlive* RelayClientMessage::unsafe_arena_release_endforcekeepalive() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.EndForceKeepAlive)
  if (_internal_has_endforcekeepalive()) {
    clear_has_Msg();
    ::ServerData::EndForceKeepAlive* temp = _impl_.Msg_.endforcekeepalive_;
    _impl_.Msg_.endforcekeepalive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_endforcekeepalive(::ServerData::EndForceKeepAlive* endforcekeepalive) {
  clear_Msg();
  if (endforcekeepalive) {
    set_has_endforcekeepalive();
    _impl_.Msg_.endforcekeepalive_ = endforcekeepalive;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.EndForceKeepAlive)
}
inline ::ServerData::EndForceKeepAlive* RelayClientMessage::_internal_mutable_endforcekeepalive() {
  if (!_internal_has_endforcekeepalive()) {
    clear_Msg();
    set_has_endforcekeepalive();
    _impl_.Msg_.endforcekeepalive_ = CreateMaybeMessage< ::ServerData::EndForceKeepAlive >(GetArenaForAllocation());
  }
  return _impl_.Msg_.endforcekeepalive_;
}
inline ::ServerData::EndForceKeepAlive* RelayClientMessage::mutable_endforcekeepalive() {
  ::ServerData::EndForceKeepAlive* _msg = _internal_mutable_endforcekeepalive();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.EndForceKeepAlive)
  return _msg;
}

// .ServerData.PostDataCacheUpdate PostDataCacheUpdate = 5;
inline bool RelayClientMessage::_internal_has_postdatacacheupdate() const {
  return Msg_case() == kPostDataCacheUpdate;
}
inline bool RelayClientMessage::has_postdatacacheupdate() const {
  return _internal_has_postdatacacheupdate();
}
inline void RelayClientMessage::set_has_postdatacacheupdate() {
  _impl_._oneof_case_[0] = kPostDataCacheUpdate;
}
inline void RelayClientMessage::clear_postdatacacheupdate() {
  if (_internal_has_postdatacacheupdate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.postdatacacheupdate_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PostDataCacheUpdate* RelayClientMessage::release_postdatacacheupdate() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.PostDataCacheUpdate)
  if (_internal_has_postdatacacheupdate()) {
    clear_has_Msg();
    ::ServerData::PostDataCacheUpdate* temp = _impl_.Msg_.postdatacacheupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.postdatacacheupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PostDataCacheUpdate& RelayClientMessage::_internal_postdatacacheupdate() const {
  return _internal_has_postdatacacheupdate()
      ? *_impl_.Msg_.postdatacacheupdate_
      : reinterpret_cast< ::ServerData::PostDataCacheUpdate&>(::ServerData::_PostDataCacheUpdate_default_instance_);
}
inline const ::ServerData::PostDataCacheUpdate& RelayClientMessage::postdatacacheupdate() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.PostDataCacheUpdate)
  return _internal_postdatacacheupdate();
}
inline ::ServerData::PostDataCacheUpdate* RelayClientMessage::unsafe_arena_release_postdatacacheupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.PostDataCacheUpdate)
  if (_internal_has_postdatacacheupdate()) {
    clear_has_Msg();
    ::ServerData::PostDataCacheUpdate* temp = _impl_.Msg_.postdatacacheupdate_;
    _impl_.Msg_.postdatacacheupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_postdatacacheupdate(::ServerData::PostDataCacheUpdate* postdatacacheupdate) {
  clear_Msg();
  if (postdatacacheupdate) {
    set_has_postdatacacheupdate();
    _impl_.Msg_.postdatacacheupdate_ = postdatacacheupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.PostDataCacheUpdate)
}
inline ::ServerData::PostDataCacheUpdate* RelayClientMessage::_internal_mutable_postdatacacheupdate() {
  if (!_internal_has_postdatacacheupdate()) {
    clear_Msg();
    set_has_postdatacacheupdate();
    _impl_.Msg_.postdatacacheupdate_ = CreateMaybeMessage< ::ServerData::PostDataCacheUpdate >(GetArenaForAllocation());
  }
  return _impl_.Msg_.postdatacacheupdate_;
}
inline ::ServerData::PostDataCacheUpdate* RelayClientMessage::mutable_postdatacacheupdate() {
  ::ServerData::PostDataCacheUpdate* _msg = _internal_mutable_postdatacacheupdate();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.PostDataCacheUpdate)
  return _msg;
}

// .ServerData.AuthenticateReq AuthenticateReq = 10;
inline bool RelayClientMessage::_internal_has_authenticatereq() const {
  return Msg_case() == kAuthenticateReq;
}
inline bool RelayClientMessage::has_authenticatereq() const {
  return _internal_has_authenticatereq();
}
inline void RelayClientMessage::set_has_authenticatereq() {
  _impl_._oneof_case_[0] = kAuthenticateReq;
}
inline void RelayClientMessage::clear_authenticatereq() {
  if (_internal_has_authenticatereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.authenticatereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AuthenticateReq* RelayClientMessage::release_authenticatereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.AuthenticateReq)
  if (_internal_has_authenticatereq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateReq* temp = _impl_.Msg_.authenticatereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.authenticatereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AuthenticateReq& RelayClientMessage::_internal_authenticatereq() const {
  return _internal_has_authenticatereq()
      ? *_impl_.Msg_.authenticatereq_
      : reinterpret_cast< ::ServerData::AuthenticateReq&>(::ServerData::_AuthenticateReq_default_instance_);
}
inline const ::ServerData::AuthenticateReq& RelayClientMessage::authenticatereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.AuthenticateReq)
  return _internal_authenticatereq();
}
inline ::ServerData::AuthenticateReq* RelayClientMessage::unsafe_arena_release_authenticatereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.AuthenticateReq)
  if (_internal_has_authenticatereq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateReq* temp = _impl_.Msg_.authenticatereq_;
    _impl_.Msg_.authenticatereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_authenticatereq(::ServerData::AuthenticateReq* authenticatereq) {
  clear_Msg();
  if (authenticatereq) {
    set_has_authenticatereq();
    _impl_.Msg_.authenticatereq_ = authenticatereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.AuthenticateReq)
}
inline ::ServerData::AuthenticateReq* RelayClientMessage::_internal_mutable_authenticatereq() {
  if (!_internal_has_authenticatereq()) {
    clear_Msg();
    set_has_authenticatereq();
    _impl_.Msg_.authenticatereq_ = CreateMaybeMessage< ::ServerData::AuthenticateReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.authenticatereq_;
}
inline ::ServerData::AuthenticateReq* RelayClientMessage::mutable_authenticatereq() {
  ::ServerData::AuthenticateReq* _msg = _internal_mutable_authenticatereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.AuthenticateReq)
  return _msg;
}

// .ServerData.AuthenticateApiKeyReq AuthenticateApiKeyReq = 19;
inline bool RelayClientMessage::_internal_has_authenticateapikeyreq() const {
  return Msg_case() == kAuthenticateApiKeyReq;
}
inline bool RelayClientMessage::has_authenticateapikeyreq() const {
  return _internal_has_authenticateapikeyreq();
}
inline void RelayClientMessage::set_has_authenticateapikeyreq() {
  _impl_._oneof_case_[0] = kAuthenticateApiKeyReq;
}
inline void RelayClientMessage::clear_authenticateapikeyreq() {
  if (_internal_has_authenticateapikeyreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.authenticateapikeyreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AuthenticateApiKeyReq* RelayClientMessage::release_authenticateapikeyreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.AuthenticateApiKeyReq)
  if (_internal_has_authenticateapikeyreq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateApiKeyReq* temp = _impl_.Msg_.authenticateapikeyreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.authenticateapikeyreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AuthenticateApiKeyReq& RelayClientMessage::_internal_authenticateapikeyreq() const {
  return _internal_has_authenticateapikeyreq()
      ? *_impl_.Msg_.authenticateapikeyreq_
      : reinterpret_cast< ::ServerData::AuthenticateApiKeyReq&>(::ServerData::_AuthenticateApiKeyReq_default_instance_);
}
inline const ::ServerData::AuthenticateApiKeyReq& RelayClientMessage::authenticateapikeyreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.AuthenticateApiKeyReq)
  return _internal_authenticateapikeyreq();
}
inline ::ServerData::AuthenticateApiKeyReq* RelayClientMessage::unsafe_arena_release_authenticateapikeyreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.AuthenticateApiKeyReq)
  if (_internal_has_authenticateapikeyreq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateApiKeyReq* temp = _impl_.Msg_.authenticateapikeyreq_;
    _impl_.Msg_.authenticateapikeyreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_authenticateapikeyreq(::ServerData::AuthenticateApiKeyReq* authenticateapikeyreq) {
  clear_Msg();
  if (authenticateapikeyreq) {
    set_has_authenticateapikeyreq();
    _impl_.Msg_.authenticateapikeyreq_ = authenticateapikeyreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.AuthenticateApiKeyReq)
}
inline ::ServerData::AuthenticateApiKeyReq* RelayClientMessage::_internal_mutable_authenticateapikeyreq() {
  if (!_internal_has_authenticateapikeyreq()) {
    clear_Msg();
    set_has_authenticateapikeyreq();
    _impl_.Msg_.authenticateapikeyreq_ = CreateMaybeMessage< ::ServerData::AuthenticateApiKeyReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.authenticateapikeyreq_;
}
inline ::ServerData::AuthenticateApiKeyReq* RelayClientMessage::mutable_authenticateapikeyreq() {
  ::ServerData::AuthenticateApiKeyReq* _msg = _internal_mutable_authenticateapikeyreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.AuthenticateApiKeyReq)
  return _msg;
}

// .ServerData.AuthenticateGuestReq AuthenticateGuestReq = 11;
inline bool RelayClientMessage::_internal_has_authenticateguestreq() const {
  return Msg_case() == kAuthenticateGuestReq;
}
inline bool RelayClientMessage::has_authenticateguestreq() const {
  return _internal_has_authenticateguestreq();
}
inline void RelayClientMessage::set_has_authenticateguestreq() {
  _impl_._oneof_case_[0] = kAuthenticateGuestReq;
}
inline void RelayClientMessage::clear_authenticateguestreq() {
  if (_internal_has_authenticateguestreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.authenticateguestreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AuthenticateGuestReq* RelayClientMessage::release_authenticateguestreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.AuthenticateGuestReq)
  if (_internal_has_authenticateguestreq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateGuestReq* temp = _impl_.Msg_.authenticateguestreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.authenticateguestreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AuthenticateGuestReq& RelayClientMessage::_internal_authenticateguestreq() const {
  return _internal_has_authenticateguestreq()
      ? *_impl_.Msg_.authenticateguestreq_
      : reinterpret_cast< ::ServerData::AuthenticateGuestReq&>(::ServerData::_AuthenticateGuestReq_default_instance_);
}
inline const ::ServerData::AuthenticateGuestReq& RelayClientMessage::authenticateguestreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.AuthenticateGuestReq)
  return _internal_authenticateguestreq();
}
inline ::ServerData::AuthenticateGuestReq* RelayClientMessage::unsafe_arena_release_authenticateguestreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.AuthenticateGuestReq)
  if (_internal_has_authenticateguestreq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateGuestReq* temp = _impl_.Msg_.authenticateguestreq_;
    _impl_.Msg_.authenticateguestreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_authenticateguestreq(::ServerData::AuthenticateGuestReq* authenticateguestreq) {
  clear_Msg();
  if (authenticateguestreq) {
    set_has_authenticateguestreq();
    _impl_.Msg_.authenticateguestreq_ = authenticateguestreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.AuthenticateGuestReq)
}
inline ::ServerData::AuthenticateGuestReq* RelayClientMessage::_internal_mutable_authenticateguestreq() {
  if (!_internal_has_authenticateguestreq()) {
    clear_Msg();
    set_has_authenticateguestreq();
    _impl_.Msg_.authenticateguestreq_ = CreateMaybeMessage< ::ServerData::AuthenticateGuestReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.authenticateguestreq_;
}
inline ::ServerData::AuthenticateGuestReq* RelayClientMessage::mutable_authenticateguestreq() {
  ::ServerData::AuthenticateGuestReq* _msg = _internal_mutable_authenticateguestreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.AuthenticateGuestReq)
  return _msg;
}

// .ServerData.AuthenticateDeviceCodeBeginReq AuthenticateDeviceCodeBeginReq = 15;
inline bool RelayClientMessage::_internal_has_authenticatedevicecodebeginreq() const {
  return Msg_case() == kAuthenticateDeviceCodeBeginReq;
}
inline bool RelayClientMessage::has_authenticatedevicecodebeginreq() const {
  return _internal_has_authenticatedevicecodebeginreq();
}
inline void RelayClientMessage::set_has_authenticatedevicecodebeginreq() {
  _impl_._oneof_case_[0] = kAuthenticateDeviceCodeBeginReq;
}
inline void RelayClientMessage::clear_authenticatedevicecodebeginreq() {
  if (_internal_has_authenticatedevicecodebeginreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.authenticatedevicecodebeginreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AuthenticateDeviceCodeBeginReq* RelayClientMessage::release_authenticatedevicecodebeginreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.AuthenticateDeviceCodeBeginReq)
  if (_internal_has_authenticatedevicecodebeginreq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateDeviceCodeBeginReq* temp = _impl_.Msg_.authenticatedevicecodebeginreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.authenticatedevicecodebeginreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AuthenticateDeviceCodeBeginReq& RelayClientMessage::_internal_authenticatedevicecodebeginreq() const {
  return _internal_has_authenticatedevicecodebeginreq()
      ? *_impl_.Msg_.authenticatedevicecodebeginreq_
      : reinterpret_cast< ::ServerData::AuthenticateDeviceCodeBeginReq&>(::ServerData::_AuthenticateDeviceCodeBeginReq_default_instance_);
}
inline const ::ServerData::AuthenticateDeviceCodeBeginReq& RelayClientMessage::authenticatedevicecodebeginreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.AuthenticateDeviceCodeBeginReq)
  return _internal_authenticatedevicecodebeginreq();
}
inline ::ServerData::AuthenticateDeviceCodeBeginReq* RelayClientMessage::unsafe_arena_release_authenticatedevicecodebeginreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.AuthenticateDeviceCodeBeginReq)
  if (_internal_has_authenticatedevicecodebeginreq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateDeviceCodeBeginReq* temp = _impl_.Msg_.authenticatedevicecodebeginreq_;
    _impl_.Msg_.authenticatedevicecodebeginreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_authenticatedevicecodebeginreq(::ServerData::AuthenticateDeviceCodeBeginReq* authenticatedevicecodebeginreq) {
  clear_Msg();
  if (authenticatedevicecodebeginreq) {
    set_has_authenticatedevicecodebeginreq();
    _impl_.Msg_.authenticatedevicecodebeginreq_ = authenticatedevicecodebeginreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.AuthenticateDeviceCodeBeginReq)
}
inline ::ServerData::AuthenticateDeviceCodeBeginReq* RelayClientMessage::_internal_mutable_authenticatedevicecodebeginreq() {
  if (!_internal_has_authenticatedevicecodebeginreq()) {
    clear_Msg();
    set_has_authenticatedevicecodebeginreq();
    _impl_.Msg_.authenticatedevicecodebeginreq_ = CreateMaybeMessage< ::ServerData::AuthenticateDeviceCodeBeginReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.authenticatedevicecodebeginreq_;
}
inline ::ServerData::AuthenticateDeviceCodeBeginReq* RelayClientMessage::mutable_authenticatedevicecodebeginreq() {
  ::ServerData::AuthenticateDeviceCodeBeginReq* _msg = _internal_mutable_authenticatedevicecodebeginreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.AuthenticateDeviceCodeBeginReq)
  return _msg;
}

// .ServerData.AuthenticateDeviceCodeConcludeReq AuthenticateDeviceCodeConcludeReq = 16;
inline bool RelayClientMessage::_internal_has_authenticatedevicecodeconcludereq() const {
  return Msg_case() == kAuthenticateDeviceCodeConcludeReq;
}
inline bool RelayClientMessage::has_authenticatedevicecodeconcludereq() const {
  return _internal_has_authenticatedevicecodeconcludereq();
}
inline void RelayClientMessage::set_has_authenticatedevicecodeconcludereq() {
  _impl_._oneof_case_[0] = kAuthenticateDeviceCodeConcludeReq;
}
inline void RelayClientMessage::clear_authenticatedevicecodeconcludereq() {
  if (_internal_has_authenticatedevicecodeconcludereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.authenticatedevicecodeconcludereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AuthenticateDeviceCodeConcludeReq* RelayClientMessage::release_authenticatedevicecodeconcludereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.AuthenticateDeviceCodeConcludeReq)
  if (_internal_has_authenticatedevicecodeconcludereq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateDeviceCodeConcludeReq* temp = _impl_.Msg_.authenticatedevicecodeconcludereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.authenticatedevicecodeconcludereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AuthenticateDeviceCodeConcludeReq& RelayClientMessage::_internal_authenticatedevicecodeconcludereq() const {
  return _internal_has_authenticatedevicecodeconcludereq()
      ? *_impl_.Msg_.authenticatedevicecodeconcludereq_
      : reinterpret_cast< ::ServerData::AuthenticateDeviceCodeConcludeReq&>(::ServerData::_AuthenticateDeviceCodeConcludeReq_default_instance_);
}
inline const ::ServerData::AuthenticateDeviceCodeConcludeReq& RelayClientMessage::authenticatedevicecodeconcludereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.AuthenticateDeviceCodeConcludeReq)
  return _internal_authenticatedevicecodeconcludereq();
}
inline ::ServerData::AuthenticateDeviceCodeConcludeReq* RelayClientMessage::unsafe_arena_release_authenticatedevicecodeconcludereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.AuthenticateDeviceCodeConcludeReq)
  if (_internal_has_authenticatedevicecodeconcludereq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateDeviceCodeConcludeReq* temp = _impl_.Msg_.authenticatedevicecodeconcludereq_;
    _impl_.Msg_.authenticatedevicecodeconcludereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_authenticatedevicecodeconcludereq(::ServerData::AuthenticateDeviceCodeConcludeReq* authenticatedevicecodeconcludereq) {
  clear_Msg();
  if (authenticatedevicecodeconcludereq) {
    set_has_authenticatedevicecodeconcludereq();
    _impl_.Msg_.authenticatedevicecodeconcludereq_ = authenticatedevicecodeconcludereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.AuthenticateDeviceCodeConcludeReq)
}
inline ::ServerData::AuthenticateDeviceCodeConcludeReq* RelayClientMessage::_internal_mutable_authenticatedevicecodeconcludereq() {
  if (!_internal_has_authenticatedevicecodeconcludereq()) {
    clear_Msg();
    set_has_authenticatedevicecodeconcludereq();
    _impl_.Msg_.authenticatedevicecodeconcludereq_ = CreateMaybeMessage< ::ServerData::AuthenticateDeviceCodeConcludeReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.authenticatedevicecodeconcludereq_;
}
inline ::ServerData::AuthenticateDeviceCodeConcludeReq* RelayClientMessage::mutable_authenticatedevicecodeconcludereq() {
  ::ServerData::AuthenticateDeviceCodeConcludeReq* _msg = _internal_mutable_authenticatedevicecodeconcludereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.AuthenticateDeviceCodeConcludeReq)
  return _msg;
}

// .ServerData.ExitAllSpacesAndLogoutReq ExitAllSpacesAndLogoutReq = 12;
inline bool RelayClientMessage::_internal_has_exitallspacesandlogoutreq() const {
  return Msg_case() == kExitAllSpacesAndLogoutReq;
}
inline bool RelayClientMessage::has_exitallspacesandlogoutreq() const {
  return _internal_has_exitallspacesandlogoutreq();
}
inline void RelayClientMessage::set_has_exitallspacesandlogoutreq() {
  _impl_._oneof_case_[0] = kExitAllSpacesAndLogoutReq;
}
inline void RelayClientMessage::clear_exitallspacesandlogoutreq() {
  if (_internal_has_exitallspacesandlogoutreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.exitallspacesandlogoutreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ExitAllSpacesAndLogoutReq* RelayClientMessage::release_exitallspacesandlogoutreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.ExitAllSpacesAndLogoutReq)
  if (_internal_has_exitallspacesandlogoutreq()) {
    clear_has_Msg();
    ::ServerData::ExitAllSpacesAndLogoutReq* temp = _impl_.Msg_.exitallspacesandlogoutreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.exitallspacesandlogoutreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ExitAllSpacesAndLogoutReq& RelayClientMessage::_internal_exitallspacesandlogoutreq() const {
  return _internal_has_exitallspacesandlogoutreq()
      ? *_impl_.Msg_.exitallspacesandlogoutreq_
      : reinterpret_cast< ::ServerData::ExitAllSpacesAndLogoutReq&>(::ServerData::_ExitAllSpacesAndLogoutReq_default_instance_);
}
inline const ::ServerData::ExitAllSpacesAndLogoutReq& RelayClientMessage::exitallspacesandlogoutreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.ExitAllSpacesAndLogoutReq)
  return _internal_exitallspacesandlogoutreq();
}
inline ::ServerData::ExitAllSpacesAndLogoutReq* RelayClientMessage::unsafe_arena_release_exitallspacesandlogoutreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.ExitAllSpacesAndLogoutReq)
  if (_internal_has_exitallspacesandlogoutreq()) {
    clear_has_Msg();
    ::ServerData::ExitAllSpacesAndLogoutReq* temp = _impl_.Msg_.exitallspacesandlogoutreq_;
    _impl_.Msg_.exitallspacesandlogoutreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_exitallspacesandlogoutreq(::ServerData::ExitAllSpacesAndLogoutReq* exitallspacesandlogoutreq) {
  clear_Msg();
  if (exitallspacesandlogoutreq) {
    set_has_exitallspacesandlogoutreq();
    _impl_.Msg_.exitallspacesandlogoutreq_ = exitallspacesandlogoutreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.ExitAllSpacesAndLogoutReq)
}
inline ::ServerData::ExitAllSpacesAndLogoutReq* RelayClientMessage::_internal_mutable_exitallspacesandlogoutreq() {
  if (!_internal_has_exitallspacesandlogoutreq()) {
    clear_Msg();
    set_has_exitallspacesandlogoutreq();
    _impl_.Msg_.exitallspacesandlogoutreq_ = CreateMaybeMessage< ::ServerData::ExitAllSpacesAndLogoutReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.exitallspacesandlogoutreq_;
}
inline ::ServerData::ExitAllSpacesAndLogoutReq* RelayClientMessage::mutable_exitallspacesandlogoutreq() {
  ::ServerData::ExitAllSpacesAndLogoutReq* _msg = _internal_mutable_exitallspacesandlogoutreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.ExitAllSpacesAndLogoutReq)
  return _msg;
}

// .ServerData.AuthenticateTokenReq AuthenticateTokenReq = 13;
inline bool RelayClientMessage::_internal_has_authenticatetokenreq() const {
  return Msg_case() == kAuthenticateTokenReq;
}
inline bool RelayClientMessage::has_authenticatetokenreq() const {
  return _internal_has_authenticatetokenreq();
}
inline void RelayClientMessage::set_has_authenticatetokenreq() {
  _impl_._oneof_case_[0] = kAuthenticateTokenReq;
}
inline void RelayClientMessage::clear_authenticatetokenreq() {
  if (_internal_has_authenticatetokenreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.authenticatetokenreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AuthenticateTokenReq* RelayClientMessage::release_authenticatetokenreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.AuthenticateTokenReq)
  if (_internal_has_authenticatetokenreq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateTokenReq* temp = _impl_.Msg_.authenticatetokenreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.authenticatetokenreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AuthenticateTokenReq& RelayClientMessage::_internal_authenticatetokenreq() const {
  return _internal_has_authenticatetokenreq()
      ? *_impl_.Msg_.authenticatetokenreq_
      : reinterpret_cast< ::ServerData::AuthenticateTokenReq&>(::ServerData::_AuthenticateTokenReq_default_instance_);
}
inline const ::ServerData::AuthenticateTokenReq& RelayClientMessage::authenticatetokenreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.AuthenticateTokenReq)
  return _internal_authenticatetokenreq();
}
inline ::ServerData::AuthenticateTokenReq* RelayClientMessage::unsafe_arena_release_authenticatetokenreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.AuthenticateTokenReq)
  if (_internal_has_authenticatetokenreq()) {
    clear_has_Msg();
    ::ServerData::AuthenticateTokenReq* temp = _impl_.Msg_.authenticatetokenreq_;
    _impl_.Msg_.authenticatetokenreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_authenticatetokenreq(::ServerData::AuthenticateTokenReq* authenticatetokenreq) {
  clear_Msg();
  if (authenticatetokenreq) {
    set_has_authenticatetokenreq();
    _impl_.Msg_.authenticatetokenreq_ = authenticatetokenreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.AuthenticateTokenReq)
}
inline ::ServerData::AuthenticateTokenReq* RelayClientMessage::_internal_mutable_authenticatetokenreq() {
  if (!_internal_has_authenticatetokenreq()) {
    clear_Msg();
    set_has_authenticatetokenreq();
    _impl_.Msg_.authenticatetokenreq_ = CreateMaybeMessage< ::ServerData::AuthenticateTokenReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.authenticatetokenreq_;
}
inline ::ServerData::AuthenticateTokenReq* RelayClientMessage::mutable_authenticatetokenreq() {
  ::ServerData::AuthenticateTokenReq* _msg = _internal_mutable_authenticatetokenreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.AuthenticateTokenReq)
  return _msg;
}

// .ServerData.CheckServerStatusReq CheckServerStatusReq = 17;
inline bool RelayClientMessage::_internal_has_checkserverstatusreq() const {
  return Msg_case() == kCheckServerStatusReq;
}
inline bool RelayClientMessage::has_checkserverstatusreq() const {
  return _internal_has_checkserverstatusreq();
}
inline void RelayClientMessage::set_has_checkserverstatusreq() {
  _impl_._oneof_case_[0] = kCheckServerStatusReq;
}
inline void RelayClientMessage::clear_checkserverstatusreq() {
  if (_internal_has_checkserverstatusreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.checkserverstatusreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::CheckServerStatusReq* RelayClientMessage::release_checkserverstatusreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.CheckServerStatusReq)
  if (_internal_has_checkserverstatusreq()) {
    clear_has_Msg();
    ::ServerData::CheckServerStatusReq* temp = _impl_.Msg_.checkserverstatusreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.checkserverstatusreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::CheckServerStatusReq& RelayClientMessage::_internal_checkserverstatusreq() const {
  return _internal_has_checkserverstatusreq()
      ? *_impl_.Msg_.checkserverstatusreq_
      : reinterpret_cast< ::ServerData::CheckServerStatusReq&>(::ServerData::_CheckServerStatusReq_default_instance_);
}
inline const ::ServerData::CheckServerStatusReq& RelayClientMessage::checkserverstatusreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.CheckServerStatusReq)
  return _internal_checkserverstatusreq();
}
inline ::ServerData::CheckServerStatusReq* RelayClientMessage::unsafe_arena_release_checkserverstatusreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.CheckServerStatusReq)
  if (_internal_has_checkserverstatusreq()) {
    clear_has_Msg();
    ::ServerData::CheckServerStatusReq* temp = _impl_.Msg_.checkserverstatusreq_;
    _impl_.Msg_.checkserverstatusreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_checkserverstatusreq(::ServerData::CheckServerStatusReq* checkserverstatusreq) {
  clear_Msg();
  if (checkserverstatusreq) {
    set_has_checkserverstatusreq();
    _impl_.Msg_.checkserverstatusreq_ = checkserverstatusreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.CheckServerStatusReq)
}
inline ::ServerData::CheckServerStatusReq* RelayClientMessage::_internal_mutable_checkserverstatusreq() {
  if (!_internal_has_checkserverstatusreq()) {
    clear_Msg();
    set_has_checkserverstatusreq();
    _impl_.Msg_.checkserverstatusreq_ = CreateMaybeMessage< ::ServerData::CheckServerStatusReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.checkserverstatusreq_;
}
inline ::ServerData::CheckServerStatusReq* RelayClientMessage::mutable_checkserverstatusreq() {
  ::ServerData::CheckServerStatusReq* _msg = _internal_mutable_checkserverstatusreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.CheckServerStatusReq)
  return _msg;
}

// .ServerData.ConstructApiKeyReq ConstructApiKeyReq = 18;
inline bool RelayClientMessage::_internal_has_constructapikeyreq() const {
  return Msg_case() == kConstructApiKeyReq;
}
inline bool RelayClientMessage::has_constructapikeyreq() const {
  return _internal_has_constructapikeyreq();
}
inline void RelayClientMessage::set_has_constructapikeyreq() {
  _impl_._oneof_case_[0] = kConstructApiKeyReq;
}
inline void RelayClientMessage::clear_constructapikeyreq() {
  if (_internal_has_constructapikeyreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.constructapikeyreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ConstructApiKeyReq* RelayClientMessage::release_constructapikeyreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.ConstructApiKeyReq)
  if (_internal_has_constructapikeyreq()) {
    clear_has_Msg();
    ::ServerData::ConstructApiKeyReq* temp = _impl_.Msg_.constructapikeyreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.constructapikeyreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ConstructApiKeyReq& RelayClientMessage::_internal_constructapikeyreq() const {
  return _internal_has_constructapikeyreq()
      ? *_impl_.Msg_.constructapikeyreq_
      : reinterpret_cast< ::ServerData::ConstructApiKeyReq&>(::ServerData::_ConstructApiKeyReq_default_instance_);
}
inline const ::ServerData::ConstructApiKeyReq& RelayClientMessage::constructapikeyreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.ConstructApiKeyReq)
  return _internal_constructapikeyreq();
}
inline ::ServerData::ConstructApiKeyReq* RelayClientMessage::unsafe_arena_release_constructapikeyreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.ConstructApiKeyReq)
  if (_internal_has_constructapikeyreq()) {
    clear_has_Msg();
    ::ServerData::ConstructApiKeyReq* temp = _impl_.Msg_.constructapikeyreq_;
    _impl_.Msg_.constructapikeyreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_constructapikeyreq(::ServerData::ConstructApiKeyReq* constructapikeyreq) {
  clear_Msg();
  if (constructapikeyreq) {
    set_has_constructapikeyreq();
    _impl_.Msg_.constructapikeyreq_ = constructapikeyreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.ConstructApiKeyReq)
}
inline ::ServerData::ConstructApiKeyReq* RelayClientMessage::_internal_mutable_constructapikeyreq() {
  if (!_internal_has_constructapikeyreq()) {
    clear_Msg();
    set_has_constructapikeyreq();
    _impl_.Msg_.constructapikeyreq_ = CreateMaybeMessage< ::ServerData::ConstructApiKeyReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.constructapikeyreq_;
}
inline ::ServerData::ConstructApiKeyReq* RelayClientMessage::mutable_constructapikeyreq() {
  ::ServerData::ConstructApiKeyReq* _msg = _internal_mutable_constructapikeyreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.ConstructApiKeyReq)
  return _msg;
}

// .ServerData.JoinSpaceFromIdReq JoinSpaceFromIdReq = 20;
inline bool RelayClientMessage::_internal_has_joinspacefromidreq() const {
  return Msg_case() == kJoinSpaceFromIdReq;
}
inline bool RelayClientMessage::has_joinspacefromidreq() const {
  return _internal_has_joinspacefromidreq();
}
inline void RelayClientMessage::set_has_joinspacefromidreq() {
  _impl_._oneof_case_[0] = kJoinSpaceFromIdReq;
}
inline void RelayClientMessage::clear_joinspacefromidreq() {
  if (_internal_has_joinspacefromidreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.joinspacefromidreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::JoinSpaceFromIdReq* RelayClientMessage::release_joinspacefromidreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.JoinSpaceFromIdReq)
  if (_internal_has_joinspacefromidreq()) {
    clear_has_Msg();
    ::ServerData::JoinSpaceFromIdReq* temp = _impl_.Msg_.joinspacefromidreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.joinspacefromidreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::JoinSpaceFromIdReq& RelayClientMessage::_internal_joinspacefromidreq() const {
  return _internal_has_joinspacefromidreq()
      ? *_impl_.Msg_.joinspacefromidreq_
      : reinterpret_cast< ::ServerData::JoinSpaceFromIdReq&>(::ServerData::_JoinSpaceFromIdReq_default_instance_);
}
inline const ::ServerData::JoinSpaceFromIdReq& RelayClientMessage::joinspacefromidreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.JoinSpaceFromIdReq)
  return _internal_joinspacefromidreq();
}
inline ::ServerData::JoinSpaceFromIdReq* RelayClientMessage::unsafe_arena_release_joinspacefromidreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.JoinSpaceFromIdReq)
  if (_internal_has_joinspacefromidreq()) {
    clear_has_Msg();
    ::ServerData::JoinSpaceFromIdReq* temp = _impl_.Msg_.joinspacefromidreq_;
    _impl_.Msg_.joinspacefromidreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_joinspacefromidreq(::ServerData::JoinSpaceFromIdReq* joinspacefromidreq) {
  clear_Msg();
  if (joinspacefromidreq) {
    set_has_joinspacefromidreq();
    _impl_.Msg_.joinspacefromidreq_ = joinspacefromidreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.JoinSpaceFromIdReq)
}
inline ::ServerData::JoinSpaceFromIdReq* RelayClientMessage::_internal_mutable_joinspacefromidreq() {
  if (!_internal_has_joinspacefromidreq()) {
    clear_Msg();
    set_has_joinspacefromidreq();
    _impl_.Msg_.joinspacefromidreq_ = CreateMaybeMessage< ::ServerData::JoinSpaceFromIdReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.joinspacefromidreq_;
}
inline ::ServerData::JoinSpaceFromIdReq* RelayClientMessage::mutable_joinspacefromidreq() {
  ::ServerData::JoinSpaceFromIdReq* _msg = _internal_mutable_joinspacefromidreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.JoinSpaceFromIdReq)
  return _msg;
}

// .ServerData.ShutdownSpaceConnectionReq ShutdownSpaceConnectionReq = 21;
inline bool RelayClientMessage::_internal_has_shutdownspaceconnectionreq() const {
  return Msg_case() == kShutdownSpaceConnectionReq;
}
inline bool RelayClientMessage::has_shutdownspaceconnectionreq() const {
  return _internal_has_shutdownspaceconnectionreq();
}
inline void RelayClientMessage::set_has_shutdownspaceconnectionreq() {
  _impl_._oneof_case_[0] = kShutdownSpaceConnectionReq;
}
inline void RelayClientMessage::clear_shutdownspaceconnectionreq() {
  if (_internal_has_shutdownspaceconnectionreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.shutdownspaceconnectionreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ShutdownSpaceConnectionReq* RelayClientMessage::release_shutdownspaceconnectionreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.ShutdownSpaceConnectionReq)
  if (_internal_has_shutdownspaceconnectionreq()) {
    clear_has_Msg();
    ::ServerData::ShutdownSpaceConnectionReq* temp = _impl_.Msg_.shutdownspaceconnectionreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.shutdownspaceconnectionreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ShutdownSpaceConnectionReq& RelayClientMessage::_internal_shutdownspaceconnectionreq() const {
  return _internal_has_shutdownspaceconnectionreq()
      ? *_impl_.Msg_.shutdownspaceconnectionreq_
      : reinterpret_cast< ::ServerData::ShutdownSpaceConnectionReq&>(::ServerData::_ShutdownSpaceConnectionReq_default_instance_);
}
inline const ::ServerData::ShutdownSpaceConnectionReq& RelayClientMessage::shutdownspaceconnectionreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.ShutdownSpaceConnectionReq)
  return _internal_shutdownspaceconnectionreq();
}
inline ::ServerData::ShutdownSpaceConnectionReq* RelayClientMessage::unsafe_arena_release_shutdownspaceconnectionreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.ShutdownSpaceConnectionReq)
  if (_internal_has_shutdownspaceconnectionreq()) {
    clear_has_Msg();
    ::ServerData::ShutdownSpaceConnectionReq* temp = _impl_.Msg_.shutdownspaceconnectionreq_;
    _impl_.Msg_.shutdownspaceconnectionreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_shutdownspaceconnectionreq(::ServerData::ShutdownSpaceConnectionReq* shutdownspaceconnectionreq) {
  clear_Msg();
  if (shutdownspaceconnectionreq) {
    set_has_shutdownspaceconnectionreq();
    _impl_.Msg_.shutdownspaceconnectionreq_ = shutdownspaceconnectionreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.ShutdownSpaceConnectionReq)
}
inline ::ServerData::ShutdownSpaceConnectionReq* RelayClientMessage::_internal_mutable_shutdownspaceconnectionreq() {
  if (!_internal_has_shutdownspaceconnectionreq()) {
    clear_Msg();
    set_has_shutdownspaceconnectionreq();
    _impl_.Msg_.shutdownspaceconnectionreq_ = CreateMaybeMessage< ::ServerData::ShutdownSpaceConnectionReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.shutdownspaceconnectionreq_;
}
inline ::ServerData::ShutdownSpaceConnectionReq* RelayClientMessage::mutable_shutdownspaceconnectionreq() {
  ::ServerData::ShutdownSpaceConnectionReq* _msg = _internal_mutable_shutdownspaceconnectionreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.ShutdownSpaceConnectionReq)
  return _msg;
}

// .ServerData.CreateSpaceReq CreateSpaceReq = 22;
inline bool RelayClientMessage::_internal_has_createspacereq() const {
  return Msg_case() == kCreateSpaceReq;
}
inline bool RelayClientMessage::has_createspacereq() const {
  return _internal_has_createspacereq();
}
inline void RelayClientMessage::set_has_createspacereq() {
  _impl_._oneof_case_[0] = kCreateSpaceReq;
}
inline void RelayClientMessage::clear_createspacereq() {
  if (_internal_has_createspacereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.createspacereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::CreateSpaceReq* RelayClientMessage::release_createspacereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.CreateSpaceReq)
  if (_internal_has_createspacereq()) {
    clear_has_Msg();
    ::ServerData::CreateSpaceReq* temp = _impl_.Msg_.createspacereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.createspacereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::CreateSpaceReq& RelayClientMessage::_internal_createspacereq() const {
  return _internal_has_createspacereq()
      ? *_impl_.Msg_.createspacereq_
      : reinterpret_cast< ::ServerData::CreateSpaceReq&>(::ServerData::_CreateSpaceReq_default_instance_);
}
inline const ::ServerData::CreateSpaceReq& RelayClientMessage::createspacereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.CreateSpaceReq)
  return _internal_createspacereq();
}
inline ::ServerData::CreateSpaceReq* RelayClientMessage::unsafe_arena_release_createspacereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.CreateSpaceReq)
  if (_internal_has_createspacereq()) {
    clear_has_Msg();
    ::ServerData::CreateSpaceReq* temp = _impl_.Msg_.createspacereq_;
    _impl_.Msg_.createspacereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_createspacereq(::ServerData::CreateSpaceReq* createspacereq) {
  clear_Msg();
  if (createspacereq) {
    set_has_createspacereq();
    _impl_.Msg_.createspacereq_ = createspacereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.CreateSpaceReq)
}
inline ::ServerData::CreateSpaceReq* RelayClientMessage::_internal_mutable_createspacereq() {
  if (!_internal_has_createspacereq()) {
    clear_Msg();
    set_has_createspacereq();
    _impl_.Msg_.createspacereq_ = CreateMaybeMessage< ::ServerData::CreateSpaceReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.createspacereq_;
}
inline ::ServerData::CreateSpaceReq* RelayClientMessage::mutable_createspacereq() {
  ::ServerData::CreateSpaceReq* _msg = _internal_mutable_createspacereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.CreateSpaceReq)
  return _msg;
}

// .ServerData.FetchAllUserAccountsReq FetchAllUserAccountsReq = 23;
inline bool RelayClientMessage::_internal_has_fetchalluseraccountsreq() const {
  return Msg_case() == kFetchAllUserAccountsReq;
}
inline bool RelayClientMessage::has_fetchalluseraccountsreq() const {
  return _internal_has_fetchalluseraccountsreq();
}
inline void RelayClientMessage::set_has_fetchalluseraccountsreq() {
  _impl_._oneof_case_[0] = kFetchAllUserAccountsReq;
}
inline void RelayClientMessage::clear_fetchalluseraccountsreq() {
  if (_internal_has_fetchalluseraccountsreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchalluseraccountsreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchAllUserAccountsReq* RelayClientMessage::release_fetchalluseraccountsreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.FetchAllUserAccountsReq)
  if (_internal_has_fetchalluseraccountsreq()) {
    clear_has_Msg();
    ::ServerData::FetchAllUserAccountsReq* temp = _impl_.Msg_.fetchalluseraccountsreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchalluseraccountsreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchAllUserAccountsReq& RelayClientMessage::_internal_fetchalluseraccountsreq() const {
  return _internal_has_fetchalluseraccountsreq()
      ? *_impl_.Msg_.fetchalluseraccountsreq_
      : reinterpret_cast< ::ServerData::FetchAllUserAccountsReq&>(::ServerData::_FetchAllUserAccountsReq_default_instance_);
}
inline const ::ServerData::FetchAllUserAccountsReq& RelayClientMessage::fetchalluseraccountsreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.FetchAllUserAccountsReq)
  return _internal_fetchalluseraccountsreq();
}
inline ::ServerData::FetchAllUserAccountsReq* RelayClientMessage::unsafe_arena_release_fetchalluseraccountsreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.FetchAllUserAccountsReq)
  if (_internal_has_fetchalluseraccountsreq()) {
    clear_has_Msg();
    ::ServerData::FetchAllUserAccountsReq* temp = _impl_.Msg_.fetchalluseraccountsreq_;
    _impl_.Msg_.fetchalluseraccountsreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_fetchalluseraccountsreq(::ServerData::FetchAllUserAccountsReq* fetchalluseraccountsreq) {
  clear_Msg();
  if (fetchalluseraccountsreq) {
    set_has_fetchalluseraccountsreq();
    _impl_.Msg_.fetchalluseraccountsreq_ = fetchalluseraccountsreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.FetchAllUserAccountsReq)
}
inline ::ServerData::FetchAllUserAccountsReq* RelayClientMessage::_internal_mutable_fetchalluseraccountsreq() {
  if (!_internal_has_fetchalluseraccountsreq()) {
    clear_Msg();
    set_has_fetchalluseraccountsreq();
    _impl_.Msg_.fetchalluseraccountsreq_ = CreateMaybeMessage< ::ServerData::FetchAllUserAccountsReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchalluseraccountsreq_;
}
inline ::ServerData::FetchAllUserAccountsReq* RelayClientMessage::mutable_fetchalluseraccountsreq() {
  ::ServerData::FetchAllUserAccountsReq* _msg = _internal_mutable_fetchalluseraccountsreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.FetchAllUserAccountsReq)
  return _msg;
}

// .ServerData.InviteUserAccountToSpaceReq InviteUserAccountToSpaceReq = 24;
inline bool RelayClientMessage::_internal_has_inviteuseraccounttospacereq() const {
  return Msg_case() == kInviteUserAccountToSpaceReq;
}
inline bool RelayClientMessage::has_inviteuseraccounttospacereq() const {
  return _internal_has_inviteuseraccounttospacereq();
}
inline void RelayClientMessage::set_has_inviteuseraccounttospacereq() {
  _impl_._oneof_case_[0] = kInviteUserAccountToSpaceReq;
}
inline void RelayClientMessage::clear_inviteuseraccounttospacereq() {
  if (_internal_has_inviteuseraccounttospacereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.inviteuseraccounttospacereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::InviteUserAccountToSpaceReq* RelayClientMessage::release_inviteuseraccounttospacereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.InviteUserAccountToSpaceReq)
  if (_internal_has_inviteuseraccounttospacereq()) {
    clear_has_Msg();
    ::ServerData::InviteUserAccountToSpaceReq* temp = _impl_.Msg_.inviteuseraccounttospacereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.inviteuseraccounttospacereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::InviteUserAccountToSpaceReq& RelayClientMessage::_internal_inviteuseraccounttospacereq() const {
  return _internal_has_inviteuseraccounttospacereq()
      ? *_impl_.Msg_.inviteuseraccounttospacereq_
      : reinterpret_cast< ::ServerData::InviteUserAccountToSpaceReq&>(::ServerData::_InviteUserAccountToSpaceReq_default_instance_);
}
inline const ::ServerData::InviteUserAccountToSpaceReq& RelayClientMessage::inviteuseraccounttospacereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.InviteUserAccountToSpaceReq)
  return _internal_inviteuseraccounttospacereq();
}
inline ::ServerData::InviteUserAccountToSpaceReq* RelayClientMessage::unsafe_arena_release_inviteuseraccounttospacereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.InviteUserAccountToSpaceReq)
  if (_internal_has_inviteuseraccounttospacereq()) {
    clear_has_Msg();
    ::ServerData::InviteUserAccountToSpaceReq* temp = _impl_.Msg_.inviteuseraccounttospacereq_;
    _impl_.Msg_.inviteuseraccounttospacereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_inviteuseraccounttospacereq(::ServerData::InviteUserAccountToSpaceReq* inviteuseraccounttospacereq) {
  clear_Msg();
  if (inviteuseraccounttospacereq) {
    set_has_inviteuseraccounttospacereq();
    _impl_.Msg_.inviteuseraccounttospacereq_ = inviteuseraccounttospacereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.InviteUserAccountToSpaceReq)
}
inline ::ServerData::InviteUserAccountToSpaceReq* RelayClientMessage::_internal_mutable_inviteuseraccounttospacereq() {
  if (!_internal_has_inviteuseraccounttospacereq()) {
    clear_Msg();
    set_has_inviteuseraccounttospacereq();
    _impl_.Msg_.inviteuseraccounttospacereq_ = CreateMaybeMessage< ::ServerData::InviteUserAccountToSpaceReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.inviteuseraccounttospacereq_;
}
inline ::ServerData::InviteUserAccountToSpaceReq* RelayClientMessage::mutable_inviteuseraccounttospacereq() {
  ::ServerData::InviteUserAccountToSpaceReq* _msg = _internal_mutable_inviteuseraccounttospacereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.InviteUserAccountToSpaceReq)
  return _msg;
}

// .ServerData.RemoveUserAccountFromSpaceReq RemoveUserAccountFromSpaceReq = 25;
inline bool RelayClientMessage::_internal_has_removeuseraccountfromspacereq() const {
  return Msg_case() == kRemoveUserAccountFromSpaceReq;
}
inline bool RelayClientMessage::has_removeuseraccountfromspacereq() const {
  return _internal_has_removeuseraccountfromspacereq();
}
inline void RelayClientMessage::set_has_removeuseraccountfromspacereq() {
  _impl_._oneof_case_[0] = kRemoveUserAccountFromSpaceReq;
}
inline void RelayClientMessage::clear_removeuseraccountfromspacereq() {
  if (_internal_has_removeuseraccountfromspacereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.removeuseraccountfromspacereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::RemoveUserAccountFromSpaceReq* RelayClientMessage::release_removeuseraccountfromspacereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.RemoveUserAccountFromSpaceReq)
  if (_internal_has_removeuseraccountfromspacereq()) {
    clear_has_Msg();
    ::ServerData::RemoveUserAccountFromSpaceReq* temp = _impl_.Msg_.removeuseraccountfromspacereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.removeuseraccountfromspacereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::RemoveUserAccountFromSpaceReq& RelayClientMessage::_internal_removeuseraccountfromspacereq() const {
  return _internal_has_removeuseraccountfromspacereq()
      ? *_impl_.Msg_.removeuseraccountfromspacereq_
      : reinterpret_cast< ::ServerData::RemoveUserAccountFromSpaceReq&>(::ServerData::_RemoveUserAccountFromSpaceReq_default_instance_);
}
inline const ::ServerData::RemoveUserAccountFromSpaceReq& RelayClientMessage::removeuseraccountfromspacereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.RemoveUserAccountFromSpaceReq)
  return _internal_removeuseraccountfromspacereq();
}
inline ::ServerData::RemoveUserAccountFromSpaceReq* RelayClientMessage::unsafe_arena_release_removeuseraccountfromspacereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.RemoveUserAccountFromSpaceReq)
  if (_internal_has_removeuseraccountfromspacereq()) {
    clear_has_Msg();
    ::ServerData::RemoveUserAccountFromSpaceReq* temp = _impl_.Msg_.removeuseraccountfromspacereq_;
    _impl_.Msg_.removeuseraccountfromspacereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_removeuseraccountfromspacereq(::ServerData::RemoveUserAccountFromSpaceReq* removeuseraccountfromspacereq) {
  clear_Msg();
  if (removeuseraccountfromspacereq) {
    set_has_removeuseraccountfromspacereq();
    _impl_.Msg_.removeuseraccountfromspacereq_ = removeuseraccountfromspacereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.RemoveUserAccountFromSpaceReq)
}
inline ::ServerData::RemoveUserAccountFromSpaceReq* RelayClientMessage::_internal_mutable_removeuseraccountfromspacereq() {
  if (!_internal_has_removeuseraccountfromspacereq()) {
    clear_Msg();
    set_has_removeuseraccountfromspacereq();
    _impl_.Msg_.removeuseraccountfromspacereq_ = CreateMaybeMessage< ::ServerData::RemoveUserAccountFromSpaceReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.removeuseraccountfromspacereq_;
}
inline ::ServerData::RemoveUserAccountFromSpaceReq* RelayClientMessage::mutable_removeuseraccountfromspacereq() {
  ::ServerData::RemoveUserAccountFromSpaceReq* _msg = _internal_mutable_removeuseraccountfromspacereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.RemoveUserAccountFromSpaceReq)
  return _msg;
}

// .ServerData.FetchAllUserRolesReq FetchAllUserRolesReq = 26;
inline bool RelayClientMessage::_internal_has_fetchalluserrolesreq() const {
  return Msg_case() == kFetchAllUserRolesReq;
}
inline bool RelayClientMessage::has_fetchalluserrolesreq() const {
  return _internal_has_fetchalluserrolesreq();
}
inline void RelayClientMessage::set_has_fetchalluserrolesreq() {
  _impl_._oneof_case_[0] = kFetchAllUserRolesReq;
}
inline void RelayClientMessage::clear_fetchalluserrolesreq() {
  if (_internal_has_fetchalluserrolesreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchalluserrolesreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchAllUserRolesReq* RelayClientMessage::release_fetchalluserrolesreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.FetchAllUserRolesReq)
  if (_internal_has_fetchalluserrolesreq()) {
    clear_has_Msg();
    ::ServerData::FetchAllUserRolesReq* temp = _impl_.Msg_.fetchalluserrolesreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchalluserrolesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchAllUserRolesReq& RelayClientMessage::_internal_fetchalluserrolesreq() const {
  return _internal_has_fetchalluserrolesreq()
      ? *_impl_.Msg_.fetchalluserrolesreq_
      : reinterpret_cast< ::ServerData::FetchAllUserRolesReq&>(::ServerData::_FetchAllUserRolesReq_default_instance_);
}
inline const ::ServerData::FetchAllUserRolesReq& RelayClientMessage::fetchalluserrolesreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.FetchAllUserRolesReq)
  return _internal_fetchalluserrolesreq();
}
inline ::ServerData::FetchAllUserRolesReq* RelayClientMessage::unsafe_arena_release_fetchalluserrolesreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.FetchAllUserRolesReq)
  if (_internal_has_fetchalluserrolesreq()) {
    clear_has_Msg();
    ::ServerData::FetchAllUserRolesReq* temp = _impl_.Msg_.fetchalluserrolesreq_;
    _impl_.Msg_.fetchalluserrolesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_fetchalluserrolesreq(::ServerData::FetchAllUserRolesReq* fetchalluserrolesreq) {
  clear_Msg();
  if (fetchalluserrolesreq) {
    set_has_fetchalluserrolesreq();
    _impl_.Msg_.fetchalluserrolesreq_ = fetchalluserrolesreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.FetchAllUserRolesReq)
}
inline ::ServerData::FetchAllUserRolesReq* RelayClientMessage::_internal_mutable_fetchalluserrolesreq() {
  if (!_internal_has_fetchalluserrolesreq()) {
    clear_Msg();
    set_has_fetchalluserrolesreq();
    _impl_.Msg_.fetchalluserrolesreq_ = CreateMaybeMessage< ::ServerData::FetchAllUserRolesReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchalluserrolesreq_;
}
inline ::ServerData::FetchAllUserRolesReq* RelayClientMessage::mutable_fetchalluserrolesreq() {
  ::ServerData::FetchAllUserRolesReq* _msg = _internal_mutable_fetchalluserrolesreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.FetchAllUserRolesReq)
  return _msg;
}

// .ServerData.DeleteSpaceReq DeleteSpaceReq = 27;
inline bool RelayClientMessage::_internal_has_deletespacereq() const {
  return Msg_case() == kDeleteSpaceReq;
}
inline bool RelayClientMessage::has_deletespacereq() const {
  return _internal_has_deletespacereq();
}
inline void RelayClientMessage::set_has_deletespacereq() {
  _impl_._oneof_case_[0] = kDeleteSpaceReq;
}
inline void RelayClientMessage::clear_deletespacereq() {
  if (_internal_has_deletespacereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.deletespacereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::DeleteSpaceReq* RelayClientMessage::release_deletespacereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.DeleteSpaceReq)
  if (_internal_has_deletespacereq()) {
    clear_has_Msg();
    ::ServerData::DeleteSpaceReq* temp = _impl_.Msg_.deletespacereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.deletespacereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::DeleteSpaceReq& RelayClientMessage::_internal_deletespacereq() const {
  return _internal_has_deletespacereq()
      ? *_impl_.Msg_.deletespacereq_
      : reinterpret_cast< ::ServerData::DeleteSpaceReq&>(::ServerData::_DeleteSpaceReq_default_instance_);
}
inline const ::ServerData::DeleteSpaceReq& RelayClientMessage::deletespacereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.DeleteSpaceReq)
  return _internal_deletespacereq();
}
inline ::ServerData::DeleteSpaceReq* RelayClientMessage::unsafe_arena_release_deletespacereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.DeleteSpaceReq)
  if (_internal_has_deletespacereq()) {
    clear_has_Msg();
    ::ServerData::DeleteSpaceReq* temp = _impl_.Msg_.deletespacereq_;
    _impl_.Msg_.deletespacereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_deletespacereq(::ServerData::DeleteSpaceReq* deletespacereq) {
  clear_Msg();
  if (deletespacereq) {
    set_has_deletespacereq();
    _impl_.Msg_.deletespacereq_ = deletespacereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.DeleteSpaceReq)
}
inline ::ServerData::DeleteSpaceReq* RelayClientMessage::_internal_mutable_deletespacereq() {
  if (!_internal_has_deletespacereq()) {
    clear_Msg();
    set_has_deletespacereq();
    _impl_.Msg_.deletespacereq_ = CreateMaybeMessage< ::ServerData::DeleteSpaceReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.deletespacereq_;
}
inline ::ServerData::DeleteSpaceReq* RelayClientMessage::mutable_deletespacereq() {
  ::ServerData::DeleteSpaceReq* _msg = _internal_mutable_deletespacereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.DeleteSpaceReq)
  return _msg;
}

// .ServerData.RenameSpaceReq RenameSpaceReq = 28;
inline bool RelayClientMessage::_internal_has_renamespacereq() const {
  return Msg_case() == kRenameSpaceReq;
}
inline bool RelayClientMessage::has_renamespacereq() const {
  return _internal_has_renamespacereq();
}
inline void RelayClientMessage::set_has_renamespacereq() {
  _impl_._oneof_case_[0] = kRenameSpaceReq;
}
inline void RelayClientMessage::clear_renamespacereq() {
  if (_internal_has_renamespacereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.renamespacereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::RenameSpaceReq* RelayClientMessage::release_renamespacereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.RenameSpaceReq)
  if (_internal_has_renamespacereq()) {
    clear_has_Msg();
    ::ServerData::RenameSpaceReq* temp = _impl_.Msg_.renamespacereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.renamespacereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::RenameSpaceReq& RelayClientMessage::_internal_renamespacereq() const {
  return _internal_has_renamespacereq()
      ? *_impl_.Msg_.renamespacereq_
      : reinterpret_cast< ::ServerData::RenameSpaceReq&>(::ServerData::_RenameSpaceReq_default_instance_);
}
inline const ::ServerData::RenameSpaceReq& RelayClientMessage::renamespacereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.RenameSpaceReq)
  return _internal_renamespacereq();
}
inline ::ServerData::RenameSpaceReq* RelayClientMessage::unsafe_arena_release_renamespacereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.RenameSpaceReq)
  if (_internal_has_renamespacereq()) {
    clear_has_Msg();
    ::ServerData::RenameSpaceReq* temp = _impl_.Msg_.renamespacereq_;
    _impl_.Msg_.renamespacereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_renamespacereq(::ServerData::RenameSpaceReq* renamespacereq) {
  clear_Msg();
  if (renamespacereq) {
    set_has_renamespacereq();
    _impl_.Msg_.renamespacereq_ = renamespacereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.RenameSpaceReq)
}
inline ::ServerData::RenameSpaceReq* RelayClientMessage::_internal_mutable_renamespacereq() {
  if (!_internal_has_renamespacereq()) {
    clear_Msg();
    set_has_renamespacereq();
    _impl_.Msg_.renamespacereq_ = CreateMaybeMessage< ::ServerData::RenameSpaceReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.renamespacereq_;
}
inline ::ServerData::RenameSpaceReq* RelayClientMessage::mutable_renamespacereq() {
  ::ServerData::RenameSpaceReq* _msg = _internal_mutable_renamespacereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.RenameSpaceReq)
  return _msg;
}

// .ServerData.UpdateThumbnailForSpaceReq UpdateThumbnailForSpaceReq = 29;
inline bool RelayClientMessage::_internal_has_updatethumbnailforspacereq() const {
  return Msg_case() == kUpdateThumbnailForSpaceReq;
}
inline bool RelayClientMessage::has_updatethumbnailforspacereq() const {
  return _internal_has_updatethumbnailforspacereq();
}
inline void RelayClientMessage::set_has_updatethumbnailforspacereq() {
  _impl_._oneof_case_[0] = kUpdateThumbnailForSpaceReq;
}
inline void RelayClientMessage::clear_updatethumbnailforspacereq() {
  if (_internal_has_updatethumbnailforspacereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.updatethumbnailforspacereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UpdateThumbnailForSpaceReq* RelayClientMessage::release_updatethumbnailforspacereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.UpdateThumbnailForSpaceReq)
  if (_internal_has_updatethumbnailforspacereq()) {
    clear_has_Msg();
    ::ServerData::UpdateThumbnailForSpaceReq* temp = _impl_.Msg_.updatethumbnailforspacereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.updatethumbnailforspacereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UpdateThumbnailForSpaceReq& RelayClientMessage::_internal_updatethumbnailforspacereq() const {
  return _internal_has_updatethumbnailforspacereq()
      ? *_impl_.Msg_.updatethumbnailforspacereq_
      : reinterpret_cast< ::ServerData::UpdateThumbnailForSpaceReq&>(::ServerData::_UpdateThumbnailForSpaceReq_default_instance_);
}
inline const ::ServerData::UpdateThumbnailForSpaceReq& RelayClientMessage::updatethumbnailforspacereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.UpdateThumbnailForSpaceReq)
  return _internal_updatethumbnailforspacereq();
}
inline ::ServerData::UpdateThumbnailForSpaceReq* RelayClientMessage::unsafe_arena_release_updatethumbnailforspacereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.UpdateThumbnailForSpaceReq)
  if (_internal_has_updatethumbnailforspacereq()) {
    clear_has_Msg();
    ::ServerData::UpdateThumbnailForSpaceReq* temp = _impl_.Msg_.updatethumbnailforspacereq_;
    _impl_.Msg_.updatethumbnailforspacereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_updatethumbnailforspacereq(::ServerData::UpdateThumbnailForSpaceReq* updatethumbnailforspacereq) {
  clear_Msg();
  if (updatethumbnailforspacereq) {
    set_has_updatethumbnailforspacereq();
    _impl_.Msg_.updatethumbnailforspacereq_ = updatethumbnailforspacereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.UpdateThumbnailForSpaceReq)
}
inline ::ServerData::UpdateThumbnailForSpaceReq* RelayClientMessage::_internal_mutable_updatethumbnailforspacereq() {
  if (!_internal_has_updatethumbnailforspacereq()) {
    clear_Msg();
    set_has_updatethumbnailforspacereq();
    _impl_.Msg_.updatethumbnailforspacereq_ = CreateMaybeMessage< ::ServerData::UpdateThumbnailForSpaceReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.updatethumbnailforspacereq_;
}
inline ::ServerData::UpdateThumbnailForSpaceReq* RelayClientMessage::mutable_updatethumbnailforspacereq() {
  ::ServerData::UpdateThumbnailForSpaceReq* _msg = _internal_mutable_updatethumbnailforspacereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.UpdateThumbnailForSpaceReq)
  return _msg;
}

// .ServerData.GetAudioInputDevicesReq GetAudioInputDevicesReq = 30;
inline bool RelayClientMessage::_internal_has_getaudioinputdevicesreq() const {
  return Msg_case() == kGetAudioInputDevicesReq;
}
inline bool RelayClientMessage::has_getaudioinputdevicesreq() const {
  return _internal_has_getaudioinputdevicesreq();
}
inline void RelayClientMessage::set_has_getaudioinputdevicesreq() {
  _impl_._oneof_case_[0] = kGetAudioInputDevicesReq;
}
inline void RelayClientMessage::clear_getaudioinputdevicesreq() {
  if (_internal_has_getaudioinputdevicesreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.getaudioinputdevicesreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::GetAudioInputDevicesReq* RelayClientMessage::release_getaudioinputdevicesreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.GetAudioInputDevicesReq)
  if (_internal_has_getaudioinputdevicesreq()) {
    clear_has_Msg();
    ::ServerData::GetAudioInputDevicesReq* temp = _impl_.Msg_.getaudioinputdevicesreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.getaudioinputdevicesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::GetAudioInputDevicesReq& RelayClientMessage::_internal_getaudioinputdevicesreq() const {
  return _internal_has_getaudioinputdevicesreq()
      ? *_impl_.Msg_.getaudioinputdevicesreq_
      : reinterpret_cast< ::ServerData::GetAudioInputDevicesReq&>(::ServerData::_GetAudioInputDevicesReq_default_instance_);
}
inline const ::ServerData::GetAudioInputDevicesReq& RelayClientMessage::getaudioinputdevicesreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.GetAudioInputDevicesReq)
  return _internal_getaudioinputdevicesreq();
}
inline ::ServerData::GetAudioInputDevicesReq* RelayClientMessage::unsafe_arena_release_getaudioinputdevicesreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.GetAudioInputDevicesReq)
  if (_internal_has_getaudioinputdevicesreq()) {
    clear_has_Msg();
    ::ServerData::GetAudioInputDevicesReq* temp = _impl_.Msg_.getaudioinputdevicesreq_;
    _impl_.Msg_.getaudioinputdevicesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_getaudioinputdevicesreq(::ServerData::GetAudioInputDevicesReq* getaudioinputdevicesreq) {
  clear_Msg();
  if (getaudioinputdevicesreq) {
    set_has_getaudioinputdevicesreq();
    _impl_.Msg_.getaudioinputdevicesreq_ = getaudioinputdevicesreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.GetAudioInputDevicesReq)
}
inline ::ServerData::GetAudioInputDevicesReq* RelayClientMessage::_internal_mutable_getaudioinputdevicesreq() {
  if (!_internal_has_getaudioinputdevicesreq()) {
    clear_Msg();
    set_has_getaudioinputdevicesreq();
    _impl_.Msg_.getaudioinputdevicesreq_ = CreateMaybeMessage< ::ServerData::GetAudioInputDevicesReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.getaudioinputdevicesreq_;
}
inline ::ServerData::GetAudioInputDevicesReq* RelayClientMessage::mutable_getaudioinputdevicesreq() {
  ::ServerData::GetAudioInputDevicesReq* _msg = _internal_mutable_getaudioinputdevicesreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.GetAudioInputDevicesReq)
  return _msg;
}

// .ServerData.GetAudioOutputDevicesReq GetAudioOutputDevicesReq = 31;
inline bool RelayClientMessage::_internal_has_getaudiooutputdevicesreq() const {
  return Msg_case() == kGetAudioOutputDevicesReq;
}
inline bool RelayClientMessage::has_getaudiooutputdevicesreq() const {
  return _internal_has_getaudiooutputdevicesreq();
}
inline void RelayClientMessage::set_has_getaudiooutputdevicesreq() {
  _impl_._oneof_case_[0] = kGetAudioOutputDevicesReq;
}
inline void RelayClientMessage::clear_getaudiooutputdevicesreq() {
  if (_internal_has_getaudiooutputdevicesreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.getaudiooutputdevicesreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::GetAudioOutputDevicesReq* RelayClientMessage::release_getaudiooutputdevicesreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.GetAudioOutputDevicesReq)
  if (_internal_has_getaudiooutputdevicesreq()) {
    clear_has_Msg();
    ::ServerData::GetAudioOutputDevicesReq* temp = _impl_.Msg_.getaudiooutputdevicesreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.getaudiooutputdevicesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::GetAudioOutputDevicesReq& RelayClientMessage::_internal_getaudiooutputdevicesreq() const {
  return _internal_has_getaudiooutputdevicesreq()
      ? *_impl_.Msg_.getaudiooutputdevicesreq_
      : reinterpret_cast< ::ServerData::GetAudioOutputDevicesReq&>(::ServerData::_GetAudioOutputDevicesReq_default_instance_);
}
inline const ::ServerData::GetAudioOutputDevicesReq& RelayClientMessage::getaudiooutputdevicesreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.GetAudioOutputDevicesReq)
  return _internal_getaudiooutputdevicesreq();
}
inline ::ServerData::GetAudioOutputDevicesReq* RelayClientMessage::unsafe_arena_release_getaudiooutputdevicesreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.GetAudioOutputDevicesReq)
  if (_internal_has_getaudiooutputdevicesreq()) {
    clear_has_Msg();
    ::ServerData::GetAudioOutputDevicesReq* temp = _impl_.Msg_.getaudiooutputdevicesreq_;
    _impl_.Msg_.getaudiooutputdevicesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_getaudiooutputdevicesreq(::ServerData::GetAudioOutputDevicesReq* getaudiooutputdevicesreq) {
  clear_Msg();
  if (getaudiooutputdevicesreq) {
    set_has_getaudiooutputdevicesreq();
    _impl_.Msg_.getaudiooutputdevicesreq_ = getaudiooutputdevicesreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.GetAudioOutputDevicesReq)
}
inline ::ServerData::GetAudioOutputDevicesReq* RelayClientMessage::_internal_mutable_getaudiooutputdevicesreq() {
  if (!_internal_has_getaudiooutputdevicesreq()) {
    clear_Msg();
    set_has_getaudiooutputdevicesreq();
    _impl_.Msg_.getaudiooutputdevicesreq_ = CreateMaybeMessage< ::ServerData::GetAudioOutputDevicesReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.getaudiooutputdevicesreq_;
}
inline ::ServerData::GetAudioOutputDevicesReq* RelayClientMessage::mutable_getaudiooutputdevicesreq() {
  ::ServerData::GetAudioOutputDevicesReq* _msg = _internal_mutable_getaudiooutputdevicesreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.GetAudioOutputDevicesReq)
  return _msg;
}

// .ServerData.GetVideoInputDevicesReq GetVideoInputDevicesReq = 32;
inline bool RelayClientMessage::_internal_has_getvideoinputdevicesreq() const {
  return Msg_case() == kGetVideoInputDevicesReq;
}
inline bool RelayClientMessage::has_getvideoinputdevicesreq() const {
  return _internal_has_getvideoinputdevicesreq();
}
inline void RelayClientMessage::set_has_getvideoinputdevicesreq() {
  _impl_._oneof_case_[0] = kGetVideoInputDevicesReq;
}
inline void RelayClientMessage::clear_getvideoinputdevicesreq() {
  if (_internal_has_getvideoinputdevicesreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.getvideoinputdevicesreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::GetVideoInputDevicesReq* RelayClientMessage::release_getvideoinputdevicesreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.GetVideoInputDevicesReq)
  if (_internal_has_getvideoinputdevicesreq()) {
    clear_has_Msg();
    ::ServerData::GetVideoInputDevicesReq* temp = _impl_.Msg_.getvideoinputdevicesreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.getvideoinputdevicesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::GetVideoInputDevicesReq& RelayClientMessage::_internal_getvideoinputdevicesreq() const {
  return _internal_has_getvideoinputdevicesreq()
      ? *_impl_.Msg_.getvideoinputdevicesreq_
      : reinterpret_cast< ::ServerData::GetVideoInputDevicesReq&>(::ServerData::_GetVideoInputDevicesReq_default_instance_);
}
inline const ::ServerData::GetVideoInputDevicesReq& RelayClientMessage::getvideoinputdevicesreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.GetVideoInputDevicesReq)
  return _internal_getvideoinputdevicesreq();
}
inline ::ServerData::GetVideoInputDevicesReq* RelayClientMessage::unsafe_arena_release_getvideoinputdevicesreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.GetVideoInputDevicesReq)
  if (_internal_has_getvideoinputdevicesreq()) {
    clear_has_Msg();
    ::ServerData::GetVideoInputDevicesReq* temp = _impl_.Msg_.getvideoinputdevicesreq_;
    _impl_.Msg_.getvideoinputdevicesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_getvideoinputdevicesreq(::ServerData::GetVideoInputDevicesReq* getvideoinputdevicesreq) {
  clear_Msg();
  if (getvideoinputdevicesreq) {
    set_has_getvideoinputdevicesreq();
    _impl_.Msg_.getvideoinputdevicesreq_ = getvideoinputdevicesreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.GetVideoInputDevicesReq)
}
inline ::ServerData::GetVideoInputDevicesReq* RelayClientMessage::_internal_mutable_getvideoinputdevicesreq() {
  if (!_internal_has_getvideoinputdevicesreq()) {
    clear_Msg();
    set_has_getvideoinputdevicesreq();
    _impl_.Msg_.getvideoinputdevicesreq_ = CreateMaybeMessage< ::ServerData::GetVideoInputDevicesReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.getvideoinputdevicesreq_;
}
inline ::ServerData::GetVideoInputDevicesReq* RelayClientMessage::mutable_getvideoinputdevicesreq() {
  ::ServerData::GetVideoInputDevicesReq* _msg = _internal_mutable_getvideoinputdevicesreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.GetVideoInputDevicesReq)
  return _msg;
}

// .ServerData.SetAudioInputDeviceReq SetAudioInputDeviceReq = 33;
inline bool RelayClientMessage::_internal_has_setaudioinputdevicereq() const {
  return Msg_case() == kSetAudioInputDeviceReq;
}
inline bool RelayClientMessage::has_setaudioinputdevicereq() const {
  return _internal_has_setaudioinputdevicereq();
}
inline void RelayClientMessage::set_has_setaudioinputdevicereq() {
  _impl_._oneof_case_[0] = kSetAudioInputDeviceReq;
}
inline void RelayClientMessage::clear_setaudioinputdevicereq() {
  if (_internal_has_setaudioinputdevicereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.setaudioinputdevicereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::SetAudioInputDeviceReq* RelayClientMessage::release_setaudioinputdevicereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.SetAudioInputDeviceReq)
  if (_internal_has_setaudioinputdevicereq()) {
    clear_has_Msg();
    ::ServerData::SetAudioInputDeviceReq* temp = _impl_.Msg_.setaudioinputdevicereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.setaudioinputdevicereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::SetAudioInputDeviceReq& RelayClientMessage::_internal_setaudioinputdevicereq() const {
  return _internal_has_setaudioinputdevicereq()
      ? *_impl_.Msg_.setaudioinputdevicereq_
      : reinterpret_cast< ::ServerData::SetAudioInputDeviceReq&>(::ServerData::_SetAudioInputDeviceReq_default_instance_);
}
inline const ::ServerData::SetAudioInputDeviceReq& RelayClientMessage::setaudioinputdevicereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.SetAudioInputDeviceReq)
  return _internal_setaudioinputdevicereq();
}
inline ::ServerData::SetAudioInputDeviceReq* RelayClientMessage::unsafe_arena_release_setaudioinputdevicereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.SetAudioInputDeviceReq)
  if (_internal_has_setaudioinputdevicereq()) {
    clear_has_Msg();
    ::ServerData::SetAudioInputDeviceReq* temp = _impl_.Msg_.setaudioinputdevicereq_;
    _impl_.Msg_.setaudioinputdevicereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_setaudioinputdevicereq(::ServerData::SetAudioInputDeviceReq* setaudioinputdevicereq) {
  clear_Msg();
  if (setaudioinputdevicereq) {
    set_has_setaudioinputdevicereq();
    _impl_.Msg_.setaudioinputdevicereq_ = setaudioinputdevicereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.SetAudioInputDeviceReq)
}
inline ::ServerData::SetAudioInputDeviceReq* RelayClientMessage::_internal_mutable_setaudioinputdevicereq() {
  if (!_internal_has_setaudioinputdevicereq()) {
    clear_Msg();
    set_has_setaudioinputdevicereq();
    _impl_.Msg_.setaudioinputdevicereq_ = CreateMaybeMessage< ::ServerData::SetAudioInputDeviceReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.setaudioinputdevicereq_;
}
inline ::ServerData::SetAudioInputDeviceReq* RelayClientMessage::mutable_setaudioinputdevicereq() {
  ::ServerData::SetAudioInputDeviceReq* _msg = _internal_mutable_setaudioinputdevicereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.SetAudioInputDeviceReq)
  return _msg;
}

// .ServerData.SetAudioOutputDeviceReq SetAudioOutputDeviceReq = 34;
inline bool RelayClientMessage::_internal_has_setaudiooutputdevicereq() const {
  return Msg_case() == kSetAudioOutputDeviceReq;
}
inline bool RelayClientMessage::has_setaudiooutputdevicereq() const {
  return _internal_has_setaudiooutputdevicereq();
}
inline void RelayClientMessage::set_has_setaudiooutputdevicereq() {
  _impl_._oneof_case_[0] = kSetAudioOutputDeviceReq;
}
inline void RelayClientMessage::clear_setaudiooutputdevicereq() {
  if (_internal_has_setaudiooutputdevicereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.setaudiooutputdevicereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::SetAudioOutputDeviceReq* RelayClientMessage::release_setaudiooutputdevicereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.SetAudioOutputDeviceReq)
  if (_internal_has_setaudiooutputdevicereq()) {
    clear_has_Msg();
    ::ServerData::SetAudioOutputDeviceReq* temp = _impl_.Msg_.setaudiooutputdevicereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.setaudiooutputdevicereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::SetAudioOutputDeviceReq& RelayClientMessage::_internal_setaudiooutputdevicereq() const {
  return _internal_has_setaudiooutputdevicereq()
      ? *_impl_.Msg_.setaudiooutputdevicereq_
      : reinterpret_cast< ::ServerData::SetAudioOutputDeviceReq&>(::ServerData::_SetAudioOutputDeviceReq_default_instance_);
}
inline const ::ServerData::SetAudioOutputDeviceReq& RelayClientMessage::setaudiooutputdevicereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.SetAudioOutputDeviceReq)
  return _internal_setaudiooutputdevicereq();
}
inline ::ServerData::SetAudioOutputDeviceReq* RelayClientMessage::unsafe_arena_release_setaudiooutputdevicereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.SetAudioOutputDeviceReq)
  if (_internal_has_setaudiooutputdevicereq()) {
    clear_has_Msg();
    ::ServerData::SetAudioOutputDeviceReq* temp = _impl_.Msg_.setaudiooutputdevicereq_;
    _impl_.Msg_.setaudiooutputdevicereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_setaudiooutputdevicereq(::ServerData::SetAudioOutputDeviceReq* setaudiooutputdevicereq) {
  clear_Msg();
  if (setaudiooutputdevicereq) {
    set_has_setaudiooutputdevicereq();
    _impl_.Msg_.setaudiooutputdevicereq_ = setaudiooutputdevicereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.SetAudioOutputDeviceReq)
}
inline ::ServerData::SetAudioOutputDeviceReq* RelayClientMessage::_internal_mutable_setaudiooutputdevicereq() {
  if (!_internal_has_setaudiooutputdevicereq()) {
    clear_Msg();
    set_has_setaudiooutputdevicereq();
    _impl_.Msg_.setaudiooutputdevicereq_ = CreateMaybeMessage< ::ServerData::SetAudioOutputDeviceReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.setaudiooutputdevicereq_;
}
inline ::ServerData::SetAudioOutputDeviceReq* RelayClientMessage::mutable_setaudiooutputdevicereq() {
  ::ServerData::SetAudioOutputDeviceReq* _msg = _internal_mutable_setaudiooutputdevicereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.SetAudioOutputDeviceReq)
  return _msg;
}

// .ServerData.SetVideoInputDeviceReq SetVideoInputDeviceReq = 35;
inline bool RelayClientMessage::_internal_has_setvideoinputdevicereq() const {
  return Msg_case() == kSetVideoInputDeviceReq;
}
inline bool RelayClientMessage::has_setvideoinputdevicereq() const {
  return _internal_has_setvideoinputdevicereq();
}
inline void RelayClientMessage::set_has_setvideoinputdevicereq() {
  _impl_._oneof_case_[0] = kSetVideoInputDeviceReq;
}
inline void RelayClientMessage::clear_setvideoinputdevicereq() {
  if (_internal_has_setvideoinputdevicereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.setvideoinputdevicereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::SetVideoInputDeviceReq* RelayClientMessage::release_setvideoinputdevicereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.SetVideoInputDeviceReq)
  if (_internal_has_setvideoinputdevicereq()) {
    clear_has_Msg();
    ::ServerData::SetVideoInputDeviceReq* temp = _impl_.Msg_.setvideoinputdevicereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.setvideoinputdevicereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::SetVideoInputDeviceReq& RelayClientMessage::_internal_setvideoinputdevicereq() const {
  return _internal_has_setvideoinputdevicereq()
      ? *_impl_.Msg_.setvideoinputdevicereq_
      : reinterpret_cast< ::ServerData::SetVideoInputDeviceReq&>(::ServerData::_SetVideoInputDeviceReq_default_instance_);
}
inline const ::ServerData::SetVideoInputDeviceReq& RelayClientMessage::setvideoinputdevicereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.SetVideoInputDeviceReq)
  return _internal_setvideoinputdevicereq();
}
inline ::ServerData::SetVideoInputDeviceReq* RelayClientMessage::unsafe_arena_release_setvideoinputdevicereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.SetVideoInputDeviceReq)
  if (_internal_has_setvideoinputdevicereq()) {
    clear_has_Msg();
    ::ServerData::SetVideoInputDeviceReq* temp = _impl_.Msg_.setvideoinputdevicereq_;
    _impl_.Msg_.setvideoinputdevicereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_setvideoinputdevicereq(::ServerData::SetVideoInputDeviceReq* setvideoinputdevicereq) {
  clear_Msg();
  if (setvideoinputdevicereq) {
    set_has_setvideoinputdevicereq();
    _impl_.Msg_.setvideoinputdevicereq_ = setvideoinputdevicereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.SetVideoInputDeviceReq)
}
inline ::ServerData::SetVideoInputDeviceReq* RelayClientMessage::_internal_mutable_setvideoinputdevicereq() {
  if (!_internal_has_setvideoinputdevicereq()) {
    clear_Msg();
    set_has_setvideoinputdevicereq();
    _impl_.Msg_.setvideoinputdevicereq_ = CreateMaybeMessage< ::ServerData::SetVideoInputDeviceReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.setvideoinputdevicereq_;
}
inline ::ServerData::SetVideoInputDeviceReq* RelayClientMessage::mutable_setvideoinputdevicereq() {
  ::ServerData::SetVideoInputDeviceReq* _msg = _internal_mutable_setvideoinputdevicereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.SetVideoInputDeviceReq)
  return _msg;
}

// .ServerData.DefinePropertyDefaultValue DefinePropertyDefaultValue = 50;
inline bool RelayClientMessage::_internal_has_definepropertydefaultvalue() const {
  return Msg_case() == kDefinePropertyDefaultValue;
}
inline bool RelayClientMessage::has_definepropertydefaultvalue() const {
  return _internal_has_definepropertydefaultvalue();
}
inline void RelayClientMessage::set_has_definepropertydefaultvalue() {
  _impl_._oneof_case_[0] = kDefinePropertyDefaultValue;
}
inline void RelayClientMessage::clear_definepropertydefaultvalue() {
  if (_internal_has_definepropertydefaultvalue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.definepropertydefaultvalue_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::DefinePropertyDefaultValue* RelayClientMessage::release_definepropertydefaultvalue() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.DefinePropertyDefaultValue)
  if (_internal_has_definepropertydefaultvalue()) {
    clear_has_Msg();
    ::ServerData::DefinePropertyDefaultValue* temp = _impl_.Msg_.definepropertydefaultvalue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.definepropertydefaultvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::DefinePropertyDefaultValue& RelayClientMessage::_internal_definepropertydefaultvalue() const {
  return _internal_has_definepropertydefaultvalue()
      ? *_impl_.Msg_.definepropertydefaultvalue_
      : reinterpret_cast< ::ServerData::DefinePropertyDefaultValue&>(::ServerData::_DefinePropertyDefaultValue_default_instance_);
}
inline const ::ServerData::DefinePropertyDefaultValue& RelayClientMessage::definepropertydefaultvalue() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.DefinePropertyDefaultValue)
  return _internal_definepropertydefaultvalue();
}
inline ::ServerData::DefinePropertyDefaultValue* RelayClientMessage::unsafe_arena_release_definepropertydefaultvalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.DefinePropertyDefaultValue)
  if (_internal_has_definepropertydefaultvalue()) {
    clear_has_Msg();
    ::ServerData::DefinePropertyDefaultValue* temp = _impl_.Msg_.definepropertydefaultvalue_;
    _impl_.Msg_.definepropertydefaultvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_definepropertydefaultvalue(::ServerData::DefinePropertyDefaultValue* definepropertydefaultvalue) {
  clear_Msg();
  if (definepropertydefaultvalue) {
    set_has_definepropertydefaultvalue();
    _impl_.Msg_.definepropertydefaultvalue_ = definepropertydefaultvalue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.DefinePropertyDefaultValue)
}
inline ::ServerData::DefinePropertyDefaultValue* RelayClientMessage::_internal_mutable_definepropertydefaultvalue() {
  if (!_internal_has_definepropertydefaultvalue()) {
    clear_Msg();
    set_has_definepropertydefaultvalue();
    _impl_.Msg_.definepropertydefaultvalue_ = CreateMaybeMessage< ::ServerData::DefinePropertyDefaultValue >(GetArenaForAllocation());
  }
  return _impl_.Msg_.definepropertydefaultvalue_;
}
inline ::ServerData::DefinePropertyDefaultValue* RelayClientMessage::mutable_definepropertydefaultvalue() {
  ::ServerData::DefinePropertyDefaultValue* _msg = _internal_mutable_definepropertydefaultvalue();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.DefinePropertyDefaultValue)
  return _msg;
}

// .ServerData.PostPropertyUpdate PostPropertyUpdate = 53;
inline bool RelayClientMessage::_internal_has_postpropertyupdate() const {
  return Msg_case() == kPostPropertyUpdate;
}
inline bool RelayClientMessage::has_postpropertyupdate() const {
  return _internal_has_postpropertyupdate();
}
inline void RelayClientMessage::set_has_postpropertyupdate() {
  _impl_._oneof_case_[0] = kPostPropertyUpdate;
}
inline void RelayClientMessage::clear_postpropertyupdate() {
  if (_internal_has_postpropertyupdate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.postpropertyupdate_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PostPropertyUpdate* RelayClientMessage::release_postpropertyupdate() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.PostPropertyUpdate)
  if (_internal_has_postpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::PostPropertyUpdate* temp = _impl_.Msg_.postpropertyupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.postpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PostPropertyUpdate& RelayClientMessage::_internal_postpropertyupdate() const {
  return _internal_has_postpropertyupdate()
      ? *_impl_.Msg_.postpropertyupdate_
      : reinterpret_cast< ::ServerData::PostPropertyUpdate&>(::ServerData::_PostPropertyUpdate_default_instance_);
}
inline const ::ServerData::PostPropertyUpdate& RelayClientMessage::postpropertyupdate() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.PostPropertyUpdate)
  return _internal_postpropertyupdate();
}
inline ::ServerData::PostPropertyUpdate* RelayClientMessage::unsafe_arena_release_postpropertyupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.PostPropertyUpdate)
  if (_internal_has_postpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::PostPropertyUpdate* temp = _impl_.Msg_.postpropertyupdate_;
    _impl_.Msg_.postpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_postpropertyupdate(::ServerData::PostPropertyUpdate* postpropertyupdate) {
  clear_Msg();
  if (postpropertyupdate) {
    set_has_postpropertyupdate();
    _impl_.Msg_.postpropertyupdate_ = postpropertyupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.PostPropertyUpdate)
}
inline ::ServerData::PostPropertyUpdate* RelayClientMessage::_internal_mutable_postpropertyupdate() {
  if (!_internal_has_postpropertyupdate()) {
    clear_Msg();
    set_has_postpropertyupdate();
    _impl_.Msg_.postpropertyupdate_ = CreateMaybeMessage< ::ServerData::PostPropertyUpdate >(GetArenaForAllocation());
  }
  return _impl_.Msg_.postpropertyupdate_;
}
inline ::ServerData::PostPropertyUpdate* RelayClientMessage::mutable_postpropertyupdate() {
  ::ServerData::PostPropertyUpdate* _msg = _internal_mutable_postpropertyupdate();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.PostPropertyUpdate)
  return _msg;
}

// .ServerData.BeginTransientPropertyUpdate BeginTransientPropertyUpdate = 54;
inline bool RelayClientMessage::_internal_has_begintransientpropertyupdate() const {
  return Msg_case() == kBeginTransientPropertyUpdate;
}
inline bool RelayClientMessage::has_begintransientpropertyupdate() const {
  return _internal_has_begintransientpropertyupdate();
}
inline void RelayClientMessage::set_has_begintransientpropertyupdate() {
  _impl_._oneof_case_[0] = kBeginTransientPropertyUpdate;
}
inline void RelayClientMessage::clear_begintransientpropertyupdate() {
  if (_internal_has_begintransientpropertyupdate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.begintransientpropertyupdate_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::BeginTransientPropertyUpdate* RelayClientMessage::release_begintransientpropertyupdate() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.BeginTransientPropertyUpdate)
  if (_internal_has_begintransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::BeginTransientPropertyUpdate* temp = _impl_.Msg_.begintransientpropertyupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.begintransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::BeginTransientPropertyUpdate& RelayClientMessage::_internal_begintransientpropertyupdate() const {
  return _internal_has_begintransientpropertyupdate()
      ? *_impl_.Msg_.begintransientpropertyupdate_
      : reinterpret_cast< ::ServerData::BeginTransientPropertyUpdate&>(::ServerData::_BeginTransientPropertyUpdate_default_instance_);
}
inline const ::ServerData::BeginTransientPropertyUpdate& RelayClientMessage::begintransientpropertyupdate() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.BeginTransientPropertyUpdate)
  return _internal_begintransientpropertyupdate();
}
inline ::ServerData::BeginTransientPropertyUpdate* RelayClientMessage::unsafe_arena_release_begintransientpropertyupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.BeginTransientPropertyUpdate)
  if (_internal_has_begintransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::BeginTransientPropertyUpdate* temp = _impl_.Msg_.begintransientpropertyupdate_;
    _impl_.Msg_.begintransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_begintransientpropertyupdate(::ServerData::BeginTransientPropertyUpdate* begintransientpropertyupdate) {
  clear_Msg();
  if (begintransientpropertyupdate) {
    set_has_begintransientpropertyupdate();
    _impl_.Msg_.begintransientpropertyupdate_ = begintransientpropertyupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.BeginTransientPropertyUpdate)
}
inline ::ServerData::BeginTransientPropertyUpdate* RelayClientMessage::_internal_mutable_begintransientpropertyupdate() {
  if (!_internal_has_begintransientpropertyupdate()) {
    clear_Msg();
    set_has_begintransientpropertyupdate();
    _impl_.Msg_.begintransientpropertyupdate_ = CreateMaybeMessage< ::ServerData::BeginTransientPropertyUpdate >(GetArenaForAllocation());
  }
  return _impl_.Msg_.begintransientpropertyupdate_;
}
inline ::ServerData::BeginTransientPropertyUpdate* RelayClientMessage::mutable_begintransientpropertyupdate() {
  ::ServerData::BeginTransientPropertyUpdate* _msg = _internal_mutable_begintransientpropertyupdate();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.BeginTransientPropertyUpdate)
  return _msg;
}

// .ServerData.ContinueTransientPropertyUpdate ContinueTransientPropertyUpdate = 55;
inline bool RelayClientMessage::_internal_has_continuetransientpropertyupdate() const {
  return Msg_case() == kContinueTransientPropertyUpdate;
}
inline bool RelayClientMessage::has_continuetransientpropertyupdate() const {
  return _internal_has_continuetransientpropertyupdate();
}
inline void RelayClientMessage::set_has_continuetransientpropertyupdate() {
  _impl_._oneof_case_[0] = kContinueTransientPropertyUpdate;
}
inline void RelayClientMessage::clear_continuetransientpropertyupdate() {
  if (_internal_has_continuetransientpropertyupdate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.continuetransientpropertyupdate_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ContinueTransientPropertyUpdate* RelayClientMessage::release_continuetransientpropertyupdate() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.ContinueTransientPropertyUpdate)
  if (_internal_has_continuetransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::ContinueTransientPropertyUpdate* temp = _impl_.Msg_.continuetransientpropertyupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.continuetransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ContinueTransientPropertyUpdate& RelayClientMessage::_internal_continuetransientpropertyupdate() const {
  return _internal_has_continuetransientpropertyupdate()
      ? *_impl_.Msg_.continuetransientpropertyupdate_
      : reinterpret_cast< ::ServerData::ContinueTransientPropertyUpdate&>(::ServerData::_ContinueTransientPropertyUpdate_default_instance_);
}
inline const ::ServerData::ContinueTransientPropertyUpdate& RelayClientMessage::continuetransientpropertyupdate() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.ContinueTransientPropertyUpdate)
  return _internal_continuetransientpropertyupdate();
}
inline ::ServerData::ContinueTransientPropertyUpdate* RelayClientMessage::unsafe_arena_release_continuetransientpropertyupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.ContinueTransientPropertyUpdate)
  if (_internal_has_continuetransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::ContinueTransientPropertyUpdate* temp = _impl_.Msg_.continuetransientpropertyupdate_;
    _impl_.Msg_.continuetransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_continuetransientpropertyupdate(::ServerData::ContinueTransientPropertyUpdate* continuetransientpropertyupdate) {
  clear_Msg();
  if (continuetransientpropertyupdate) {
    set_has_continuetransientpropertyupdate();
    _impl_.Msg_.continuetransientpropertyupdate_ = continuetransientpropertyupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.ContinueTransientPropertyUpdate)
}
inline ::ServerData::ContinueTransientPropertyUpdate* RelayClientMessage::_internal_mutable_continuetransientpropertyupdate() {
  if (!_internal_has_continuetransientpropertyupdate()) {
    clear_Msg();
    set_has_continuetransientpropertyupdate();
    _impl_.Msg_.continuetransientpropertyupdate_ = CreateMaybeMessage< ::ServerData::ContinueTransientPropertyUpdate >(GetArenaForAllocation());
  }
  return _impl_.Msg_.continuetransientpropertyupdate_;
}
inline ::ServerData::ContinueTransientPropertyUpdate* RelayClientMessage::mutable_continuetransientpropertyupdate() {
  ::ServerData::ContinueTransientPropertyUpdate* _msg = _internal_mutable_continuetransientpropertyupdate();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.ContinueTransientPropertyUpdate)
  return _msg;
}

// .ServerData.FinalizeTransientPropertyUpdate FinalizeTransientPropertyUpdate = 56;
inline bool RelayClientMessage::_internal_has_finalizetransientpropertyupdate() const {
  return Msg_case() == kFinalizeTransientPropertyUpdate;
}
inline bool RelayClientMessage::has_finalizetransientpropertyupdate() const {
  return _internal_has_finalizetransientpropertyupdate();
}
inline void RelayClientMessage::set_has_finalizetransientpropertyupdate() {
  _impl_._oneof_case_[0] = kFinalizeTransientPropertyUpdate;
}
inline void RelayClientMessage::clear_finalizetransientpropertyupdate() {
  if (_internal_has_finalizetransientpropertyupdate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.finalizetransientpropertyupdate_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FinalizeTransientPropertyUpdate* RelayClientMessage::release_finalizetransientpropertyupdate() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.FinalizeTransientPropertyUpdate)
  if (_internal_has_finalizetransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::FinalizeTransientPropertyUpdate* temp = _impl_.Msg_.finalizetransientpropertyupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.finalizetransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FinalizeTransientPropertyUpdate& RelayClientMessage::_internal_finalizetransientpropertyupdate() const {
  return _internal_has_finalizetransientpropertyupdate()
      ? *_impl_.Msg_.finalizetransientpropertyupdate_
      : reinterpret_cast< ::ServerData::FinalizeTransientPropertyUpdate&>(::ServerData::_FinalizeTransientPropertyUpdate_default_instance_);
}
inline const ::ServerData::FinalizeTransientPropertyUpdate& RelayClientMessage::finalizetransientpropertyupdate() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.FinalizeTransientPropertyUpdate)
  return _internal_finalizetransientpropertyupdate();
}
inline ::ServerData::FinalizeTransientPropertyUpdate* RelayClientMessage::unsafe_arena_release_finalizetransientpropertyupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.FinalizeTransientPropertyUpdate)
  if (_internal_has_finalizetransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::FinalizeTransientPropertyUpdate* temp = _impl_.Msg_.finalizetransientpropertyupdate_;
    _impl_.Msg_.finalizetransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_finalizetransientpropertyupdate(::ServerData::FinalizeTransientPropertyUpdate* finalizetransientpropertyupdate) {
  clear_Msg();
  if (finalizetransientpropertyupdate) {
    set_has_finalizetransientpropertyupdate();
    _impl_.Msg_.finalizetransientpropertyupdate_ = finalizetransientpropertyupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.FinalizeTransientPropertyUpdate)
}
inline ::ServerData::FinalizeTransientPropertyUpdate* RelayClientMessage::_internal_mutable_finalizetransientpropertyupdate() {
  if (!_internal_has_finalizetransientpropertyupdate()) {
    clear_Msg();
    set_has_finalizetransientpropertyupdate();
    _impl_.Msg_.finalizetransientpropertyupdate_ = CreateMaybeMessage< ::ServerData::FinalizeTransientPropertyUpdate >(GetArenaForAllocation());
  }
  return _impl_.Msg_.finalizetransientpropertyupdate_;
}
inline ::ServerData::FinalizeTransientPropertyUpdate* RelayClientMessage::mutable_finalizetransientpropertyupdate() {
  ::ServerData::FinalizeTransientPropertyUpdate* _msg = _internal_mutable_finalizetransientpropertyupdate();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.FinalizeTransientPropertyUpdate)
  return _msg;
}

// .ServerData.CancelTransientPropertyUpdate CancelTransientPropertyUpdate = 57;
inline bool RelayClientMessage::_internal_has_canceltransientpropertyupdate() const {
  return Msg_case() == kCancelTransientPropertyUpdate;
}
inline bool RelayClientMessage::has_canceltransientpropertyupdate() const {
  return _internal_has_canceltransientpropertyupdate();
}
inline void RelayClientMessage::set_has_canceltransientpropertyupdate() {
  _impl_._oneof_case_[0] = kCancelTransientPropertyUpdate;
}
inline void RelayClientMessage::clear_canceltransientpropertyupdate() {
  if (_internal_has_canceltransientpropertyupdate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.canceltransientpropertyupdate_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::CancelTransientPropertyUpdate* RelayClientMessage::release_canceltransientpropertyupdate() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.CancelTransientPropertyUpdate)
  if (_internal_has_canceltransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::CancelTransientPropertyUpdate* temp = _impl_.Msg_.canceltransientpropertyupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.canceltransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::CancelTransientPropertyUpdate& RelayClientMessage::_internal_canceltransientpropertyupdate() const {
  return _internal_has_canceltransientpropertyupdate()
      ? *_impl_.Msg_.canceltransientpropertyupdate_
      : reinterpret_cast< ::ServerData::CancelTransientPropertyUpdate&>(::ServerData::_CancelTransientPropertyUpdate_default_instance_);
}
inline const ::ServerData::CancelTransientPropertyUpdate& RelayClientMessage::canceltransientpropertyupdate() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.CancelTransientPropertyUpdate)
  return _internal_canceltransientpropertyupdate();
}
inline ::ServerData::CancelTransientPropertyUpdate* RelayClientMessage::unsafe_arena_release_canceltransientpropertyupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.CancelTransientPropertyUpdate)
  if (_internal_has_canceltransientpropertyupdate()) {
    clear_has_Msg();
    ::ServerData::CancelTransientPropertyUpdate* temp = _impl_.Msg_.canceltransientpropertyupdate_;
    _impl_.Msg_.canceltransientpropertyupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_canceltransientpropertyupdate(::ServerData::CancelTransientPropertyUpdate* canceltransientpropertyupdate) {
  clear_Msg();
  if (canceltransientpropertyupdate) {
    set_has_canceltransientpropertyupdate();
    _impl_.Msg_.canceltransientpropertyupdate_ = canceltransientpropertyupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.CancelTransientPropertyUpdate)
}
inline ::ServerData::CancelTransientPropertyUpdate* RelayClientMessage::_internal_mutable_canceltransientpropertyupdate() {
  if (!_internal_has_canceltransientpropertyupdate()) {
    clear_Msg();
    set_has_canceltransientpropertyupdate();
    _impl_.Msg_.canceltransientpropertyupdate_ = CreateMaybeMessage< ::ServerData::CancelTransientPropertyUpdate >(GetArenaForAllocation());
  }
  return _impl_.Msg_.canceltransientpropertyupdate_;
}
inline ::ServerData::CancelTransientPropertyUpdate* RelayClientMessage::mutable_canceltransientpropertyupdate() {
  ::ServerData::CancelTransientPropertyUpdate* _msg = _internal_mutable_canceltransientpropertyupdate();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.CancelTransientPropertyUpdate)
  return _msg;
}

// .ServerData.UpdateLocalUserMuted UpdateLocalUserMuted = 60;
inline bool RelayClientMessage::_internal_has_updatelocalusermuted() const {
  return Msg_case() == kUpdateLocalUserMuted;
}
inline bool RelayClientMessage::has_updatelocalusermuted() const {
  return _internal_has_updatelocalusermuted();
}
inline void RelayClientMessage::set_has_updatelocalusermuted() {
  _impl_._oneof_case_[0] = kUpdateLocalUserMuted;
}
inline void RelayClientMessage::clear_updatelocalusermuted() {
  if (_internal_has_updatelocalusermuted()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.updatelocalusermuted_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UpdateLocalUserMuted* RelayClientMessage::release_updatelocalusermuted() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.UpdateLocalUserMuted)
  if (_internal_has_updatelocalusermuted()) {
    clear_has_Msg();
    ::ServerData::UpdateLocalUserMuted* temp = _impl_.Msg_.updatelocalusermuted_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.updatelocalusermuted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UpdateLocalUserMuted& RelayClientMessage::_internal_updatelocalusermuted() const {
  return _internal_has_updatelocalusermuted()
      ? *_impl_.Msg_.updatelocalusermuted_
      : reinterpret_cast< ::ServerData::UpdateLocalUserMuted&>(::ServerData::_UpdateLocalUserMuted_default_instance_);
}
inline const ::ServerData::UpdateLocalUserMuted& RelayClientMessage::updatelocalusermuted() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.UpdateLocalUserMuted)
  return _internal_updatelocalusermuted();
}
inline ::ServerData::UpdateLocalUserMuted* RelayClientMessage::unsafe_arena_release_updatelocalusermuted() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.UpdateLocalUserMuted)
  if (_internal_has_updatelocalusermuted()) {
    clear_has_Msg();
    ::ServerData::UpdateLocalUserMuted* temp = _impl_.Msg_.updatelocalusermuted_;
    _impl_.Msg_.updatelocalusermuted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_updatelocalusermuted(::ServerData::UpdateLocalUserMuted* updatelocalusermuted) {
  clear_Msg();
  if (updatelocalusermuted) {
    set_has_updatelocalusermuted();
    _impl_.Msg_.updatelocalusermuted_ = updatelocalusermuted;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.UpdateLocalUserMuted)
}
inline ::ServerData::UpdateLocalUserMuted* RelayClientMessage::_internal_mutable_updatelocalusermuted() {
  if (!_internal_has_updatelocalusermuted()) {
    clear_Msg();
    set_has_updatelocalusermuted();
    _impl_.Msg_.updatelocalusermuted_ = CreateMaybeMessage< ::ServerData::UpdateLocalUserMuted >(GetArenaForAllocation());
  }
  return _impl_.Msg_.updatelocalusermuted_;
}
inline ::ServerData::UpdateLocalUserMuted* RelayClientMessage::mutable_updatelocalusermuted() {
  ::ServerData::UpdateLocalUserMuted* _msg = _internal_mutable_updatelocalusermuted();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.UpdateLocalUserMuted)
  return _msg;
}

// .ServerData.UpdateLocalUserCoPresence UpdateLocalUserCoPresence = 61;
inline bool RelayClientMessage::_internal_has_updatelocalusercopresence() const {
  return Msg_case() == kUpdateLocalUserCoPresence;
}
inline bool RelayClientMessage::has_updatelocalusercopresence() const {
  return _internal_has_updatelocalusercopresence();
}
inline void RelayClientMessage::set_has_updatelocalusercopresence() {
  _impl_._oneof_case_[0] = kUpdateLocalUserCoPresence;
}
inline void RelayClientMessage::clear_updatelocalusercopresence() {
  if (_internal_has_updatelocalusercopresence()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.updatelocalusercopresence_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UpdateLocalUserCoPresence* RelayClientMessage::release_updatelocalusercopresence() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.UpdateLocalUserCoPresence)
  if (_internal_has_updatelocalusercopresence()) {
    clear_has_Msg();
    ::ServerData::UpdateLocalUserCoPresence* temp = _impl_.Msg_.updatelocalusercopresence_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.updatelocalusercopresence_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UpdateLocalUserCoPresence& RelayClientMessage::_internal_updatelocalusercopresence() const {
  return _internal_has_updatelocalusercopresence()
      ? *_impl_.Msg_.updatelocalusercopresence_
      : reinterpret_cast< ::ServerData::UpdateLocalUserCoPresence&>(::ServerData::_UpdateLocalUserCoPresence_default_instance_);
}
inline const ::ServerData::UpdateLocalUserCoPresence& RelayClientMessage::updatelocalusercopresence() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.UpdateLocalUserCoPresence)
  return _internal_updatelocalusercopresence();
}
inline ::ServerData::UpdateLocalUserCoPresence* RelayClientMessage::unsafe_arena_release_updatelocalusercopresence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.UpdateLocalUserCoPresence)
  if (_internal_has_updatelocalusercopresence()) {
    clear_has_Msg();
    ::ServerData::UpdateLocalUserCoPresence* temp = _impl_.Msg_.updatelocalusercopresence_;
    _impl_.Msg_.updatelocalusercopresence_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_updatelocalusercopresence(::ServerData::UpdateLocalUserCoPresence* updatelocalusercopresence) {
  clear_Msg();
  if (updatelocalusercopresence) {
    set_has_updatelocalusercopresence();
    _impl_.Msg_.updatelocalusercopresence_ = updatelocalusercopresence;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.UpdateLocalUserCoPresence)
}
inline ::ServerData::UpdateLocalUserCoPresence* RelayClientMessage::_internal_mutable_updatelocalusercopresence() {
  if (!_internal_has_updatelocalusercopresence()) {
    clear_Msg();
    set_has_updatelocalusercopresence();
    _impl_.Msg_.updatelocalusercopresence_ = CreateMaybeMessage< ::ServerData::UpdateLocalUserCoPresence >(GetArenaForAllocation());
  }
  return _impl_.Msg_.updatelocalusercopresence_;
}
inline ::ServerData::UpdateLocalUserCoPresence* RelayClientMessage::mutable_updatelocalusercopresence() {
  ::ServerData::UpdateLocalUserCoPresence* _msg = _internal_mutable_updatelocalusercopresence();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.UpdateLocalUserCoPresence)
  return _msg;
}

// .ServerData.UpdateLocalUserStreamState UpdateLocalUserStreamState = 62;
inline bool RelayClientMessage::_internal_has_updatelocaluserstreamstate() const {
  return Msg_case() == kUpdateLocalUserStreamState;
}
inline bool RelayClientMessage::has_updatelocaluserstreamstate() const {
  return _internal_has_updatelocaluserstreamstate();
}
inline void RelayClientMessage::set_has_updatelocaluserstreamstate() {
  _impl_._oneof_case_[0] = kUpdateLocalUserStreamState;
}
inline void RelayClientMessage::clear_updatelocaluserstreamstate() {
  if (_internal_has_updatelocaluserstreamstate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.updatelocaluserstreamstate_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UpdateLocalUserStreamState* RelayClientMessage::release_updatelocaluserstreamstate() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.UpdateLocalUserStreamState)
  if (_internal_has_updatelocaluserstreamstate()) {
    clear_has_Msg();
    ::ServerData::UpdateLocalUserStreamState* temp = _impl_.Msg_.updatelocaluserstreamstate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.updatelocaluserstreamstate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UpdateLocalUserStreamState& RelayClientMessage::_internal_updatelocaluserstreamstate() const {
  return _internal_has_updatelocaluserstreamstate()
      ? *_impl_.Msg_.updatelocaluserstreamstate_
      : reinterpret_cast< ::ServerData::UpdateLocalUserStreamState&>(::ServerData::_UpdateLocalUserStreamState_default_instance_);
}
inline const ::ServerData::UpdateLocalUserStreamState& RelayClientMessage::updatelocaluserstreamstate() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.UpdateLocalUserStreamState)
  return _internal_updatelocaluserstreamstate();
}
inline ::ServerData::UpdateLocalUserStreamState* RelayClientMessage::unsafe_arena_release_updatelocaluserstreamstate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.UpdateLocalUserStreamState)
  if (_internal_has_updatelocaluserstreamstate()) {
    clear_has_Msg();
    ::ServerData::UpdateLocalUserStreamState* temp = _impl_.Msg_.updatelocaluserstreamstate_;
    _impl_.Msg_.updatelocaluserstreamstate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_updatelocaluserstreamstate(::ServerData::UpdateLocalUserStreamState* updatelocaluserstreamstate) {
  clear_Msg();
  if (updatelocaluserstreamstate) {
    set_has_updatelocaluserstreamstate();
    _impl_.Msg_.updatelocaluserstreamstate_ = updatelocaluserstreamstate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.UpdateLocalUserStreamState)
}
inline ::ServerData::UpdateLocalUserStreamState* RelayClientMessage::_internal_mutable_updatelocaluserstreamstate() {
  if (!_internal_has_updatelocaluserstreamstate()) {
    clear_Msg();
    set_has_updatelocaluserstreamstate();
    _impl_.Msg_.updatelocaluserstreamstate_ = CreateMaybeMessage< ::ServerData::UpdateLocalUserStreamState >(GetArenaForAllocation());
  }
  return _impl_.Msg_.updatelocaluserstreamstate_;
}
inline ::ServerData::UpdateLocalUserStreamState* RelayClientMessage::mutable_updatelocaluserstreamstate() {
  ::ServerData::UpdateLocalUserStreamState* _msg = _internal_mutable_updatelocaluserstreamstate();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.UpdateLocalUserStreamState)
  return _msg;
}

// .ServerData.PostCreateObject PostCreateObject = 70;
inline bool RelayClientMessage::_internal_has_postcreateobject() const {
  return Msg_case() == kPostCreateObject;
}
inline bool RelayClientMessage::has_postcreateobject() const {
  return _internal_has_postcreateobject();
}
inline void RelayClientMessage::set_has_postcreateobject() {
  _impl_._oneof_case_[0] = kPostCreateObject;
}
inline void RelayClientMessage::clear_postcreateobject() {
  if (_internal_has_postcreateobject()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.postcreateobject_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PostCreateObject* RelayClientMessage::release_postcreateobject() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.PostCreateObject)
  if (_internal_has_postcreateobject()) {
    clear_has_Msg();
    ::ServerData::PostCreateObject* temp = _impl_.Msg_.postcreateobject_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.postcreateobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PostCreateObject& RelayClientMessage::_internal_postcreateobject() const {
  return _internal_has_postcreateobject()
      ? *_impl_.Msg_.postcreateobject_
      : reinterpret_cast< ::ServerData::PostCreateObject&>(::ServerData::_PostCreateObject_default_instance_);
}
inline const ::ServerData::PostCreateObject& RelayClientMessage::postcreateobject() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.PostCreateObject)
  return _internal_postcreateobject();
}
inline ::ServerData::PostCreateObject* RelayClientMessage::unsafe_arena_release_postcreateobject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.PostCreateObject)
  if (_internal_has_postcreateobject()) {
    clear_has_Msg();
    ::ServerData::PostCreateObject* temp = _impl_.Msg_.postcreateobject_;
    _impl_.Msg_.postcreateobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_postcreateobject(::ServerData::PostCreateObject* postcreateobject) {
  clear_Msg();
  if (postcreateobject) {
    set_has_postcreateobject();
    _impl_.Msg_.postcreateobject_ = postcreateobject;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.PostCreateObject)
}
inline ::ServerData::PostCreateObject* RelayClientMessage::_internal_mutable_postcreateobject() {
  if (!_internal_has_postcreateobject()) {
    clear_Msg();
    set_has_postcreateobject();
    _impl_.Msg_.postcreateobject_ = CreateMaybeMessage< ::ServerData::PostCreateObject >(GetArenaForAllocation());
  }
  return _impl_.Msg_.postcreateobject_;
}
inline ::ServerData::PostCreateObject* RelayClientMessage::mutable_postcreateobject() {
  ::ServerData::PostCreateObject* _msg = _internal_mutable_postcreateobject();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.PostCreateObject)
  return _msg;
}

// .ServerData.PostRemoveObject PostRemoveObject = 71;
inline bool RelayClientMessage::_internal_has_postremoveobject() const {
  return Msg_case() == kPostRemoveObject;
}
inline bool RelayClientMessage::has_postremoveobject() const {
  return _internal_has_postremoveobject();
}
inline void RelayClientMessage::set_has_postremoveobject() {
  _impl_._oneof_case_[0] = kPostRemoveObject;
}
inline void RelayClientMessage::clear_postremoveobject() {
  if (_internal_has_postremoveobject()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.postremoveobject_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PostRemoveObject* RelayClientMessage::release_postremoveobject() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.PostRemoveObject)
  if (_internal_has_postremoveobject()) {
    clear_has_Msg();
    ::ServerData::PostRemoveObject* temp = _impl_.Msg_.postremoveobject_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.postremoveobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PostRemoveObject& RelayClientMessage::_internal_postremoveobject() const {
  return _internal_has_postremoveobject()
      ? *_impl_.Msg_.postremoveobject_
      : reinterpret_cast< ::ServerData::PostRemoveObject&>(::ServerData::_PostRemoveObject_default_instance_);
}
inline const ::ServerData::PostRemoveObject& RelayClientMessage::postremoveobject() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.PostRemoveObject)
  return _internal_postremoveobject();
}
inline ::ServerData::PostRemoveObject* RelayClientMessage::unsafe_arena_release_postremoveobject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.PostRemoveObject)
  if (_internal_has_postremoveobject()) {
    clear_has_Msg();
    ::ServerData::PostRemoveObject* temp = _impl_.Msg_.postremoveobject_;
    _impl_.Msg_.postremoveobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_postremoveobject(::ServerData::PostRemoveObject* postremoveobject) {
  clear_Msg();
  if (postremoveobject) {
    set_has_postremoveobject();
    _impl_.Msg_.postremoveobject_ = postremoveobject;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.PostRemoveObject)
}
inline ::ServerData::PostRemoveObject* RelayClientMessage::_internal_mutable_postremoveobject() {
  if (!_internal_has_postremoveobject()) {
    clear_Msg();
    set_has_postremoveobject();
    _impl_.Msg_.postremoveobject_ = CreateMaybeMessage< ::ServerData::PostRemoveObject >(GetArenaForAllocation());
  }
  return _impl_.Msg_.postremoveobject_;
}
inline ::ServerData::PostRemoveObject* RelayClientMessage::mutable_postremoveobject() {
  ::ServerData::PostRemoveObject* _msg = _internal_mutable_postremoveobject();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.PostRemoveObject)
  return _msg;
}

// .ServerData.PermissionStatusReq PermissionStatusReq = 90;
inline bool RelayClientMessage::_internal_has_permissionstatusreq() const {
  return Msg_case() == kPermissionStatusReq;
}
inline bool RelayClientMessage::has_permissionstatusreq() const {
  return _internal_has_permissionstatusreq();
}
inline void RelayClientMessage::set_has_permissionstatusreq() {
  _impl_._oneof_case_[0] = kPermissionStatusReq;
}
inline void RelayClientMessage::clear_permissionstatusreq() {
  if (_internal_has_permissionstatusreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.permissionstatusreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PermissionStatusReq* RelayClientMessage::release_permissionstatusreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.PermissionStatusReq)
  if (_internal_has_permissionstatusreq()) {
    clear_has_Msg();
    ::ServerData::PermissionStatusReq* temp = _impl_.Msg_.permissionstatusreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.permissionstatusreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PermissionStatusReq& RelayClientMessage::_internal_permissionstatusreq() const {
  return _internal_has_permissionstatusreq()
      ? *_impl_.Msg_.permissionstatusreq_
      : reinterpret_cast< ::ServerData::PermissionStatusReq&>(::ServerData::_PermissionStatusReq_default_instance_);
}
inline const ::ServerData::PermissionStatusReq& RelayClientMessage::permissionstatusreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.PermissionStatusReq)
  return _internal_permissionstatusreq();
}
inline ::ServerData::PermissionStatusReq* RelayClientMessage::unsafe_arena_release_permissionstatusreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.PermissionStatusReq)
  if (_internal_has_permissionstatusreq()) {
    clear_has_Msg();
    ::ServerData::PermissionStatusReq* temp = _impl_.Msg_.permissionstatusreq_;
    _impl_.Msg_.permissionstatusreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_permissionstatusreq(::ServerData::PermissionStatusReq* permissionstatusreq) {
  clear_Msg();
  if (permissionstatusreq) {
    set_has_permissionstatusreq();
    _impl_.Msg_.permissionstatusreq_ = permissionstatusreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.PermissionStatusReq)
}
inline ::ServerData::PermissionStatusReq* RelayClientMessage::_internal_mutable_permissionstatusreq() {
  if (!_internal_has_permissionstatusreq()) {
    clear_Msg();
    set_has_permissionstatusreq();
    _impl_.Msg_.permissionstatusreq_ = CreateMaybeMessage< ::ServerData::PermissionStatusReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.permissionstatusreq_;
}
inline ::ServerData::PermissionStatusReq* RelayClientMessage::mutable_permissionstatusreq() {
  ::ServerData::PermissionStatusReq* _msg = _internal_mutable_permissionstatusreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.PermissionStatusReq)
  return _msg;
}

// .ServerData.AllJoinableSpacesReq AllJoinableSpacesReq = 100;
inline bool RelayClientMessage::_internal_has_alljoinablespacesreq() const {
  return Msg_case() == kAllJoinableSpacesReq;
}
inline bool RelayClientMessage::has_alljoinablespacesreq() const {
  return _internal_has_alljoinablespacesreq();
}
inline void RelayClientMessage::set_has_alljoinablespacesreq() {
  _impl_._oneof_case_[0] = kAllJoinableSpacesReq;
}
inline void RelayClientMessage::clear_alljoinablespacesreq() {
  if (_internal_has_alljoinablespacesreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.alljoinablespacesreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AllJoinableSpacesReq* RelayClientMessage::release_alljoinablespacesreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.AllJoinableSpacesReq)
  if (_internal_has_alljoinablespacesreq()) {
    clear_has_Msg();
    ::ServerData::AllJoinableSpacesReq* temp = _impl_.Msg_.alljoinablespacesreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.alljoinablespacesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AllJoinableSpacesReq& RelayClientMessage::_internal_alljoinablespacesreq() const {
  return _internal_has_alljoinablespacesreq()
      ? *_impl_.Msg_.alljoinablespacesreq_
      : reinterpret_cast< ::ServerData::AllJoinableSpacesReq&>(::ServerData::_AllJoinableSpacesReq_default_instance_);
}
inline const ::ServerData::AllJoinableSpacesReq& RelayClientMessage::alljoinablespacesreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.AllJoinableSpacesReq)
  return _internal_alljoinablespacesreq();
}
inline ::ServerData::AllJoinableSpacesReq* RelayClientMessage::unsafe_arena_release_alljoinablespacesreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.AllJoinableSpacesReq)
  if (_internal_has_alljoinablespacesreq()) {
    clear_has_Msg();
    ::ServerData::AllJoinableSpacesReq* temp = _impl_.Msg_.alljoinablespacesreq_;
    _impl_.Msg_.alljoinablespacesreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_alljoinablespacesreq(::ServerData::AllJoinableSpacesReq* alljoinablespacesreq) {
  clear_Msg();
  if (alljoinablespacesreq) {
    set_has_alljoinablespacesreq();
    _impl_.Msg_.alljoinablespacesreq_ = alljoinablespacesreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.AllJoinableSpacesReq)
}
inline ::ServerData::AllJoinableSpacesReq* RelayClientMessage::_internal_mutable_alljoinablespacesreq() {
  if (!_internal_has_alljoinablespacesreq()) {
    clear_Msg();
    set_has_alljoinablespacesreq();
    _impl_.Msg_.alljoinablespacesreq_ = CreateMaybeMessage< ::ServerData::AllJoinableSpacesReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.alljoinablespacesreq_;
}
inline ::ServerData::AllJoinableSpacesReq* RelayClientMessage::mutable_alljoinablespacesreq() {
  ::ServerData::AllJoinableSpacesReq* _msg = _internal_mutable_alljoinablespacesreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.AllJoinableSpacesReq)
  return _msg;
}

// .ServerData.GetSpaceInfoReq GetSpaceInfoReq = 101;
inline bool RelayClientMessage::_internal_has_getspaceinforeq() const {
  return Msg_case() == kGetSpaceInfoReq;
}
inline bool RelayClientMessage::has_getspaceinforeq() const {
  return _internal_has_getspaceinforeq();
}
inline void RelayClientMessage::set_has_getspaceinforeq() {
  _impl_._oneof_case_[0] = kGetSpaceInfoReq;
}
inline void RelayClientMessage::clear_getspaceinforeq() {
  if (_internal_has_getspaceinforeq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.getspaceinforeq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::GetSpaceInfoReq* RelayClientMessage::release_getspaceinforeq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.GetSpaceInfoReq)
  if (_internal_has_getspaceinforeq()) {
    clear_has_Msg();
    ::ServerData::GetSpaceInfoReq* temp = _impl_.Msg_.getspaceinforeq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.getspaceinforeq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::GetSpaceInfoReq& RelayClientMessage::_internal_getspaceinforeq() const {
  return _internal_has_getspaceinforeq()
      ? *_impl_.Msg_.getspaceinforeq_
      : reinterpret_cast< ::ServerData::GetSpaceInfoReq&>(::ServerData::_GetSpaceInfoReq_default_instance_);
}
inline const ::ServerData::GetSpaceInfoReq& RelayClientMessage::getspaceinforeq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.GetSpaceInfoReq)
  return _internal_getspaceinforeq();
}
inline ::ServerData::GetSpaceInfoReq* RelayClientMessage::unsafe_arena_release_getspaceinforeq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.GetSpaceInfoReq)
  if (_internal_has_getspaceinforeq()) {
    clear_has_Msg();
    ::ServerData::GetSpaceInfoReq* temp = _impl_.Msg_.getspaceinforeq_;
    _impl_.Msg_.getspaceinforeq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_getspaceinforeq(::ServerData::GetSpaceInfoReq* getspaceinforeq) {
  clear_Msg();
  if (getspaceinforeq) {
    set_has_getspaceinforeq();
    _impl_.Msg_.getspaceinforeq_ = getspaceinforeq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.GetSpaceInfoReq)
}
inline ::ServerData::GetSpaceInfoReq* RelayClientMessage::_internal_mutable_getspaceinforeq() {
  if (!_internal_has_getspaceinforeq()) {
    clear_Msg();
    set_has_getspaceinforeq();
    _impl_.Msg_.getspaceinforeq_ = CreateMaybeMessage< ::ServerData::GetSpaceInfoReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.getspaceinforeq_;
}
inline ::ServerData::GetSpaceInfoReq* RelayClientMessage::mutable_getspaceinforeq() {
  ::ServerData::GetSpaceInfoReq* _msg = _internal_mutable_getspaceinforeq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.GetSpaceInfoReq)
  return _msg;
}

// .ServerData.FetchFileByIdReq FetchFileByIdReq = 110;
inline bool RelayClientMessage::_internal_has_fetchfilebyidreq() const {
  return Msg_case() == kFetchFileByIdReq;
}
inline bool RelayClientMessage::has_fetchfilebyidreq() const {
  return _internal_has_fetchfilebyidreq();
}
inline void RelayClientMessage::set_has_fetchfilebyidreq() {
  _impl_._oneof_case_[0] = kFetchFileByIdReq;
}
inline void RelayClientMessage::clear_fetchfilebyidreq() {
  if (_internal_has_fetchfilebyidreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchfilebyidreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchFileByIdReq* RelayClientMessage::release_fetchfilebyidreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.FetchFileByIdReq)
  if (_internal_has_fetchfilebyidreq()) {
    clear_has_Msg();
    ::ServerData::FetchFileByIdReq* temp = _impl_.Msg_.fetchfilebyidreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchfilebyidreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchFileByIdReq& RelayClientMessage::_internal_fetchfilebyidreq() const {
  return _internal_has_fetchfilebyidreq()
      ? *_impl_.Msg_.fetchfilebyidreq_
      : reinterpret_cast< ::ServerData::FetchFileByIdReq&>(::ServerData::_FetchFileByIdReq_default_instance_);
}
inline const ::ServerData::FetchFileByIdReq& RelayClientMessage::fetchfilebyidreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.FetchFileByIdReq)
  return _internal_fetchfilebyidreq();
}
inline ::ServerData::FetchFileByIdReq* RelayClientMessage::unsafe_arena_release_fetchfilebyidreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.FetchFileByIdReq)
  if (_internal_has_fetchfilebyidreq()) {
    clear_has_Msg();
    ::ServerData::FetchFileByIdReq* temp = _impl_.Msg_.fetchfilebyidreq_;
    _impl_.Msg_.fetchfilebyidreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_fetchfilebyidreq(::ServerData::FetchFileByIdReq* fetchfilebyidreq) {
  clear_Msg();
  if (fetchfilebyidreq) {
    set_has_fetchfilebyidreq();
    _impl_.Msg_.fetchfilebyidreq_ = fetchfilebyidreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.FetchFileByIdReq)
}
inline ::ServerData::FetchFileByIdReq* RelayClientMessage::_internal_mutable_fetchfilebyidreq() {
  if (!_internal_has_fetchfilebyidreq()) {
    clear_Msg();
    set_has_fetchfilebyidreq();
    _impl_.Msg_.fetchfilebyidreq_ = CreateMaybeMessage< ::ServerData::FetchFileByIdReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchfilebyidreq_;
}
inline ::ServerData::FetchFileByIdReq* RelayClientMessage::mutable_fetchfilebyidreq() {
  ::ServerData::FetchFileByIdReq* _msg = _internal_mutable_fetchfilebyidreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.FetchFileByIdReq)
  return _msg;
}

// .ServerData.FetchAllUploadedContentReq FetchAllUploadedContentReq = 111;
inline bool RelayClientMessage::_internal_has_fetchalluploadedcontentreq() const {
  return Msg_case() == kFetchAllUploadedContentReq;
}
inline bool RelayClientMessage::has_fetchalluploadedcontentreq() const {
  return _internal_has_fetchalluploadedcontentreq();
}
inline void RelayClientMessage::set_has_fetchalluploadedcontentreq() {
  _impl_._oneof_case_[0] = kFetchAllUploadedContentReq;
}
inline void RelayClientMessage::clear_fetchalluploadedcontentreq() {
  if (_internal_has_fetchalluploadedcontentreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchalluploadedcontentreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchAllUploadedContentReq* RelayClientMessage::release_fetchalluploadedcontentreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.FetchAllUploadedContentReq)
  if (_internal_has_fetchalluploadedcontentreq()) {
    clear_has_Msg();
    ::ServerData::FetchAllUploadedContentReq* temp = _impl_.Msg_.fetchalluploadedcontentreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchalluploadedcontentreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchAllUploadedContentReq& RelayClientMessage::_internal_fetchalluploadedcontentreq() const {
  return _internal_has_fetchalluploadedcontentreq()
      ? *_impl_.Msg_.fetchalluploadedcontentreq_
      : reinterpret_cast< ::ServerData::FetchAllUploadedContentReq&>(::ServerData::_FetchAllUploadedContentReq_default_instance_);
}
inline const ::ServerData::FetchAllUploadedContentReq& RelayClientMessage::fetchalluploadedcontentreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.FetchAllUploadedContentReq)
  return _internal_fetchalluploadedcontentreq();
}
inline ::ServerData::FetchAllUploadedContentReq* RelayClientMessage::unsafe_arena_release_fetchalluploadedcontentreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.FetchAllUploadedContentReq)
  if (_internal_has_fetchalluploadedcontentreq()) {
    clear_has_Msg();
    ::ServerData::FetchAllUploadedContentReq* temp = _impl_.Msg_.fetchalluploadedcontentreq_;
    _impl_.Msg_.fetchalluploadedcontentreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_fetchalluploadedcontentreq(::ServerData::FetchAllUploadedContentReq* fetchalluploadedcontentreq) {
  clear_Msg();
  if (fetchalluploadedcontentreq) {
    set_has_fetchalluploadedcontentreq();
    _impl_.Msg_.fetchalluploadedcontentreq_ = fetchalluploadedcontentreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.FetchAllUploadedContentReq)
}
inline ::ServerData::FetchAllUploadedContentReq* RelayClientMessage::_internal_mutable_fetchalluploadedcontentreq() {
  if (!_internal_has_fetchalluploadedcontentreq()) {
    clear_Msg();
    set_has_fetchalluploadedcontentreq();
    _impl_.Msg_.fetchalluploadedcontentreq_ = CreateMaybeMessage< ::ServerData::FetchAllUploadedContentReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchalluploadedcontentreq_;
}
inline ::ServerData::FetchAllUploadedContentReq* RelayClientMessage::mutable_fetchalluploadedcontentreq() {
  ::ServerData::FetchAllUploadedContentReq* _msg = _internal_mutable_fetchalluploadedcontentreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.FetchAllUploadedContentReq)
  return _msg;
}

// .ServerData.UploadLocalFileReq UploadLocalFileReq = 112;
inline bool RelayClientMessage::_internal_has_uploadlocalfilereq() const {
  return Msg_case() == kUploadLocalFileReq;
}
inline bool RelayClientMessage::has_uploadlocalfilereq() const {
  return _internal_has_uploadlocalfilereq();
}
inline void RelayClientMessage::set_has_uploadlocalfilereq() {
  _impl_._oneof_case_[0] = kUploadLocalFileReq;
}
inline void RelayClientMessage::clear_uploadlocalfilereq() {
  if (_internal_has_uploadlocalfilereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.uploadlocalfilereq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UploadLocalFileReq* RelayClientMessage::release_uploadlocalfilereq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.UploadLocalFileReq)
  if (_internal_has_uploadlocalfilereq()) {
    clear_has_Msg();
    ::ServerData::UploadLocalFileReq* temp = _impl_.Msg_.uploadlocalfilereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.uploadlocalfilereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UploadLocalFileReq& RelayClientMessage::_internal_uploadlocalfilereq() const {
  return _internal_has_uploadlocalfilereq()
      ? *_impl_.Msg_.uploadlocalfilereq_
      : reinterpret_cast< ::ServerData::UploadLocalFileReq&>(::ServerData::_UploadLocalFileReq_default_instance_);
}
inline const ::ServerData::UploadLocalFileReq& RelayClientMessage::uploadlocalfilereq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.UploadLocalFileReq)
  return _internal_uploadlocalfilereq();
}
inline ::ServerData::UploadLocalFileReq* RelayClientMessage::unsafe_arena_release_uploadlocalfilereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.UploadLocalFileReq)
  if (_internal_has_uploadlocalfilereq()) {
    clear_has_Msg();
    ::ServerData::UploadLocalFileReq* temp = _impl_.Msg_.uploadlocalfilereq_;
    _impl_.Msg_.uploadlocalfilereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_uploadlocalfilereq(::ServerData::UploadLocalFileReq* uploadlocalfilereq) {
  clear_Msg();
  if (uploadlocalfilereq) {
    set_has_uploadlocalfilereq();
    _impl_.Msg_.uploadlocalfilereq_ = uploadlocalfilereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.UploadLocalFileReq)
}
inline ::ServerData::UploadLocalFileReq* RelayClientMessage::_internal_mutable_uploadlocalfilereq() {
  if (!_internal_has_uploadlocalfilereq()) {
    clear_Msg();
    set_has_uploadlocalfilereq();
    _impl_.Msg_.uploadlocalfilereq_ = CreateMaybeMessage< ::ServerData::UploadLocalFileReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.uploadlocalfilereq_;
}
inline ::ServerData::UploadLocalFileReq* RelayClientMessage::mutable_uploadlocalfilereq() {
  ::ServerData::UploadLocalFileReq* _msg = _internal_mutable_uploadlocalfilereq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.UploadLocalFileReq)
  return _msg;
}

// .ServerData.ContentDestinationFolderReq ContentDestinationFolderReq = 113;
inline bool RelayClientMessage::_internal_has_contentdestinationfolderreq() const {
  return Msg_case() == kContentDestinationFolderReq;
}
inline bool RelayClientMessage::has_contentdestinationfolderreq() const {
  return _internal_has_contentdestinationfolderreq();
}
inline void RelayClientMessage::set_has_contentdestinationfolderreq() {
  _impl_._oneof_case_[0] = kContentDestinationFolderReq;
}
inline void RelayClientMessage::clear_contentdestinationfolderreq() {
  if (_internal_has_contentdestinationfolderreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.contentdestinationfolderreq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ContentDestinationFolderReq* RelayClientMessage::release_contentdestinationfolderreq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.ContentDestinationFolderReq)
  if (_internal_has_contentdestinationfolderreq()) {
    clear_has_Msg();
    ::ServerData::ContentDestinationFolderReq* temp = _impl_.Msg_.contentdestinationfolderreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.contentdestinationfolderreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ContentDestinationFolderReq& RelayClientMessage::_internal_contentdestinationfolderreq() const {
  return _internal_has_contentdestinationfolderreq()
      ? *_impl_.Msg_.contentdestinationfolderreq_
      : reinterpret_cast< ::ServerData::ContentDestinationFolderReq&>(::ServerData::_ContentDestinationFolderReq_default_instance_);
}
inline const ::ServerData::ContentDestinationFolderReq& RelayClientMessage::contentdestinationfolderreq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.ContentDestinationFolderReq)
  return _internal_contentdestinationfolderreq();
}
inline ::ServerData::ContentDestinationFolderReq* RelayClientMessage::unsafe_arena_release_contentdestinationfolderreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.ContentDestinationFolderReq)
  if (_internal_has_contentdestinationfolderreq()) {
    clear_has_Msg();
    ::ServerData::ContentDestinationFolderReq* temp = _impl_.Msg_.contentdestinationfolderreq_;
    _impl_.Msg_.contentdestinationfolderreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_contentdestinationfolderreq(::ServerData::ContentDestinationFolderReq* contentdestinationfolderreq) {
  clear_Msg();
  if (contentdestinationfolderreq) {
    set_has_contentdestinationfolderreq();
    _impl_.Msg_.contentdestinationfolderreq_ = contentdestinationfolderreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.ContentDestinationFolderReq)
}
inline ::ServerData::ContentDestinationFolderReq* RelayClientMessage::_internal_mutable_contentdestinationfolderreq() {
  if (!_internal_has_contentdestinationfolderreq()) {
    clear_Msg();
    set_has_contentdestinationfolderreq();
    _impl_.Msg_.contentdestinationfolderreq_ = CreateMaybeMessage< ::ServerData::ContentDestinationFolderReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.contentdestinationfolderreq_;
}
inline ::ServerData::ContentDestinationFolderReq* RelayClientMessage::mutable_contentdestinationfolderreq() {
  ::ServerData::ContentDestinationFolderReq* _msg = _internal_mutable_contentdestinationfolderreq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.ContentDestinationFolderReq)
  return _msg;
}

// .ServerData.FetchRemoteContentInfoReq FetchRemoteContentInfoReq = 114;
inline bool RelayClientMessage::_internal_has_fetchremotecontentinforeq() const {
  return Msg_case() == kFetchRemoteContentInfoReq;
}
inline bool RelayClientMessage::has_fetchremotecontentinforeq() const {
  return _internal_has_fetchremotecontentinforeq();
}
inline void RelayClientMessage::set_has_fetchremotecontentinforeq() {
  _impl_._oneof_case_[0] = kFetchRemoteContentInfoReq;
}
inline void RelayClientMessage::clear_fetchremotecontentinforeq() {
  if (_internal_has_fetchremotecontentinforeq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchremotecontentinforeq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchRemoteContentInfoReq* RelayClientMessage::release_fetchremotecontentinforeq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.FetchRemoteContentInfoReq)
  if (_internal_has_fetchremotecontentinforeq()) {
    clear_has_Msg();
    ::ServerData::FetchRemoteContentInfoReq* temp = _impl_.Msg_.fetchremotecontentinforeq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchremotecontentinforeq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchRemoteContentInfoReq& RelayClientMessage::_internal_fetchremotecontentinforeq() const {
  return _internal_has_fetchremotecontentinforeq()
      ? *_impl_.Msg_.fetchremotecontentinforeq_
      : reinterpret_cast< ::ServerData::FetchRemoteContentInfoReq&>(::ServerData::_FetchRemoteContentInfoReq_default_instance_);
}
inline const ::ServerData::FetchRemoteContentInfoReq& RelayClientMessage::fetchremotecontentinforeq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.FetchRemoteContentInfoReq)
  return _internal_fetchremotecontentinforeq();
}
inline ::ServerData::FetchRemoteContentInfoReq* RelayClientMessage::unsafe_arena_release_fetchremotecontentinforeq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.FetchRemoteContentInfoReq)
  if (_internal_has_fetchremotecontentinforeq()) {
    clear_has_Msg();
    ::ServerData::FetchRemoteContentInfoReq* temp = _impl_.Msg_.fetchremotecontentinforeq_;
    _impl_.Msg_.fetchremotecontentinforeq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_fetchremotecontentinforeq(::ServerData::FetchRemoteContentInfoReq* fetchremotecontentinforeq) {
  clear_Msg();
  if (fetchremotecontentinforeq) {
    set_has_fetchremotecontentinforeq();
    _impl_.Msg_.fetchremotecontentinforeq_ = fetchremotecontentinforeq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.FetchRemoteContentInfoReq)
}
inline ::ServerData::FetchRemoteContentInfoReq* RelayClientMessage::_internal_mutable_fetchremotecontentinforeq() {
  if (!_internal_has_fetchremotecontentinforeq()) {
    clear_Msg();
    set_has_fetchremotecontentinforeq();
    _impl_.Msg_.fetchremotecontentinforeq_ = CreateMaybeMessage< ::ServerData::FetchRemoteContentInfoReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchremotecontentinforeq_;
}
inline ::ServerData::FetchRemoteContentInfoReq* RelayClientMessage::mutable_fetchremotecontentinforeq() {
  ::ServerData::FetchRemoteContentInfoReq* _msg = _internal_mutable_fetchremotecontentinforeq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.FetchRemoteContentInfoReq)
  return _msg;
}

// .ServerData.PostChat PostChat = 120;
inline bool RelayClientMessage::_internal_has_postchat() const {
  return Msg_case() == kPostChat;
}
inline bool RelayClientMessage::has_postchat() const {
  return _internal_has_postchat();
}
inline void RelayClientMessage::set_has_postchat() {
  _impl_._oneof_case_[0] = kPostChat;
}
inline void RelayClientMessage::clear_postchat() {
  if (_internal_has_postchat()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.postchat_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PostChat* RelayClientMessage::release_postchat() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.PostChat)
  if (_internal_has_postchat()) {
    clear_has_Msg();
    ::ServerData::PostChat* temp = _impl_.Msg_.postchat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.postchat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PostChat& RelayClientMessage::_internal_postchat() const {
  return _internal_has_postchat()
      ? *_impl_.Msg_.postchat_
      : reinterpret_cast< ::ServerData::PostChat&>(::ServerData::_PostChat_default_instance_);
}
inline const ::ServerData::PostChat& RelayClientMessage::postchat() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.PostChat)
  return _internal_postchat();
}
inline ::ServerData::PostChat* RelayClientMessage::unsafe_arena_release_postchat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.PostChat)
  if (_internal_has_postchat()) {
    clear_has_Msg();
    ::ServerData::PostChat* temp = _impl_.Msg_.postchat_;
    _impl_.Msg_.postchat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_postchat(::ServerData::PostChat* postchat) {
  clear_Msg();
  if (postchat) {
    set_has_postchat();
    _impl_.Msg_.postchat_ = postchat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.PostChat)
}
inline ::ServerData::PostChat* RelayClientMessage::_internal_mutable_postchat() {
  if (!_internal_has_postchat()) {
    clear_Msg();
    set_has_postchat();
    _impl_.Msg_.postchat_ = CreateMaybeMessage< ::ServerData::PostChat >(GetArenaForAllocation());
  }
  return _impl_.Msg_.postchat_;
}
inline ::ServerData::PostChat* RelayClientMessage::mutable_postchat() {
  ::ServerData::PostChat* _msg = _internal_mutable_postchat();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.PostChat)
  return _msg;
}

// .ServerData.QueryAiReq QueryAiReq = 130;
inline bool RelayClientMessage::_internal_has_queryaireq() const {
  return Msg_case() == kQueryAiReq;
}
inline bool RelayClientMessage::has_queryaireq() const {
  return _internal_has_queryaireq();
}
inline void RelayClientMessage::set_has_queryaireq() {
  _impl_._oneof_case_[0] = kQueryAiReq;
}
inline void RelayClientMessage::clear_queryaireq() {
  if (_internal_has_queryaireq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.queryaireq_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::QueryAiReq* RelayClientMessage::release_queryaireq() {
  // @@protoc_insertion_point(field_release:ServerData.RelayClientMessage.QueryAiReq)
  if (_internal_has_queryaireq()) {
    clear_has_Msg();
    ::ServerData::QueryAiReq* temp = _impl_.Msg_.queryaireq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.queryaireq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::QueryAiReq& RelayClientMessage::_internal_queryaireq() const {
  return _internal_has_queryaireq()
      ? *_impl_.Msg_.queryaireq_
      : reinterpret_cast< ::ServerData::QueryAiReq&>(::ServerData::_QueryAiReq_default_instance_);
}
inline const ::ServerData::QueryAiReq& RelayClientMessage::queryaireq() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayClientMessage.QueryAiReq)
  return _internal_queryaireq();
}
inline ::ServerData::QueryAiReq* RelayClientMessage::unsafe_arena_release_queryaireq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayClientMessage.QueryAiReq)
  if (_internal_has_queryaireq()) {
    clear_has_Msg();
    ::ServerData::QueryAiReq* temp = _impl_.Msg_.queryaireq_;
    _impl_.Msg_.queryaireq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayClientMessage::unsafe_arena_set_allocated_queryaireq(::ServerData::QueryAiReq* queryaireq) {
  clear_Msg();
  if (queryaireq) {
    set_has_queryaireq();
    _impl_.Msg_.queryaireq_ = queryaireq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayClientMessage.QueryAiReq)
}
inline ::ServerData::QueryAiReq* RelayClientMessage::_internal_mutable_queryaireq() {
  if (!_internal_has_queryaireq()) {
    clear_Msg();
    set_has_queryaireq();
    _impl_.Msg_.queryaireq_ = CreateMaybeMessage< ::ServerData::QueryAiReq >(GetArenaForAllocation());
  }
  return _impl_.Msg_.queryaireq_;
}
inline ::ServerData::QueryAiReq* RelayClientMessage::mutable_queryaireq() {
  ::ServerData::QueryAiReq* _msg = _internal_mutable_queryaireq();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayClientMessage.QueryAiReq)
  return _msg;
}

inline bool RelayClientMessage::has_Msg() const {
  return Msg_case() != MSG_NOT_SET;
}
inline void RelayClientMessage::clear_has_Msg() {
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}
inline RelayClientMessage::MsgCase RelayClientMessage::Msg_case() const {
  return RelayClientMessage::MsgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RelayRemoteMessageBatch

// repeated .ServerData.RelayRemoteMessage Messages = 1;
inline int RelayRemoteMessageBatch::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int RelayRemoteMessageBatch::messages_size() const {
  return _internal_messages_size();
}
inline void RelayRemoteMessageBatch::clear_messages() {
  _impl_.messages_.Clear();
}
inline ::ServerData::RelayRemoteMessage* RelayRemoteMessageBatch::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessageBatch.Messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayRemoteMessage >*
RelayRemoteMessageBatch::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.RelayRemoteMessageBatch.Messages)
  return &_impl_.messages_;
}
inline const ::ServerData::RelayRemoteMessage& RelayRemoteMessageBatch::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::ServerData::RelayRemoteMessage& RelayRemoteMessageBatch::messages(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessageBatch.Messages)
  return _internal_messages(index);
}
inline ::ServerData::RelayRemoteMessage* RelayRemoteMessageBatch::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::ServerData::RelayRemoteMessage* RelayRemoteMessageBatch::add_messages() {
  ::ServerData::RelayRemoteMessage* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:ServerData.RelayRemoteMessageBatch.Messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RelayRemoteMessage >&
RelayRemoteMessageBatch::messages() const {
  // @@protoc_insertion_point(field_list:ServerData.RelayRemoteMessageBatch.Messages)
  return _impl_.messages_;
}

// -------------------------------------------------------------------

// RelayRemoteMessage

// .ServerData.StatusMessage Message = 1;
inline bool RelayRemoteMessage::_internal_has_message() const {
  return Msg_case() == kMessage;
}
inline bool RelayRemoteMessage::has_message() const {
  return _internal_has_message();
}
inline void RelayRemoteMessage::set_has_message() {
  _impl_._oneof_case_[0] = kMessage;
}
inline void RelayRemoteMessage::clear_message() {
  if (_internal_has_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.message_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::StatusMessage* RelayRemoteMessage::release_message() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.Message)
  if (_internal_has_message()) {
    clear_has_Msg();
    ::ServerData::StatusMessage* temp = _impl_.Msg_.message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::StatusMessage& RelayRemoteMessage::_internal_message() const {
  return _internal_has_message()
      ? *_impl_.Msg_.message_
      : reinterpret_cast< ::ServerData::StatusMessage&>(::ServerData::_StatusMessage_default_instance_);
}
inline const ::ServerData::StatusMessage& RelayRemoteMessage::message() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.Message)
  return _internal_message();
}
inline ::ServerData::StatusMessage* RelayRemoteMessage::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.Message)
  if (_internal_has_message()) {
    clear_has_Msg();
    ::ServerData::StatusMessage* temp = _impl_.Msg_.message_;
    _impl_.Msg_.message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_message(::ServerData::StatusMessage* message) {
  clear_Msg();
  if (message) {
    set_has_message();
    _impl_.Msg_.message_ = message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.Message)
}
inline ::ServerData::StatusMessage* RelayRemoteMessage::_internal_mutable_message() {
  if (!_internal_has_message()) {
    clear_Msg();
    set_has_message();
    _impl_.Msg_.message_ = CreateMaybeMessage< ::ServerData::StatusMessage >(GetArenaForAllocation());
  }
  return _impl_.Msg_.message_;
}
inline ::ServerData::StatusMessage* RelayRemoteMessage::mutable_message() {
  ::ServerData::StatusMessage* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.Message)
  return _msg;
}

// .ServerData.AuthenticateResp AuthenticateResp = 2;
inline bool RelayRemoteMessage::_internal_has_authenticateresp() const {
  return Msg_case() == kAuthenticateResp;
}
inline bool RelayRemoteMessage::has_authenticateresp() const {
  return _internal_has_authenticateresp();
}
inline void RelayRemoteMessage::set_has_authenticateresp() {
  _impl_._oneof_case_[0] = kAuthenticateResp;
}
inline void RelayRemoteMessage::clear_authenticateresp() {
  if (_internal_has_authenticateresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.authenticateresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AuthenticateResp* RelayRemoteMessage::release_authenticateresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.AuthenticateResp)
  if (_internal_has_authenticateresp()) {
    clear_has_Msg();
    ::ServerData::AuthenticateResp* temp = _impl_.Msg_.authenticateresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.authenticateresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AuthenticateResp& RelayRemoteMessage::_internal_authenticateresp() const {
  return _internal_has_authenticateresp()
      ? *_impl_.Msg_.authenticateresp_
      : reinterpret_cast< ::ServerData::AuthenticateResp&>(::ServerData::_AuthenticateResp_default_instance_);
}
inline const ::ServerData::AuthenticateResp& RelayRemoteMessage::authenticateresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.AuthenticateResp)
  return _internal_authenticateresp();
}
inline ::ServerData::AuthenticateResp* RelayRemoteMessage::unsafe_arena_release_authenticateresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.AuthenticateResp)
  if (_internal_has_authenticateresp()) {
    clear_has_Msg();
    ::ServerData::AuthenticateResp* temp = _impl_.Msg_.authenticateresp_;
    _impl_.Msg_.authenticateresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_authenticateresp(::ServerData::AuthenticateResp* authenticateresp) {
  clear_Msg();
  if (authenticateresp) {
    set_has_authenticateresp();
    _impl_.Msg_.authenticateresp_ = authenticateresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.AuthenticateResp)
}
inline ::ServerData::AuthenticateResp* RelayRemoteMessage::_internal_mutable_authenticateresp() {
  if (!_internal_has_authenticateresp()) {
    clear_Msg();
    set_has_authenticateresp();
    _impl_.Msg_.authenticateresp_ = CreateMaybeMessage< ::ServerData::AuthenticateResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.authenticateresp_;
}
inline ::ServerData::AuthenticateResp* RelayRemoteMessage::mutable_authenticateresp() {
  ::ServerData::AuthenticateResp* _msg = _internal_mutable_authenticateresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.AuthenticateResp)
  return _msg;
}

// .ServerData.ExitAllSpacesAndLogoutResp ExitAllSpacesAndLogoutResp = 4;
inline bool RelayRemoteMessage::_internal_has_exitallspacesandlogoutresp() const {
  return Msg_case() == kExitAllSpacesAndLogoutResp;
}
inline bool RelayRemoteMessage::has_exitallspacesandlogoutresp() const {
  return _internal_has_exitallspacesandlogoutresp();
}
inline void RelayRemoteMessage::set_has_exitallspacesandlogoutresp() {
  _impl_._oneof_case_[0] = kExitAllSpacesAndLogoutResp;
}
inline void RelayRemoteMessage::clear_exitallspacesandlogoutresp() {
  if (_internal_has_exitallspacesandlogoutresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.exitallspacesandlogoutresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ExitAllSpacesAndLogoutResp* RelayRemoteMessage::release_exitallspacesandlogoutresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ExitAllSpacesAndLogoutResp)
  if (_internal_has_exitallspacesandlogoutresp()) {
    clear_has_Msg();
    ::ServerData::ExitAllSpacesAndLogoutResp* temp = _impl_.Msg_.exitallspacesandlogoutresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.exitallspacesandlogoutresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ExitAllSpacesAndLogoutResp& RelayRemoteMessage::_internal_exitallspacesandlogoutresp() const {
  return _internal_has_exitallspacesandlogoutresp()
      ? *_impl_.Msg_.exitallspacesandlogoutresp_
      : reinterpret_cast< ::ServerData::ExitAllSpacesAndLogoutResp&>(::ServerData::_ExitAllSpacesAndLogoutResp_default_instance_);
}
inline const ::ServerData::ExitAllSpacesAndLogoutResp& RelayRemoteMessage::exitallspacesandlogoutresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ExitAllSpacesAndLogoutResp)
  return _internal_exitallspacesandlogoutresp();
}
inline ::ServerData::ExitAllSpacesAndLogoutResp* RelayRemoteMessage::unsafe_arena_release_exitallspacesandlogoutresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ExitAllSpacesAndLogoutResp)
  if (_internal_has_exitallspacesandlogoutresp()) {
    clear_has_Msg();
    ::ServerData::ExitAllSpacesAndLogoutResp* temp = _impl_.Msg_.exitallspacesandlogoutresp_;
    _impl_.Msg_.exitallspacesandlogoutresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_exitallspacesandlogoutresp(::ServerData::ExitAllSpacesAndLogoutResp* exitallspacesandlogoutresp) {
  clear_Msg();
  if (exitallspacesandlogoutresp) {
    set_has_exitallspacesandlogoutresp();
    _impl_.Msg_.exitallspacesandlogoutresp_ = exitallspacesandlogoutresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ExitAllSpacesAndLogoutResp)
}
inline ::ServerData::ExitAllSpacesAndLogoutResp* RelayRemoteMessage::_internal_mutable_exitallspacesandlogoutresp() {
  if (!_internal_has_exitallspacesandlogoutresp()) {
    clear_Msg();
    set_has_exitallspacesandlogoutresp();
    _impl_.Msg_.exitallspacesandlogoutresp_ = CreateMaybeMessage< ::ServerData::ExitAllSpacesAndLogoutResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.exitallspacesandlogoutresp_;
}
inline ::ServerData::ExitAllSpacesAndLogoutResp* RelayRemoteMessage::mutable_exitallspacesandlogoutresp() {
  ::ServerData::ExitAllSpacesAndLogoutResp* _msg = _internal_mutable_exitallspacesandlogoutresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ExitAllSpacesAndLogoutResp)
  return _msg;
}

// .ServerData.RelayDataCache RelayDataCache = 5;
inline bool RelayRemoteMessage::_internal_has_relaydatacache() const {
  return Msg_case() == kRelayDataCache;
}
inline bool RelayRemoteMessage::has_relaydatacache() const {
  return _internal_has_relaydatacache();
}
inline void RelayRemoteMessage::set_has_relaydatacache() {
  _impl_._oneof_case_[0] = kRelayDataCache;
}
inline ::ServerData::RelayDataCache* RelayRemoteMessage::release_relaydatacache() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.RelayDataCache)
  if (_internal_has_relaydatacache()) {
    clear_has_Msg();
    ::ServerData::RelayDataCache* temp = _impl_.Msg_.relaydatacache_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.relaydatacache_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::RelayDataCache& RelayRemoteMessage::_internal_relaydatacache() const {
  return _internal_has_relaydatacache()
      ? *_impl_.Msg_.relaydatacache_
      : reinterpret_cast< ::ServerData::RelayDataCache&>(::ServerData::_RelayDataCache_default_instance_);
}
inline const ::ServerData::RelayDataCache& RelayRemoteMessage::relaydatacache() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.RelayDataCache)
  return _internal_relaydatacache();
}
inline ::ServerData::RelayDataCache* RelayRemoteMessage::unsafe_arena_release_relaydatacache() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.RelayDataCache)
  if (_internal_has_relaydatacache()) {
    clear_has_Msg();
    ::ServerData::RelayDataCache* temp = _impl_.Msg_.relaydatacache_;
    _impl_.Msg_.relaydatacache_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_relaydatacache(::ServerData::RelayDataCache* relaydatacache) {
  clear_Msg();
  if (relaydatacache) {
    set_has_relaydatacache();
    _impl_.Msg_.relaydatacache_ = relaydatacache;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.RelayDataCache)
}
inline ::ServerData::RelayDataCache* RelayRemoteMessage::_internal_mutable_relaydatacache() {
  if (!_internal_has_relaydatacache()) {
    clear_Msg();
    set_has_relaydatacache();
    _impl_.Msg_.relaydatacache_ = CreateMaybeMessage< ::ServerData::RelayDataCache >(GetArenaForAllocation());
  }
  return _impl_.Msg_.relaydatacache_;
}
inline ::ServerData::RelayDataCache* RelayRemoteMessage::mutable_relaydatacache() {
  ::ServerData::RelayDataCache* _msg = _internal_mutable_relaydatacache();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.RelayDataCache)
  return _msg;
}

// .ServerData.AuthenticateDeviceCodeBeginResp AuthenticateDeviceCodeBeginResp = 18;
inline bool RelayRemoteMessage::_internal_has_authenticatedevicecodebeginresp() const {
  return Msg_case() == kAuthenticateDeviceCodeBeginResp;
}
inline bool RelayRemoteMessage::has_authenticatedevicecodebeginresp() const {
  return _internal_has_authenticatedevicecodebeginresp();
}
inline void RelayRemoteMessage::set_has_authenticatedevicecodebeginresp() {
  _impl_._oneof_case_[0] = kAuthenticateDeviceCodeBeginResp;
}
inline void RelayRemoteMessage::clear_authenticatedevicecodebeginresp() {
  if (_internal_has_authenticatedevicecodebeginresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.authenticatedevicecodebeginresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AuthenticateDeviceCodeBeginResp* RelayRemoteMessage::release_authenticatedevicecodebeginresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.AuthenticateDeviceCodeBeginResp)
  if (_internal_has_authenticatedevicecodebeginresp()) {
    clear_has_Msg();
    ::ServerData::AuthenticateDeviceCodeBeginResp* temp = _impl_.Msg_.authenticatedevicecodebeginresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.authenticatedevicecodebeginresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AuthenticateDeviceCodeBeginResp& RelayRemoteMessage::_internal_authenticatedevicecodebeginresp() const {
  return _internal_has_authenticatedevicecodebeginresp()
      ? *_impl_.Msg_.authenticatedevicecodebeginresp_
      : reinterpret_cast< ::ServerData::AuthenticateDeviceCodeBeginResp&>(::ServerData::_AuthenticateDeviceCodeBeginResp_default_instance_);
}
inline const ::ServerData::AuthenticateDeviceCodeBeginResp& RelayRemoteMessage::authenticatedevicecodebeginresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.AuthenticateDeviceCodeBeginResp)
  return _internal_authenticatedevicecodebeginresp();
}
inline ::ServerData::AuthenticateDeviceCodeBeginResp* RelayRemoteMessage::unsafe_arena_release_authenticatedevicecodebeginresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.AuthenticateDeviceCodeBeginResp)
  if (_internal_has_authenticatedevicecodebeginresp()) {
    clear_has_Msg();
    ::ServerData::AuthenticateDeviceCodeBeginResp* temp = _impl_.Msg_.authenticatedevicecodebeginresp_;
    _impl_.Msg_.authenticatedevicecodebeginresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_authenticatedevicecodebeginresp(::ServerData::AuthenticateDeviceCodeBeginResp* authenticatedevicecodebeginresp) {
  clear_Msg();
  if (authenticatedevicecodebeginresp) {
    set_has_authenticatedevicecodebeginresp();
    _impl_.Msg_.authenticatedevicecodebeginresp_ = authenticatedevicecodebeginresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.AuthenticateDeviceCodeBeginResp)
}
inline ::ServerData::AuthenticateDeviceCodeBeginResp* RelayRemoteMessage::_internal_mutable_authenticatedevicecodebeginresp() {
  if (!_internal_has_authenticatedevicecodebeginresp()) {
    clear_Msg();
    set_has_authenticatedevicecodebeginresp();
    _impl_.Msg_.authenticatedevicecodebeginresp_ = CreateMaybeMessage< ::ServerData::AuthenticateDeviceCodeBeginResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.authenticatedevicecodebeginresp_;
}
inline ::ServerData::AuthenticateDeviceCodeBeginResp* RelayRemoteMessage::mutable_authenticatedevicecodebeginresp() {
  ::ServerData::AuthenticateDeviceCodeBeginResp* _msg = _internal_mutable_authenticatedevicecodebeginresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.AuthenticateDeviceCodeBeginResp)
  return _msg;
}

// .ServerData.ConstructApiKeyResp ConstructApiKeyResp = 19;
inline bool RelayRemoteMessage::_internal_has_constructapikeyresp() const {
  return Msg_case() == kConstructApiKeyResp;
}
inline bool RelayRemoteMessage::has_constructapikeyresp() const {
  return _internal_has_constructapikeyresp();
}
inline void RelayRemoteMessage::set_has_constructapikeyresp() {
  _impl_._oneof_case_[0] = kConstructApiKeyResp;
}
inline void RelayRemoteMessage::clear_constructapikeyresp() {
  if (_internal_has_constructapikeyresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.constructapikeyresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ConstructApiKeyResp* RelayRemoteMessage::release_constructapikeyresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ConstructApiKeyResp)
  if (_internal_has_constructapikeyresp()) {
    clear_has_Msg();
    ::ServerData::ConstructApiKeyResp* temp = _impl_.Msg_.constructapikeyresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.constructapikeyresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ConstructApiKeyResp& RelayRemoteMessage::_internal_constructapikeyresp() const {
  return _internal_has_constructapikeyresp()
      ? *_impl_.Msg_.constructapikeyresp_
      : reinterpret_cast< ::ServerData::ConstructApiKeyResp&>(::ServerData::_ConstructApiKeyResp_default_instance_);
}
inline const ::ServerData::ConstructApiKeyResp& RelayRemoteMessage::constructapikeyresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ConstructApiKeyResp)
  return _internal_constructapikeyresp();
}
inline ::ServerData::ConstructApiKeyResp* RelayRemoteMessage::unsafe_arena_release_constructapikeyresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ConstructApiKeyResp)
  if (_internal_has_constructapikeyresp()) {
    clear_has_Msg();
    ::ServerData::ConstructApiKeyResp* temp = _impl_.Msg_.constructapikeyresp_;
    _impl_.Msg_.constructapikeyresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_constructapikeyresp(::ServerData::ConstructApiKeyResp* constructapikeyresp) {
  clear_Msg();
  if (constructapikeyresp) {
    set_has_constructapikeyresp();
    _impl_.Msg_.constructapikeyresp_ = constructapikeyresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ConstructApiKeyResp)
}
inline ::ServerData::ConstructApiKeyResp* RelayRemoteMessage::_internal_mutable_constructapikeyresp() {
  if (!_internal_has_constructapikeyresp()) {
    clear_Msg();
    set_has_constructapikeyresp();
    _impl_.Msg_.constructapikeyresp_ = CreateMaybeMessage< ::ServerData::ConstructApiKeyResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.constructapikeyresp_;
}
inline ::ServerData::ConstructApiKeyResp* RelayRemoteMessage::mutable_constructapikeyresp() {
  ::ServerData::ConstructApiKeyResp* _msg = _internal_mutable_constructapikeyresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ConstructApiKeyResp)
  return _msg;
}

// .ServerData.GenericResp GenericResponse = 6;
inline bool RelayRemoteMessage::_internal_has_genericresponse() const {
  return Msg_case() == kGenericResponse;
}
inline bool RelayRemoteMessage::has_genericresponse() const {
  return _internal_has_genericresponse();
}
inline void RelayRemoteMessage::set_has_genericresponse() {
  _impl_._oneof_case_[0] = kGenericResponse;
}
inline void RelayRemoteMessage::clear_genericresponse() {
  if (_internal_has_genericresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.genericresponse_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::GenericResp* RelayRemoteMessage::release_genericresponse() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.GenericResponse)
  if (_internal_has_genericresponse()) {
    clear_has_Msg();
    ::ServerData::GenericResp* temp = _impl_.Msg_.genericresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.genericresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::GenericResp& RelayRemoteMessage::_internal_genericresponse() const {
  return _internal_has_genericresponse()
      ? *_impl_.Msg_.genericresponse_
      : reinterpret_cast< ::ServerData::GenericResp&>(::ServerData::_GenericResp_default_instance_);
}
inline const ::ServerData::GenericResp& RelayRemoteMessage::genericresponse() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.GenericResponse)
  return _internal_genericresponse();
}
inline ::ServerData::GenericResp* RelayRemoteMessage::unsafe_arena_release_genericresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.GenericResponse)
  if (_internal_has_genericresponse()) {
    clear_has_Msg();
    ::ServerData::GenericResp* temp = _impl_.Msg_.genericresponse_;
    _impl_.Msg_.genericresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_genericresponse(::ServerData::GenericResp* genericresponse) {
  clear_Msg();
  if (genericresponse) {
    set_has_genericresponse();
    _impl_.Msg_.genericresponse_ = genericresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.GenericResponse)
}
inline ::ServerData::GenericResp* RelayRemoteMessage::_internal_mutable_genericresponse() {
  if (!_internal_has_genericresponse()) {
    clear_Msg();
    set_has_genericresponse();
    _impl_.Msg_.genericresponse_ = CreateMaybeMessage< ::ServerData::GenericResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.genericresponse_;
}
inline ::ServerData::GenericResp* RelayRemoteMessage::mutable_genericresponse() {
  ::ServerData::GenericResp* _msg = _internal_mutable_genericresponse();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.GenericResponse)
  return _msg;
}

// .ServerData.ServerMessage ServerMessageResp = 7;
inline bool RelayRemoteMessage::_internal_has_servermessageresp() const {
  return Msg_case() == kServerMessageResp;
}
inline bool RelayRemoteMessage::has_servermessageresp() const {
  return _internal_has_servermessageresp();
}
inline void RelayRemoteMessage::set_has_servermessageresp() {
  _impl_._oneof_case_[0] = kServerMessageResp;
}
inline void RelayRemoteMessage::clear_servermessageresp() {
  if (_internal_has_servermessageresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.servermessageresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ServerMessage* RelayRemoteMessage::release_servermessageresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ServerMessageResp)
  if (_internal_has_servermessageresp()) {
    clear_has_Msg();
    ::ServerData::ServerMessage* temp = _impl_.Msg_.servermessageresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.servermessageresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ServerMessage& RelayRemoteMessage::_internal_servermessageresp() const {
  return _internal_has_servermessageresp()
      ? *_impl_.Msg_.servermessageresp_
      : reinterpret_cast< ::ServerData::ServerMessage&>(::ServerData::_ServerMessage_default_instance_);
}
inline const ::ServerData::ServerMessage& RelayRemoteMessage::servermessageresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ServerMessageResp)
  return _internal_servermessageresp();
}
inline ::ServerData::ServerMessage* RelayRemoteMessage::unsafe_arena_release_servermessageresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ServerMessageResp)
  if (_internal_has_servermessageresp()) {
    clear_has_Msg();
    ::ServerData::ServerMessage* temp = _impl_.Msg_.servermessageresp_;
    _impl_.Msg_.servermessageresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_servermessageresp(::ServerData::ServerMessage* servermessageresp) {
  clear_Msg();
  if (servermessageresp) {
    set_has_servermessageresp();
    _impl_.Msg_.servermessageresp_ = servermessageresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ServerMessageResp)
}
inline ::ServerData::ServerMessage* RelayRemoteMessage::_internal_mutable_servermessageresp() {
  if (!_internal_has_servermessageresp()) {
    clear_Msg();
    set_has_servermessageresp();
    _impl_.Msg_.servermessageresp_ = CreateMaybeMessage< ::ServerData::ServerMessage >(GetArenaForAllocation());
  }
  return _impl_.Msg_.servermessageresp_;
}
inline ::ServerData::ServerMessage* RelayRemoteMessage::mutable_servermessageresp() {
  ::ServerData::ServerMessage* _msg = _internal_mutable_servermessageresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ServerMessageResp)
  return _msg;
}

// .ServerData.SpaceConnectionStatus ConnectionStatusResp = 8;
inline bool RelayRemoteMessage::_internal_has_connectionstatusresp() const {
  return Msg_case() == kConnectionStatusResp;
}
inline bool RelayRemoteMessage::has_connectionstatusresp() const {
  return _internal_has_connectionstatusresp();
}
inline void RelayRemoteMessage::set_has_connectionstatusresp() {
  _impl_._oneof_case_[0] = kConnectionStatusResp;
}
inline void RelayRemoteMessage::clear_connectionstatusresp() {
  if (_internal_has_connectionstatusresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.connectionstatusresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::SpaceConnectionStatus* RelayRemoteMessage::release_connectionstatusresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ConnectionStatusResp)
  if (_internal_has_connectionstatusresp()) {
    clear_has_Msg();
    ::ServerData::SpaceConnectionStatus* temp = _impl_.Msg_.connectionstatusresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.connectionstatusresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::SpaceConnectionStatus& RelayRemoteMessage::_internal_connectionstatusresp() const {
  return _internal_has_connectionstatusresp()
      ? *_impl_.Msg_.connectionstatusresp_
      : reinterpret_cast< ::ServerData::SpaceConnectionStatus&>(::ServerData::_SpaceConnectionStatus_default_instance_);
}
inline const ::ServerData::SpaceConnectionStatus& RelayRemoteMessage::connectionstatusresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ConnectionStatusResp)
  return _internal_connectionstatusresp();
}
inline ::ServerData::SpaceConnectionStatus* RelayRemoteMessage::unsafe_arena_release_connectionstatusresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ConnectionStatusResp)
  if (_internal_has_connectionstatusresp()) {
    clear_has_Msg();
    ::ServerData::SpaceConnectionStatus* temp = _impl_.Msg_.connectionstatusresp_;
    _impl_.Msg_.connectionstatusresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_connectionstatusresp(::ServerData::SpaceConnectionStatus* connectionstatusresp) {
  clear_Msg();
  if (connectionstatusresp) {
    set_has_connectionstatusresp();
    _impl_.Msg_.connectionstatusresp_ = connectionstatusresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ConnectionStatusResp)
}
inline ::ServerData::SpaceConnectionStatus* RelayRemoteMessage::_internal_mutable_connectionstatusresp() {
  if (!_internal_has_connectionstatusresp()) {
    clear_Msg();
    set_has_connectionstatusresp();
    _impl_.Msg_.connectionstatusresp_ = CreateMaybeMessage< ::ServerData::SpaceConnectionStatus >(GetArenaForAllocation());
  }
  return _impl_.Msg_.connectionstatusresp_;
}
inline ::ServerData::SpaceConnectionStatus* RelayRemoteMessage::mutable_connectionstatusresp() {
  ::ServerData::SpaceConnectionStatus* _msg = _internal_mutable_connectionstatusresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ConnectionStatusResp)
  return _msg;
}

// .ServerData.JoinSpaceFromIdResp JoinSpaceFromIdResp = 10;
inline bool RelayRemoteMessage::_internal_has_joinspacefromidresp() const {
  return Msg_case() == kJoinSpaceFromIdResp;
}
inline bool RelayRemoteMessage::has_joinspacefromidresp() const {
  return _internal_has_joinspacefromidresp();
}
inline void RelayRemoteMessage::set_has_joinspacefromidresp() {
  _impl_._oneof_case_[0] = kJoinSpaceFromIdResp;
}
inline void RelayRemoteMessage::clear_joinspacefromidresp() {
  if (_internal_has_joinspacefromidresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.joinspacefromidresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::JoinSpaceFromIdResp* RelayRemoteMessage::release_joinspacefromidresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.JoinSpaceFromIdResp)
  if (_internal_has_joinspacefromidresp()) {
    clear_has_Msg();
    ::ServerData::JoinSpaceFromIdResp* temp = _impl_.Msg_.joinspacefromidresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.joinspacefromidresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::JoinSpaceFromIdResp& RelayRemoteMessage::_internal_joinspacefromidresp() const {
  return _internal_has_joinspacefromidresp()
      ? *_impl_.Msg_.joinspacefromidresp_
      : reinterpret_cast< ::ServerData::JoinSpaceFromIdResp&>(::ServerData::_JoinSpaceFromIdResp_default_instance_);
}
inline const ::ServerData::JoinSpaceFromIdResp& RelayRemoteMessage::joinspacefromidresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.JoinSpaceFromIdResp)
  return _internal_joinspacefromidresp();
}
inline ::ServerData::JoinSpaceFromIdResp* RelayRemoteMessage::unsafe_arena_release_joinspacefromidresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.JoinSpaceFromIdResp)
  if (_internal_has_joinspacefromidresp()) {
    clear_has_Msg();
    ::ServerData::JoinSpaceFromIdResp* temp = _impl_.Msg_.joinspacefromidresp_;
    _impl_.Msg_.joinspacefromidresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_joinspacefromidresp(::ServerData::JoinSpaceFromIdResp* joinspacefromidresp) {
  clear_Msg();
  if (joinspacefromidresp) {
    set_has_joinspacefromidresp();
    _impl_.Msg_.joinspacefromidresp_ = joinspacefromidresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.JoinSpaceFromIdResp)
}
inline ::ServerData::JoinSpaceFromIdResp* RelayRemoteMessage::_internal_mutable_joinspacefromidresp() {
  if (!_internal_has_joinspacefromidresp()) {
    clear_Msg();
    set_has_joinspacefromidresp();
    _impl_.Msg_.joinspacefromidresp_ = CreateMaybeMessage< ::ServerData::JoinSpaceFromIdResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.joinspacefromidresp_;
}
inline ::ServerData::JoinSpaceFromIdResp* RelayRemoteMessage::mutable_joinspacefromidresp() {
  ::ServerData::JoinSpaceFromIdResp* _msg = _internal_mutable_joinspacefromidresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.JoinSpaceFromIdResp)
  return _msg;
}

// .ServerData.ShutdownSpaceConnectionResp ShutdownSpaceConnectionResp = 11;
inline bool RelayRemoteMessage::_internal_has_shutdownspaceconnectionresp() const {
  return Msg_case() == kShutdownSpaceConnectionResp;
}
inline bool RelayRemoteMessage::has_shutdownspaceconnectionresp() const {
  return _internal_has_shutdownspaceconnectionresp();
}
inline void RelayRemoteMessage::set_has_shutdownspaceconnectionresp() {
  _impl_._oneof_case_[0] = kShutdownSpaceConnectionResp;
}
inline void RelayRemoteMessage::clear_shutdownspaceconnectionresp() {
  if (_internal_has_shutdownspaceconnectionresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.shutdownspaceconnectionresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ShutdownSpaceConnectionResp* RelayRemoteMessage::release_shutdownspaceconnectionresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ShutdownSpaceConnectionResp)
  if (_internal_has_shutdownspaceconnectionresp()) {
    clear_has_Msg();
    ::ServerData::ShutdownSpaceConnectionResp* temp = _impl_.Msg_.shutdownspaceconnectionresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.shutdownspaceconnectionresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ShutdownSpaceConnectionResp& RelayRemoteMessage::_internal_shutdownspaceconnectionresp() const {
  return _internal_has_shutdownspaceconnectionresp()
      ? *_impl_.Msg_.shutdownspaceconnectionresp_
      : reinterpret_cast< ::ServerData::ShutdownSpaceConnectionResp&>(::ServerData::_ShutdownSpaceConnectionResp_default_instance_);
}
inline const ::ServerData::ShutdownSpaceConnectionResp& RelayRemoteMessage::shutdownspaceconnectionresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ShutdownSpaceConnectionResp)
  return _internal_shutdownspaceconnectionresp();
}
inline ::ServerData::ShutdownSpaceConnectionResp* RelayRemoteMessage::unsafe_arena_release_shutdownspaceconnectionresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ShutdownSpaceConnectionResp)
  if (_internal_has_shutdownspaceconnectionresp()) {
    clear_has_Msg();
    ::ServerData::ShutdownSpaceConnectionResp* temp = _impl_.Msg_.shutdownspaceconnectionresp_;
    _impl_.Msg_.shutdownspaceconnectionresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_shutdownspaceconnectionresp(::ServerData::ShutdownSpaceConnectionResp* shutdownspaceconnectionresp) {
  clear_Msg();
  if (shutdownspaceconnectionresp) {
    set_has_shutdownspaceconnectionresp();
    _impl_.Msg_.shutdownspaceconnectionresp_ = shutdownspaceconnectionresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ShutdownSpaceConnectionResp)
}
inline ::ServerData::ShutdownSpaceConnectionResp* RelayRemoteMessage::_internal_mutable_shutdownspaceconnectionresp() {
  if (!_internal_has_shutdownspaceconnectionresp()) {
    clear_Msg();
    set_has_shutdownspaceconnectionresp();
    _impl_.Msg_.shutdownspaceconnectionresp_ = CreateMaybeMessage< ::ServerData::ShutdownSpaceConnectionResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.shutdownspaceconnectionresp_;
}
inline ::ServerData::ShutdownSpaceConnectionResp* RelayRemoteMessage::mutable_shutdownspaceconnectionresp() {
  ::ServerData::ShutdownSpaceConnectionResp* _msg = _internal_mutable_shutdownspaceconnectionresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ShutdownSpaceConnectionResp)
  return _msg;
}

// .ServerData.CreateSpaceResp CreateSpaceResp = 12;
inline bool RelayRemoteMessage::_internal_has_createspaceresp() const {
  return Msg_case() == kCreateSpaceResp;
}
inline bool RelayRemoteMessage::has_createspaceresp() const {
  return _internal_has_createspaceresp();
}
inline void RelayRemoteMessage::set_has_createspaceresp() {
  _impl_._oneof_case_[0] = kCreateSpaceResp;
}
inline void RelayRemoteMessage::clear_createspaceresp() {
  if (_internal_has_createspaceresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.createspaceresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::CreateSpaceResp* RelayRemoteMessage::release_createspaceresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.CreateSpaceResp)
  if (_internal_has_createspaceresp()) {
    clear_has_Msg();
    ::ServerData::CreateSpaceResp* temp = _impl_.Msg_.createspaceresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.createspaceresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::CreateSpaceResp& RelayRemoteMessage::_internal_createspaceresp() const {
  return _internal_has_createspaceresp()
      ? *_impl_.Msg_.createspaceresp_
      : reinterpret_cast< ::ServerData::CreateSpaceResp&>(::ServerData::_CreateSpaceResp_default_instance_);
}
inline const ::ServerData::CreateSpaceResp& RelayRemoteMessage::createspaceresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.CreateSpaceResp)
  return _internal_createspaceresp();
}
inline ::ServerData::CreateSpaceResp* RelayRemoteMessage::unsafe_arena_release_createspaceresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.CreateSpaceResp)
  if (_internal_has_createspaceresp()) {
    clear_has_Msg();
    ::ServerData::CreateSpaceResp* temp = _impl_.Msg_.createspaceresp_;
    _impl_.Msg_.createspaceresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_createspaceresp(::ServerData::CreateSpaceResp* createspaceresp) {
  clear_Msg();
  if (createspaceresp) {
    set_has_createspaceresp();
    _impl_.Msg_.createspaceresp_ = createspaceresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.CreateSpaceResp)
}
inline ::ServerData::CreateSpaceResp* RelayRemoteMessage::_internal_mutable_createspaceresp() {
  if (!_internal_has_createspaceresp()) {
    clear_Msg();
    set_has_createspaceresp();
    _impl_.Msg_.createspaceresp_ = CreateMaybeMessage< ::ServerData::CreateSpaceResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.createspaceresp_;
}
inline ::ServerData::CreateSpaceResp* RelayRemoteMessage::mutable_createspaceresp() {
  ::ServerData::CreateSpaceResp* _msg = _internal_mutable_createspaceresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.CreateSpaceResp)
  return _msg;
}

// .ServerData.CheckServerStatusResp CheckServerStatusResp = 17;
inline bool RelayRemoteMessage::_internal_has_checkserverstatusresp() const {
  return Msg_case() == kCheckServerStatusResp;
}
inline bool RelayRemoteMessage::has_checkserverstatusresp() const {
  return _internal_has_checkserverstatusresp();
}
inline void RelayRemoteMessage::set_has_checkserverstatusresp() {
  _impl_._oneof_case_[0] = kCheckServerStatusResp;
}
inline void RelayRemoteMessage::clear_checkserverstatusresp() {
  if (_internal_has_checkserverstatusresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.checkserverstatusresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::CheckServerStatusResp* RelayRemoteMessage::release_checkserverstatusresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.CheckServerStatusResp)
  if (_internal_has_checkserverstatusresp()) {
    clear_has_Msg();
    ::ServerData::CheckServerStatusResp* temp = _impl_.Msg_.checkserverstatusresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.checkserverstatusresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::CheckServerStatusResp& RelayRemoteMessage::_internal_checkserverstatusresp() const {
  return _internal_has_checkserverstatusresp()
      ? *_impl_.Msg_.checkserverstatusresp_
      : reinterpret_cast< ::ServerData::CheckServerStatusResp&>(::ServerData::_CheckServerStatusResp_default_instance_);
}
inline const ::ServerData::CheckServerStatusResp& RelayRemoteMessage::checkserverstatusresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.CheckServerStatusResp)
  return _internal_checkserverstatusresp();
}
inline ::ServerData::CheckServerStatusResp* RelayRemoteMessage::unsafe_arena_release_checkserverstatusresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.CheckServerStatusResp)
  if (_internal_has_checkserverstatusresp()) {
    clear_has_Msg();
    ::ServerData::CheckServerStatusResp* temp = _impl_.Msg_.checkserverstatusresp_;
    _impl_.Msg_.checkserverstatusresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_checkserverstatusresp(::ServerData::CheckServerStatusResp* checkserverstatusresp) {
  clear_Msg();
  if (checkserverstatusresp) {
    set_has_checkserverstatusresp();
    _impl_.Msg_.checkserverstatusresp_ = checkserverstatusresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.CheckServerStatusResp)
}
inline ::ServerData::CheckServerStatusResp* RelayRemoteMessage::_internal_mutable_checkserverstatusresp() {
  if (!_internal_has_checkserverstatusresp()) {
    clear_Msg();
    set_has_checkserverstatusresp();
    _impl_.Msg_.checkserverstatusresp_ = CreateMaybeMessage< ::ServerData::CheckServerStatusResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.checkserverstatusresp_;
}
inline ::ServerData::CheckServerStatusResp* RelayRemoteMessage::mutable_checkserverstatusresp() {
  ::ServerData::CheckServerStatusResp* _msg = _internal_mutable_checkserverstatusresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.CheckServerStatusResp)
  return _msg;
}

// .ServerData.GetAudioInputDevicesResp GetAudioInputDevicesResp = 20;
inline bool RelayRemoteMessage::_internal_has_getaudioinputdevicesresp() const {
  return Msg_case() == kGetAudioInputDevicesResp;
}
inline bool RelayRemoteMessage::has_getaudioinputdevicesresp() const {
  return _internal_has_getaudioinputdevicesresp();
}
inline void RelayRemoteMessage::set_has_getaudioinputdevicesresp() {
  _impl_._oneof_case_[0] = kGetAudioInputDevicesResp;
}
inline void RelayRemoteMessage::clear_getaudioinputdevicesresp() {
  if (_internal_has_getaudioinputdevicesresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.getaudioinputdevicesresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::GetAudioInputDevicesResp* RelayRemoteMessage::release_getaudioinputdevicesresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.GetAudioInputDevicesResp)
  if (_internal_has_getaudioinputdevicesresp()) {
    clear_has_Msg();
    ::ServerData::GetAudioInputDevicesResp* temp = _impl_.Msg_.getaudioinputdevicesresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.getaudioinputdevicesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::GetAudioInputDevicesResp& RelayRemoteMessage::_internal_getaudioinputdevicesresp() const {
  return _internal_has_getaudioinputdevicesresp()
      ? *_impl_.Msg_.getaudioinputdevicesresp_
      : reinterpret_cast< ::ServerData::GetAudioInputDevicesResp&>(::ServerData::_GetAudioInputDevicesResp_default_instance_);
}
inline const ::ServerData::GetAudioInputDevicesResp& RelayRemoteMessage::getaudioinputdevicesresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.GetAudioInputDevicesResp)
  return _internal_getaudioinputdevicesresp();
}
inline ::ServerData::GetAudioInputDevicesResp* RelayRemoteMessage::unsafe_arena_release_getaudioinputdevicesresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.GetAudioInputDevicesResp)
  if (_internal_has_getaudioinputdevicesresp()) {
    clear_has_Msg();
    ::ServerData::GetAudioInputDevicesResp* temp = _impl_.Msg_.getaudioinputdevicesresp_;
    _impl_.Msg_.getaudioinputdevicesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_getaudioinputdevicesresp(::ServerData::GetAudioInputDevicesResp* getaudioinputdevicesresp) {
  clear_Msg();
  if (getaudioinputdevicesresp) {
    set_has_getaudioinputdevicesresp();
    _impl_.Msg_.getaudioinputdevicesresp_ = getaudioinputdevicesresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.GetAudioInputDevicesResp)
}
inline ::ServerData::GetAudioInputDevicesResp* RelayRemoteMessage::_internal_mutable_getaudioinputdevicesresp() {
  if (!_internal_has_getaudioinputdevicesresp()) {
    clear_Msg();
    set_has_getaudioinputdevicesresp();
    _impl_.Msg_.getaudioinputdevicesresp_ = CreateMaybeMessage< ::ServerData::GetAudioInputDevicesResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.getaudioinputdevicesresp_;
}
inline ::ServerData::GetAudioInputDevicesResp* RelayRemoteMessage::mutable_getaudioinputdevicesresp() {
  ::ServerData::GetAudioInputDevicesResp* _msg = _internal_mutable_getaudioinputdevicesresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.GetAudioInputDevicesResp)
  return _msg;
}

// .ServerData.GetAudioOutputDevicesResp GetAudioOutputDevicesResp = 21;
inline bool RelayRemoteMessage::_internal_has_getaudiooutputdevicesresp() const {
  return Msg_case() == kGetAudioOutputDevicesResp;
}
inline bool RelayRemoteMessage::has_getaudiooutputdevicesresp() const {
  return _internal_has_getaudiooutputdevicesresp();
}
inline void RelayRemoteMessage::set_has_getaudiooutputdevicesresp() {
  _impl_._oneof_case_[0] = kGetAudioOutputDevicesResp;
}
inline void RelayRemoteMessage::clear_getaudiooutputdevicesresp() {
  if (_internal_has_getaudiooutputdevicesresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.getaudiooutputdevicesresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::GetAudioOutputDevicesResp* RelayRemoteMessage::release_getaudiooutputdevicesresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.GetAudioOutputDevicesResp)
  if (_internal_has_getaudiooutputdevicesresp()) {
    clear_has_Msg();
    ::ServerData::GetAudioOutputDevicesResp* temp = _impl_.Msg_.getaudiooutputdevicesresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.getaudiooutputdevicesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::GetAudioOutputDevicesResp& RelayRemoteMessage::_internal_getaudiooutputdevicesresp() const {
  return _internal_has_getaudiooutputdevicesresp()
      ? *_impl_.Msg_.getaudiooutputdevicesresp_
      : reinterpret_cast< ::ServerData::GetAudioOutputDevicesResp&>(::ServerData::_GetAudioOutputDevicesResp_default_instance_);
}
inline const ::ServerData::GetAudioOutputDevicesResp& RelayRemoteMessage::getaudiooutputdevicesresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.GetAudioOutputDevicesResp)
  return _internal_getaudiooutputdevicesresp();
}
inline ::ServerData::GetAudioOutputDevicesResp* RelayRemoteMessage::unsafe_arena_release_getaudiooutputdevicesresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.GetAudioOutputDevicesResp)
  if (_internal_has_getaudiooutputdevicesresp()) {
    clear_has_Msg();
    ::ServerData::GetAudioOutputDevicesResp* temp = _impl_.Msg_.getaudiooutputdevicesresp_;
    _impl_.Msg_.getaudiooutputdevicesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_getaudiooutputdevicesresp(::ServerData::GetAudioOutputDevicesResp* getaudiooutputdevicesresp) {
  clear_Msg();
  if (getaudiooutputdevicesresp) {
    set_has_getaudiooutputdevicesresp();
    _impl_.Msg_.getaudiooutputdevicesresp_ = getaudiooutputdevicesresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.GetAudioOutputDevicesResp)
}
inline ::ServerData::GetAudioOutputDevicesResp* RelayRemoteMessage::_internal_mutable_getaudiooutputdevicesresp() {
  if (!_internal_has_getaudiooutputdevicesresp()) {
    clear_Msg();
    set_has_getaudiooutputdevicesresp();
    _impl_.Msg_.getaudiooutputdevicesresp_ = CreateMaybeMessage< ::ServerData::GetAudioOutputDevicesResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.getaudiooutputdevicesresp_;
}
inline ::ServerData::GetAudioOutputDevicesResp* RelayRemoteMessage::mutable_getaudiooutputdevicesresp() {
  ::ServerData::GetAudioOutputDevicesResp* _msg = _internal_mutable_getaudiooutputdevicesresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.GetAudioOutputDevicesResp)
  return _msg;
}

// .ServerData.GetVideoInputDevicesResp GetVideoInputDevicesResp = 22;
inline bool RelayRemoteMessage::_internal_has_getvideoinputdevicesresp() const {
  return Msg_case() == kGetVideoInputDevicesResp;
}
inline bool RelayRemoteMessage::has_getvideoinputdevicesresp() const {
  return _internal_has_getvideoinputdevicesresp();
}
inline void RelayRemoteMessage::set_has_getvideoinputdevicesresp() {
  _impl_._oneof_case_[0] = kGetVideoInputDevicesResp;
}
inline void RelayRemoteMessage::clear_getvideoinputdevicesresp() {
  if (_internal_has_getvideoinputdevicesresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.getvideoinputdevicesresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::GetVideoInputDevicesResp* RelayRemoteMessage::release_getvideoinputdevicesresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.GetVideoInputDevicesResp)
  if (_internal_has_getvideoinputdevicesresp()) {
    clear_has_Msg();
    ::ServerData::GetVideoInputDevicesResp* temp = _impl_.Msg_.getvideoinputdevicesresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.getvideoinputdevicesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::GetVideoInputDevicesResp& RelayRemoteMessage::_internal_getvideoinputdevicesresp() const {
  return _internal_has_getvideoinputdevicesresp()
      ? *_impl_.Msg_.getvideoinputdevicesresp_
      : reinterpret_cast< ::ServerData::GetVideoInputDevicesResp&>(::ServerData::_GetVideoInputDevicesResp_default_instance_);
}
inline const ::ServerData::GetVideoInputDevicesResp& RelayRemoteMessage::getvideoinputdevicesresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.GetVideoInputDevicesResp)
  return _internal_getvideoinputdevicesresp();
}
inline ::ServerData::GetVideoInputDevicesResp* RelayRemoteMessage::unsafe_arena_release_getvideoinputdevicesresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.GetVideoInputDevicesResp)
  if (_internal_has_getvideoinputdevicesresp()) {
    clear_has_Msg();
    ::ServerData::GetVideoInputDevicesResp* temp = _impl_.Msg_.getvideoinputdevicesresp_;
    _impl_.Msg_.getvideoinputdevicesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_getvideoinputdevicesresp(::ServerData::GetVideoInputDevicesResp* getvideoinputdevicesresp) {
  clear_Msg();
  if (getvideoinputdevicesresp) {
    set_has_getvideoinputdevicesresp();
    _impl_.Msg_.getvideoinputdevicesresp_ = getvideoinputdevicesresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.GetVideoInputDevicesResp)
}
inline ::ServerData::GetVideoInputDevicesResp* RelayRemoteMessage::_internal_mutable_getvideoinputdevicesresp() {
  if (!_internal_has_getvideoinputdevicesresp()) {
    clear_Msg();
    set_has_getvideoinputdevicesresp();
    _impl_.Msg_.getvideoinputdevicesresp_ = CreateMaybeMessage< ::ServerData::GetVideoInputDevicesResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.getvideoinputdevicesresp_;
}
inline ::ServerData::GetVideoInputDevicesResp* RelayRemoteMessage::mutable_getvideoinputdevicesresp() {
  ::ServerData::GetVideoInputDevicesResp* _msg = _internal_mutable_getvideoinputdevicesresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.GetVideoInputDevicesResp)
  return _msg;
}

// .ServerData.FetchAllUserAccountsResp FetchAllUserAccountsResp = 23;
inline bool RelayRemoteMessage::_internal_has_fetchalluseraccountsresp() const {
  return Msg_case() == kFetchAllUserAccountsResp;
}
inline bool RelayRemoteMessage::has_fetchalluseraccountsresp() const {
  return _internal_has_fetchalluseraccountsresp();
}
inline void RelayRemoteMessage::set_has_fetchalluseraccountsresp() {
  _impl_._oneof_case_[0] = kFetchAllUserAccountsResp;
}
inline void RelayRemoteMessage::clear_fetchalluseraccountsresp() {
  if (_internal_has_fetchalluseraccountsresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchalluseraccountsresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchAllUserAccountsResp* RelayRemoteMessage::release_fetchalluseraccountsresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.FetchAllUserAccountsResp)
  if (_internal_has_fetchalluseraccountsresp()) {
    clear_has_Msg();
    ::ServerData::FetchAllUserAccountsResp* temp = _impl_.Msg_.fetchalluseraccountsresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchalluseraccountsresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchAllUserAccountsResp& RelayRemoteMessage::_internal_fetchalluseraccountsresp() const {
  return _internal_has_fetchalluseraccountsresp()
      ? *_impl_.Msg_.fetchalluseraccountsresp_
      : reinterpret_cast< ::ServerData::FetchAllUserAccountsResp&>(::ServerData::_FetchAllUserAccountsResp_default_instance_);
}
inline const ::ServerData::FetchAllUserAccountsResp& RelayRemoteMessage::fetchalluseraccountsresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.FetchAllUserAccountsResp)
  return _internal_fetchalluseraccountsresp();
}
inline ::ServerData::FetchAllUserAccountsResp* RelayRemoteMessage::unsafe_arena_release_fetchalluseraccountsresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.FetchAllUserAccountsResp)
  if (_internal_has_fetchalluseraccountsresp()) {
    clear_has_Msg();
    ::ServerData::FetchAllUserAccountsResp* temp = _impl_.Msg_.fetchalluseraccountsresp_;
    _impl_.Msg_.fetchalluseraccountsresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_fetchalluseraccountsresp(::ServerData::FetchAllUserAccountsResp* fetchalluseraccountsresp) {
  clear_Msg();
  if (fetchalluseraccountsresp) {
    set_has_fetchalluseraccountsresp();
    _impl_.Msg_.fetchalluseraccountsresp_ = fetchalluseraccountsresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.FetchAllUserAccountsResp)
}
inline ::ServerData::FetchAllUserAccountsResp* RelayRemoteMessage::_internal_mutable_fetchalluseraccountsresp() {
  if (!_internal_has_fetchalluseraccountsresp()) {
    clear_Msg();
    set_has_fetchalluseraccountsresp();
    _impl_.Msg_.fetchalluseraccountsresp_ = CreateMaybeMessage< ::ServerData::FetchAllUserAccountsResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchalluseraccountsresp_;
}
inline ::ServerData::FetchAllUserAccountsResp* RelayRemoteMessage::mutable_fetchalluseraccountsresp() {
  ::ServerData::FetchAllUserAccountsResp* _msg = _internal_mutable_fetchalluseraccountsresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.FetchAllUserAccountsResp)
  return _msg;
}

// .ServerData.FetchAllUserRolesResp FetchAllUserRolesResp = 26;
inline bool RelayRemoteMessage::_internal_has_fetchalluserrolesresp() const {
  return Msg_case() == kFetchAllUserRolesResp;
}
inline bool RelayRemoteMessage::has_fetchalluserrolesresp() const {
  return _internal_has_fetchalluserrolesresp();
}
inline void RelayRemoteMessage::set_has_fetchalluserrolesresp() {
  _impl_._oneof_case_[0] = kFetchAllUserRolesResp;
}
inline void RelayRemoteMessage::clear_fetchalluserrolesresp() {
  if (_internal_has_fetchalluserrolesresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchalluserrolesresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchAllUserRolesResp* RelayRemoteMessage::release_fetchalluserrolesresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.FetchAllUserRolesResp)
  if (_internal_has_fetchalluserrolesresp()) {
    clear_has_Msg();
    ::ServerData::FetchAllUserRolesResp* temp = _impl_.Msg_.fetchalluserrolesresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchalluserrolesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchAllUserRolesResp& RelayRemoteMessage::_internal_fetchalluserrolesresp() const {
  return _internal_has_fetchalluserrolesresp()
      ? *_impl_.Msg_.fetchalluserrolesresp_
      : reinterpret_cast< ::ServerData::FetchAllUserRolesResp&>(::ServerData::_FetchAllUserRolesResp_default_instance_);
}
inline const ::ServerData::FetchAllUserRolesResp& RelayRemoteMessage::fetchalluserrolesresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.FetchAllUserRolesResp)
  return _internal_fetchalluserrolesresp();
}
inline ::ServerData::FetchAllUserRolesResp* RelayRemoteMessage::unsafe_arena_release_fetchalluserrolesresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.FetchAllUserRolesResp)
  if (_internal_has_fetchalluserrolesresp()) {
    clear_has_Msg();
    ::ServerData::FetchAllUserRolesResp* temp = _impl_.Msg_.fetchalluserrolesresp_;
    _impl_.Msg_.fetchalluserrolesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_fetchalluserrolesresp(::ServerData::FetchAllUserRolesResp* fetchalluserrolesresp) {
  clear_Msg();
  if (fetchalluserrolesresp) {
    set_has_fetchalluserrolesresp();
    _impl_.Msg_.fetchalluserrolesresp_ = fetchalluserrolesresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.FetchAllUserRolesResp)
}
inline ::ServerData::FetchAllUserRolesResp* RelayRemoteMessage::_internal_mutable_fetchalluserrolesresp() {
  if (!_internal_has_fetchalluserrolesresp()) {
    clear_Msg();
    set_has_fetchalluserrolesresp();
    _impl_.Msg_.fetchalluserrolesresp_ = CreateMaybeMessage< ::ServerData::FetchAllUserRolesResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchalluserrolesresp_;
}
inline ::ServerData::FetchAllUserRolesResp* RelayRemoteMessage::mutable_fetchalluserrolesresp() {
  ::ServerData::FetchAllUserRolesResp* _msg = _internal_mutable_fetchalluserrolesresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.FetchAllUserRolesResp)
  return _msg;
}

// .ServerData.PropertyValueStatus PropertyValueStatus = 50;
inline bool RelayRemoteMessage::_internal_has_propertyvaluestatus() const {
  return Msg_case() == kPropertyValueStatus;
}
inline bool RelayRemoteMessage::has_propertyvaluestatus() const {
  return _internal_has_propertyvaluestatus();
}
inline void RelayRemoteMessage::set_has_propertyvaluestatus() {
  _impl_._oneof_case_[0] = kPropertyValueStatus;
}
inline void RelayRemoteMessage::clear_propertyvaluestatus() {
  if (_internal_has_propertyvaluestatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.propertyvaluestatus_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PropertyValueStatus* RelayRemoteMessage::release_propertyvaluestatus() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.PropertyValueStatus)
  if (_internal_has_propertyvaluestatus()) {
    clear_has_Msg();
    ::ServerData::PropertyValueStatus* temp = _impl_.Msg_.propertyvaluestatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.propertyvaluestatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PropertyValueStatus& RelayRemoteMessage::_internal_propertyvaluestatus() const {
  return _internal_has_propertyvaluestatus()
      ? *_impl_.Msg_.propertyvaluestatus_
      : reinterpret_cast< ::ServerData::PropertyValueStatus&>(::ServerData::_PropertyValueStatus_default_instance_);
}
inline const ::ServerData::PropertyValueStatus& RelayRemoteMessage::propertyvaluestatus() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.PropertyValueStatus)
  return _internal_propertyvaluestatus();
}
inline ::ServerData::PropertyValueStatus* RelayRemoteMessage::unsafe_arena_release_propertyvaluestatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.PropertyValueStatus)
  if (_internal_has_propertyvaluestatus()) {
    clear_has_Msg();
    ::ServerData::PropertyValueStatus* temp = _impl_.Msg_.propertyvaluestatus_;
    _impl_.Msg_.propertyvaluestatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_propertyvaluestatus(::ServerData::PropertyValueStatus* propertyvaluestatus) {
  clear_Msg();
  if (propertyvaluestatus) {
    set_has_propertyvaluestatus();
    _impl_.Msg_.propertyvaluestatus_ = propertyvaluestatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.PropertyValueStatus)
}
inline ::ServerData::PropertyValueStatus* RelayRemoteMessage::_internal_mutable_propertyvaluestatus() {
  if (!_internal_has_propertyvaluestatus()) {
    clear_Msg();
    set_has_propertyvaluestatus();
    _impl_.Msg_.propertyvaluestatus_ = CreateMaybeMessage< ::ServerData::PropertyValueStatus >(GetArenaForAllocation());
  }
  return _impl_.Msg_.propertyvaluestatus_;
}
inline ::ServerData::PropertyValueStatus* RelayRemoteMessage::mutable_propertyvaluestatus() {
  ::ServerData::PropertyValueStatus* _msg = _internal_mutable_propertyvaluestatus();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.PropertyValueStatus)
  return _msg;
}

// .ServerData.LocalPropertyHandledResp LocalPropertyHandledResp = 51;
inline bool RelayRemoteMessage::_internal_has_localpropertyhandledresp() const {
  return Msg_case() == kLocalPropertyHandledResp;
}
inline bool RelayRemoteMessage::has_localpropertyhandledresp() const {
  return _internal_has_localpropertyhandledresp();
}
inline void RelayRemoteMessage::set_has_localpropertyhandledresp() {
  _impl_._oneof_case_[0] = kLocalPropertyHandledResp;
}
inline void RelayRemoteMessage::clear_localpropertyhandledresp() {
  if (_internal_has_localpropertyhandledresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.localpropertyhandledresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::LocalPropertyHandledResp* RelayRemoteMessage::release_localpropertyhandledresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.LocalPropertyHandledResp)
  if (_internal_has_localpropertyhandledresp()) {
    clear_has_Msg();
    ::ServerData::LocalPropertyHandledResp* temp = _impl_.Msg_.localpropertyhandledresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.localpropertyhandledresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::LocalPropertyHandledResp& RelayRemoteMessage::_internal_localpropertyhandledresp() const {
  return _internal_has_localpropertyhandledresp()
      ? *_impl_.Msg_.localpropertyhandledresp_
      : reinterpret_cast< ::ServerData::LocalPropertyHandledResp&>(::ServerData::_LocalPropertyHandledResp_default_instance_);
}
inline const ::ServerData::LocalPropertyHandledResp& RelayRemoteMessage::localpropertyhandledresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.LocalPropertyHandledResp)
  return _internal_localpropertyhandledresp();
}
inline ::ServerData::LocalPropertyHandledResp* RelayRemoteMessage::unsafe_arena_release_localpropertyhandledresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.LocalPropertyHandledResp)
  if (_internal_has_localpropertyhandledresp()) {
    clear_has_Msg();
    ::ServerData::LocalPropertyHandledResp* temp = _impl_.Msg_.localpropertyhandledresp_;
    _impl_.Msg_.localpropertyhandledresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_localpropertyhandledresp(::ServerData::LocalPropertyHandledResp* localpropertyhandledresp) {
  clear_Msg();
  if (localpropertyhandledresp) {
    set_has_localpropertyhandledresp();
    _impl_.Msg_.localpropertyhandledresp_ = localpropertyhandledresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.LocalPropertyHandledResp)
}
inline ::ServerData::LocalPropertyHandledResp* RelayRemoteMessage::_internal_mutable_localpropertyhandledresp() {
  if (!_internal_has_localpropertyhandledresp()) {
    clear_Msg();
    set_has_localpropertyhandledresp();
    _impl_.Msg_.localpropertyhandledresp_ = CreateMaybeMessage< ::ServerData::LocalPropertyHandledResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.localpropertyhandledresp_;
}
inline ::ServerData::LocalPropertyHandledResp* RelayRemoteMessage::mutable_localpropertyhandledresp() {
  ::ServerData::LocalPropertyHandledResp* _msg = _internal_mutable_localpropertyhandledresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.LocalPropertyHandledResp)
  return _msg;
}

// .ServerData.PropMetadataStatus PropMetadataStatus = 52;
inline bool RelayRemoteMessage::_internal_has_propmetadatastatus() const {
  return Msg_case() == kPropMetadataStatus;
}
inline bool RelayRemoteMessage::has_propmetadatastatus() const {
  return _internal_has_propmetadatastatus();
}
inline void RelayRemoteMessage::set_has_propmetadatastatus() {
  _impl_._oneof_case_[0] = kPropMetadataStatus;
}
inline void RelayRemoteMessage::clear_propmetadatastatus() {
  if (_internal_has_propmetadatastatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.propmetadatastatus_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PropMetadataStatus* RelayRemoteMessage::release_propmetadatastatus() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.PropMetadataStatus)
  if (_internal_has_propmetadatastatus()) {
    clear_has_Msg();
    ::ServerData::PropMetadataStatus* temp = _impl_.Msg_.propmetadatastatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.propmetadatastatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PropMetadataStatus& RelayRemoteMessage::_internal_propmetadatastatus() const {
  return _internal_has_propmetadatastatus()
      ? *_impl_.Msg_.propmetadatastatus_
      : reinterpret_cast< ::ServerData::PropMetadataStatus&>(::ServerData::_PropMetadataStatus_default_instance_);
}
inline const ::ServerData::PropMetadataStatus& RelayRemoteMessage::propmetadatastatus() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.PropMetadataStatus)
  return _internal_propmetadatastatus();
}
inline ::ServerData::PropMetadataStatus* RelayRemoteMessage::unsafe_arena_release_propmetadatastatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.PropMetadataStatus)
  if (_internal_has_propmetadatastatus()) {
    clear_has_Msg();
    ::ServerData::PropMetadataStatus* temp = _impl_.Msg_.propmetadatastatus_;
    _impl_.Msg_.propmetadatastatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_propmetadatastatus(::ServerData::PropMetadataStatus* propmetadatastatus) {
  clear_Msg();
  if (propmetadatastatus) {
    set_has_propmetadatastatus();
    _impl_.Msg_.propmetadatastatus_ = propmetadatastatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.PropMetadataStatus)
}
inline ::ServerData::PropMetadataStatus* RelayRemoteMessage::_internal_mutable_propmetadatastatus() {
  if (!_internal_has_propmetadatastatus()) {
    clear_Msg();
    set_has_propmetadatastatus();
    _impl_.Msg_.propmetadatastatus_ = CreateMaybeMessage< ::ServerData::PropMetadataStatus >(GetArenaForAllocation());
  }
  return _impl_.Msg_.propmetadatastatus_;
}
inline ::ServerData::PropMetadataStatus* RelayRemoteMessage::mutable_propmetadatastatus() {
  ::ServerData::PropMetadataStatus* _msg = _internal_mutable_propmetadatastatus();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.PropMetadataStatus)
  return _msg;
}

// .ServerData.UserAdded UserAdded = 60;
inline bool RelayRemoteMessage::_internal_has_useradded() const {
  return Msg_case() == kUserAdded;
}
inline bool RelayRemoteMessage::has_useradded() const {
  return _internal_has_useradded();
}
inline void RelayRemoteMessage::set_has_useradded() {
  _impl_._oneof_case_[0] = kUserAdded;
}
inline void RelayRemoteMessage::clear_useradded() {
  if (_internal_has_useradded()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.useradded_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UserAdded* RelayRemoteMessage::release_useradded() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.UserAdded)
  if (_internal_has_useradded()) {
    clear_has_Msg();
    ::ServerData::UserAdded* temp = _impl_.Msg_.useradded_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.useradded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UserAdded& RelayRemoteMessage::_internal_useradded() const {
  return _internal_has_useradded()
      ? *_impl_.Msg_.useradded_
      : reinterpret_cast< ::ServerData::UserAdded&>(::ServerData::_UserAdded_default_instance_);
}
inline const ::ServerData::UserAdded& RelayRemoteMessage::useradded() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.UserAdded)
  return _internal_useradded();
}
inline ::ServerData::UserAdded* RelayRemoteMessage::unsafe_arena_release_useradded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.UserAdded)
  if (_internal_has_useradded()) {
    clear_has_Msg();
    ::ServerData::UserAdded* temp = _impl_.Msg_.useradded_;
    _impl_.Msg_.useradded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_useradded(::ServerData::UserAdded* useradded) {
  clear_Msg();
  if (useradded) {
    set_has_useradded();
    _impl_.Msg_.useradded_ = useradded;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.UserAdded)
}
inline ::ServerData::UserAdded* RelayRemoteMessage::_internal_mutable_useradded() {
  if (!_internal_has_useradded()) {
    clear_Msg();
    set_has_useradded();
    _impl_.Msg_.useradded_ = CreateMaybeMessage< ::ServerData::UserAdded >(GetArenaForAllocation());
  }
  return _impl_.Msg_.useradded_;
}
inline ::ServerData::UserAdded* RelayRemoteMessage::mutable_useradded() {
  ::ServerData::UserAdded* _msg = _internal_mutable_useradded();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.UserAdded)
  return _msg;
}

// .ServerData.UserRemoved UserRemoved = 61;
inline bool RelayRemoteMessage::_internal_has_userremoved() const {
  return Msg_case() == kUserRemoved;
}
inline bool RelayRemoteMessage::has_userremoved() const {
  return _internal_has_userremoved();
}
inline void RelayRemoteMessage::set_has_userremoved() {
  _impl_._oneof_case_[0] = kUserRemoved;
}
inline void RelayRemoteMessage::clear_userremoved() {
  if (_internal_has_userremoved()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.userremoved_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UserRemoved* RelayRemoteMessage::release_userremoved() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.UserRemoved)
  if (_internal_has_userremoved()) {
    clear_has_Msg();
    ::ServerData::UserRemoved* temp = _impl_.Msg_.userremoved_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.userremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UserRemoved& RelayRemoteMessage::_internal_userremoved() const {
  return _internal_has_userremoved()
      ? *_impl_.Msg_.userremoved_
      : reinterpret_cast< ::ServerData::UserRemoved&>(::ServerData::_UserRemoved_default_instance_);
}
inline const ::ServerData::UserRemoved& RelayRemoteMessage::userremoved() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.UserRemoved)
  return _internal_userremoved();
}
inline ::ServerData::UserRemoved* RelayRemoteMessage::unsafe_arena_release_userremoved() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.UserRemoved)
  if (_internal_has_userremoved()) {
    clear_has_Msg();
    ::ServerData::UserRemoved* temp = _impl_.Msg_.userremoved_;
    _impl_.Msg_.userremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_userremoved(::ServerData::UserRemoved* userremoved) {
  clear_Msg();
  if (userremoved) {
    set_has_userremoved();
    _impl_.Msg_.userremoved_ = userremoved;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.UserRemoved)
}
inline ::ServerData::UserRemoved* RelayRemoteMessage::_internal_mutable_userremoved() {
  if (!_internal_has_userremoved()) {
    clear_Msg();
    set_has_userremoved();
    _impl_.Msg_.userremoved_ = CreateMaybeMessage< ::ServerData::UserRemoved >(GetArenaForAllocation());
  }
  return _impl_.Msg_.userremoved_;
}
inline ::ServerData::UserRemoved* RelayRemoteMessage::mutable_userremoved() {
  ::ServerData::UserRemoved* _msg = _internal_mutable_userremoved();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.UserRemoved)
  return _msg;
}

// .ServerData.UserVideoFrame UserVideoFrame = 65;
inline bool RelayRemoteMessage::_internal_has_uservideoframe() const {
  return Msg_case() == kUserVideoFrame;
}
inline bool RelayRemoteMessage::has_uservideoframe() const {
  return _internal_has_uservideoframe();
}
inline void RelayRemoteMessage::set_has_uservideoframe() {
  _impl_._oneof_case_[0] = kUserVideoFrame;
}
inline void RelayRemoteMessage::clear_uservideoframe() {
  if (_internal_has_uservideoframe()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.uservideoframe_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UserVideoFrame* RelayRemoteMessage::release_uservideoframe() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.UserVideoFrame)
  if (_internal_has_uservideoframe()) {
    clear_has_Msg();
    ::ServerData::UserVideoFrame* temp = _impl_.Msg_.uservideoframe_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.uservideoframe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UserVideoFrame& RelayRemoteMessage::_internal_uservideoframe() const {
  return _internal_has_uservideoframe()
      ? *_impl_.Msg_.uservideoframe_
      : reinterpret_cast< ::ServerData::UserVideoFrame&>(::ServerData::_UserVideoFrame_default_instance_);
}
inline const ::ServerData::UserVideoFrame& RelayRemoteMessage::uservideoframe() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.UserVideoFrame)
  return _internal_uservideoframe();
}
inline ::ServerData::UserVideoFrame* RelayRemoteMessage::unsafe_arena_release_uservideoframe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.UserVideoFrame)
  if (_internal_has_uservideoframe()) {
    clear_has_Msg();
    ::ServerData::UserVideoFrame* temp = _impl_.Msg_.uservideoframe_;
    _impl_.Msg_.uservideoframe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_uservideoframe(::ServerData::UserVideoFrame* uservideoframe) {
  clear_Msg();
  if (uservideoframe) {
    set_has_uservideoframe();
    _impl_.Msg_.uservideoframe_ = uservideoframe;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.UserVideoFrame)
}
inline ::ServerData::UserVideoFrame* RelayRemoteMessage::_internal_mutable_uservideoframe() {
  if (!_internal_has_uservideoframe()) {
    clear_Msg();
    set_has_uservideoframe();
    _impl_.Msg_.uservideoframe_ = CreateMaybeMessage< ::ServerData::UserVideoFrame >(GetArenaForAllocation());
  }
  return _impl_.Msg_.uservideoframe_;
}
inline ::ServerData::UserVideoFrame* RelayRemoteMessage::mutable_uservideoframe() {
  ::ServerData::UserVideoFrame* _msg = _internal_mutable_uservideoframe();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.UserVideoFrame)
  return _msg;
}

// .ServerData.SpaceInfo SpaceAdded = 70;
inline bool RelayRemoteMessage::_internal_has_spaceadded() const {
  return Msg_case() == kSpaceAdded;
}
inline bool RelayRemoteMessage::has_spaceadded() const {
  return _internal_has_spaceadded();
}
inline void RelayRemoteMessage::set_has_spaceadded() {
  _impl_._oneof_case_[0] = kSpaceAdded;
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::release_spaceadded() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.SpaceAdded)
  if (_internal_has_spaceadded()) {
    clear_has_Msg();
    ::ServerData::SpaceInfo* temp = _impl_.Msg_.spaceadded_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.spaceadded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::SpaceInfo& RelayRemoteMessage::_internal_spaceadded() const {
  return _internal_has_spaceadded()
      ? *_impl_.Msg_.spaceadded_
      : reinterpret_cast< ::ServerData::SpaceInfo&>(::ServerData::_SpaceInfo_default_instance_);
}
inline const ::ServerData::SpaceInfo& RelayRemoteMessage::spaceadded() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.SpaceAdded)
  return _internal_spaceadded();
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::unsafe_arena_release_spaceadded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.SpaceAdded)
  if (_internal_has_spaceadded()) {
    clear_has_Msg();
    ::ServerData::SpaceInfo* temp = _impl_.Msg_.spaceadded_;
    _impl_.Msg_.spaceadded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_spaceadded(::ServerData::SpaceInfo* spaceadded) {
  clear_Msg();
  if (spaceadded) {
    set_has_spaceadded();
    _impl_.Msg_.spaceadded_ = spaceadded;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.SpaceAdded)
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::_internal_mutable_spaceadded() {
  if (!_internal_has_spaceadded()) {
    clear_Msg();
    set_has_spaceadded();
    _impl_.Msg_.spaceadded_ = CreateMaybeMessage< ::ServerData::SpaceInfo >(GetArenaForAllocation());
  }
  return _impl_.Msg_.spaceadded_;
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::mutable_spaceadded() {
  ::ServerData::SpaceInfo* _msg = _internal_mutable_spaceadded();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.SpaceAdded)
  return _msg;
}

// .ServerData.SpaceInfo SpaceUpdated = 71;
inline bool RelayRemoteMessage::_internal_has_spaceupdated() const {
  return Msg_case() == kSpaceUpdated;
}
inline bool RelayRemoteMessage::has_spaceupdated() const {
  return _internal_has_spaceupdated();
}
inline void RelayRemoteMessage::set_has_spaceupdated() {
  _impl_._oneof_case_[0] = kSpaceUpdated;
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::release_spaceupdated() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.SpaceUpdated)
  if (_internal_has_spaceupdated()) {
    clear_has_Msg();
    ::ServerData::SpaceInfo* temp = _impl_.Msg_.spaceupdated_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.spaceupdated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::SpaceInfo& RelayRemoteMessage::_internal_spaceupdated() const {
  return _internal_has_spaceupdated()
      ? *_impl_.Msg_.spaceupdated_
      : reinterpret_cast< ::ServerData::SpaceInfo&>(::ServerData::_SpaceInfo_default_instance_);
}
inline const ::ServerData::SpaceInfo& RelayRemoteMessage::spaceupdated() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.SpaceUpdated)
  return _internal_spaceupdated();
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::unsafe_arena_release_spaceupdated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.SpaceUpdated)
  if (_internal_has_spaceupdated()) {
    clear_has_Msg();
    ::ServerData::SpaceInfo* temp = _impl_.Msg_.spaceupdated_;
    _impl_.Msg_.spaceupdated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_spaceupdated(::ServerData::SpaceInfo* spaceupdated) {
  clear_Msg();
  if (spaceupdated) {
    set_has_spaceupdated();
    _impl_.Msg_.spaceupdated_ = spaceupdated;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.SpaceUpdated)
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::_internal_mutable_spaceupdated() {
  if (!_internal_has_spaceupdated()) {
    clear_Msg();
    set_has_spaceupdated();
    _impl_.Msg_.spaceupdated_ = CreateMaybeMessage< ::ServerData::SpaceInfo >(GetArenaForAllocation());
  }
  return _impl_.Msg_.spaceupdated_;
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::mutable_spaceupdated() {
  ::ServerData::SpaceInfo* _msg = _internal_mutable_spaceupdated();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.SpaceUpdated)
  return _msg;
}

// .ServerData.SpaceInfo SpaceRemoved = 72;
inline bool RelayRemoteMessage::_internal_has_spaceremoved() const {
  return Msg_case() == kSpaceRemoved;
}
inline bool RelayRemoteMessage::has_spaceremoved() const {
  return _internal_has_spaceremoved();
}
inline void RelayRemoteMessage::set_has_spaceremoved() {
  _impl_._oneof_case_[0] = kSpaceRemoved;
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::release_spaceremoved() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.SpaceRemoved)
  if (_internal_has_spaceremoved()) {
    clear_has_Msg();
    ::ServerData::SpaceInfo* temp = _impl_.Msg_.spaceremoved_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.spaceremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::SpaceInfo& RelayRemoteMessage::_internal_spaceremoved() const {
  return _internal_has_spaceremoved()
      ? *_impl_.Msg_.spaceremoved_
      : reinterpret_cast< ::ServerData::SpaceInfo&>(::ServerData::_SpaceInfo_default_instance_);
}
inline const ::ServerData::SpaceInfo& RelayRemoteMessage::spaceremoved() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.SpaceRemoved)
  return _internal_spaceremoved();
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::unsafe_arena_release_spaceremoved() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.SpaceRemoved)
  if (_internal_has_spaceremoved()) {
    clear_has_Msg();
    ::ServerData::SpaceInfo* temp = _impl_.Msg_.spaceremoved_;
    _impl_.Msg_.spaceremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_spaceremoved(::ServerData::SpaceInfo* spaceremoved) {
  clear_Msg();
  if (spaceremoved) {
    set_has_spaceremoved();
    _impl_.Msg_.spaceremoved_ = spaceremoved;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.SpaceRemoved)
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::_internal_mutable_spaceremoved() {
  if (!_internal_has_spaceremoved()) {
    clear_Msg();
    set_has_spaceremoved();
    _impl_.Msg_.spaceremoved_ = CreateMaybeMessage< ::ServerData::SpaceInfo >(GetArenaForAllocation());
  }
  return _impl_.Msg_.spaceremoved_;
}
inline ::ServerData::SpaceInfo* RelayRemoteMessage::mutable_spaceremoved() {
  ::ServerData::SpaceInfo* _msg = _internal_mutable_spaceremoved();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.SpaceRemoved)
  return _msg;
}

// .ServerData.ObjectAdded ObjectAdded = 80;
inline bool RelayRemoteMessage::_internal_has_objectadded() const {
  return Msg_case() == kObjectAdded;
}
inline bool RelayRemoteMessage::has_objectadded() const {
  return _internal_has_objectadded();
}
inline void RelayRemoteMessage::set_has_objectadded() {
  _impl_._oneof_case_[0] = kObjectAdded;
}
inline void RelayRemoteMessage::clear_objectadded() {
  if (_internal_has_objectadded()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.objectadded_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ObjectAdded* RelayRemoteMessage::release_objectadded() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ObjectAdded)
  if (_internal_has_objectadded()) {
    clear_has_Msg();
    ::ServerData::ObjectAdded* temp = _impl_.Msg_.objectadded_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.objectadded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ObjectAdded& RelayRemoteMessage::_internal_objectadded() const {
  return _internal_has_objectadded()
      ? *_impl_.Msg_.objectadded_
      : reinterpret_cast< ::ServerData::ObjectAdded&>(::ServerData::_ObjectAdded_default_instance_);
}
inline const ::ServerData::ObjectAdded& RelayRemoteMessage::objectadded() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ObjectAdded)
  return _internal_objectadded();
}
inline ::ServerData::ObjectAdded* RelayRemoteMessage::unsafe_arena_release_objectadded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ObjectAdded)
  if (_internal_has_objectadded()) {
    clear_has_Msg();
    ::ServerData::ObjectAdded* temp = _impl_.Msg_.objectadded_;
    _impl_.Msg_.objectadded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_objectadded(::ServerData::ObjectAdded* objectadded) {
  clear_Msg();
  if (objectadded) {
    set_has_objectadded();
    _impl_.Msg_.objectadded_ = objectadded;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ObjectAdded)
}
inline ::ServerData::ObjectAdded* RelayRemoteMessage::_internal_mutable_objectadded() {
  if (!_internal_has_objectadded()) {
    clear_Msg();
    set_has_objectadded();
    _impl_.Msg_.objectadded_ = CreateMaybeMessage< ::ServerData::ObjectAdded >(GetArenaForAllocation());
  }
  return _impl_.Msg_.objectadded_;
}
inline ::ServerData::ObjectAdded* RelayRemoteMessage::mutable_objectadded() {
  ::ServerData::ObjectAdded* _msg = _internal_mutable_objectadded();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ObjectAdded)
  return _msg;
}

// .ServerData.ObjectRemoved ObjectRemoved = 81;
inline bool RelayRemoteMessage::_internal_has_objectremoved() const {
  return Msg_case() == kObjectRemoved;
}
inline bool RelayRemoteMessage::has_objectremoved() const {
  return _internal_has_objectremoved();
}
inline void RelayRemoteMessage::set_has_objectremoved() {
  _impl_._oneof_case_[0] = kObjectRemoved;
}
inline void RelayRemoteMessage::clear_objectremoved() {
  if (_internal_has_objectremoved()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.objectremoved_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ObjectRemoved* RelayRemoteMessage::release_objectremoved() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ObjectRemoved)
  if (_internal_has_objectremoved()) {
    clear_has_Msg();
    ::ServerData::ObjectRemoved* temp = _impl_.Msg_.objectremoved_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.objectremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ObjectRemoved& RelayRemoteMessage::_internal_objectremoved() const {
  return _internal_has_objectremoved()
      ? *_impl_.Msg_.objectremoved_
      : reinterpret_cast< ::ServerData::ObjectRemoved&>(::ServerData::_ObjectRemoved_default_instance_);
}
inline const ::ServerData::ObjectRemoved& RelayRemoteMessage::objectremoved() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ObjectRemoved)
  return _internal_objectremoved();
}
inline ::ServerData::ObjectRemoved* RelayRemoteMessage::unsafe_arena_release_objectremoved() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ObjectRemoved)
  if (_internal_has_objectremoved()) {
    clear_has_Msg();
    ::ServerData::ObjectRemoved* temp = _impl_.Msg_.objectremoved_;
    _impl_.Msg_.objectremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_objectremoved(::ServerData::ObjectRemoved* objectremoved) {
  clear_Msg();
  if (objectremoved) {
    set_has_objectremoved();
    _impl_.Msg_.objectremoved_ = objectremoved;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ObjectRemoved)
}
inline ::ServerData::ObjectRemoved* RelayRemoteMessage::_internal_mutable_objectremoved() {
  if (!_internal_has_objectremoved()) {
    clear_Msg();
    set_has_objectremoved();
    _impl_.Msg_.objectremoved_ = CreateMaybeMessage< ::ServerData::ObjectRemoved >(GetArenaForAllocation());
  }
  return _impl_.Msg_.objectremoved_;
}
inline ::ServerData::ObjectRemoved* RelayRemoteMessage::mutable_objectremoved() {
  ::ServerData::ObjectRemoved* _msg = _internal_mutable_objectremoved();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ObjectRemoved)
  return _msg;
}

// .ServerData.PermissionStatus PermissionStatus = 90;
inline bool RelayRemoteMessage::_internal_has_permissionstatus() const {
  return Msg_case() == kPermissionStatus;
}
inline bool RelayRemoteMessage::has_permissionstatus() const {
  return _internal_has_permissionstatus();
}
inline void RelayRemoteMessage::set_has_permissionstatus() {
  _impl_._oneof_case_[0] = kPermissionStatus;
}
inline void RelayRemoteMessage::clear_permissionstatus() {
  if (_internal_has_permissionstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.permissionstatus_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::PermissionStatus* RelayRemoteMessage::release_permissionstatus() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.PermissionStatus)
  if (_internal_has_permissionstatus()) {
    clear_has_Msg();
    ::ServerData::PermissionStatus* temp = _impl_.Msg_.permissionstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.permissionstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::PermissionStatus& RelayRemoteMessage::_internal_permissionstatus() const {
  return _internal_has_permissionstatus()
      ? *_impl_.Msg_.permissionstatus_
      : reinterpret_cast< ::ServerData::PermissionStatus&>(::ServerData::_PermissionStatus_default_instance_);
}
inline const ::ServerData::PermissionStatus& RelayRemoteMessage::permissionstatus() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.PermissionStatus)
  return _internal_permissionstatus();
}
inline ::ServerData::PermissionStatus* RelayRemoteMessage::unsafe_arena_release_permissionstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.PermissionStatus)
  if (_internal_has_permissionstatus()) {
    clear_has_Msg();
    ::ServerData::PermissionStatus* temp = _impl_.Msg_.permissionstatus_;
    _impl_.Msg_.permissionstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_permissionstatus(::ServerData::PermissionStatus* permissionstatus) {
  clear_Msg();
  if (permissionstatus) {
    set_has_permissionstatus();
    _impl_.Msg_.permissionstatus_ = permissionstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.PermissionStatus)
}
inline ::ServerData::PermissionStatus* RelayRemoteMessage::_internal_mutable_permissionstatus() {
  if (!_internal_has_permissionstatus()) {
    clear_Msg();
    set_has_permissionstatus();
    _impl_.Msg_.permissionstatus_ = CreateMaybeMessage< ::ServerData::PermissionStatus >(GetArenaForAllocation());
  }
  return _impl_.Msg_.permissionstatus_;
}
inline ::ServerData::PermissionStatus* RelayRemoteMessage::mutable_permissionstatus() {
  ::ServerData::PermissionStatus* _msg = _internal_mutable_permissionstatus();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.PermissionStatus)
  return _msg;
}

// .ServerData.AllJoinableSpacesResp AllJoinableSpacesResp = 100;
inline bool RelayRemoteMessage::_internal_has_alljoinablespacesresp() const {
  return Msg_case() == kAllJoinableSpacesResp;
}
inline bool RelayRemoteMessage::has_alljoinablespacesresp() const {
  return _internal_has_alljoinablespacesresp();
}
inline void RelayRemoteMessage::set_has_alljoinablespacesresp() {
  _impl_._oneof_case_[0] = kAllJoinableSpacesResp;
}
inline void RelayRemoteMessage::clear_alljoinablespacesresp() {
  if (_internal_has_alljoinablespacesresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.alljoinablespacesresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::AllJoinableSpacesResp* RelayRemoteMessage::release_alljoinablespacesresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.AllJoinableSpacesResp)
  if (_internal_has_alljoinablespacesresp()) {
    clear_has_Msg();
    ::ServerData::AllJoinableSpacesResp* temp = _impl_.Msg_.alljoinablespacesresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.alljoinablespacesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::AllJoinableSpacesResp& RelayRemoteMessage::_internal_alljoinablespacesresp() const {
  return _internal_has_alljoinablespacesresp()
      ? *_impl_.Msg_.alljoinablespacesresp_
      : reinterpret_cast< ::ServerData::AllJoinableSpacesResp&>(::ServerData::_AllJoinableSpacesResp_default_instance_);
}
inline const ::ServerData::AllJoinableSpacesResp& RelayRemoteMessage::alljoinablespacesresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.AllJoinableSpacesResp)
  return _internal_alljoinablespacesresp();
}
inline ::ServerData::AllJoinableSpacesResp* RelayRemoteMessage::unsafe_arena_release_alljoinablespacesresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.AllJoinableSpacesResp)
  if (_internal_has_alljoinablespacesresp()) {
    clear_has_Msg();
    ::ServerData::AllJoinableSpacesResp* temp = _impl_.Msg_.alljoinablespacesresp_;
    _impl_.Msg_.alljoinablespacesresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_alljoinablespacesresp(::ServerData::AllJoinableSpacesResp* alljoinablespacesresp) {
  clear_Msg();
  if (alljoinablespacesresp) {
    set_has_alljoinablespacesresp();
    _impl_.Msg_.alljoinablespacesresp_ = alljoinablespacesresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.AllJoinableSpacesResp)
}
inline ::ServerData::AllJoinableSpacesResp* RelayRemoteMessage::_internal_mutable_alljoinablespacesresp() {
  if (!_internal_has_alljoinablespacesresp()) {
    clear_Msg();
    set_has_alljoinablespacesresp();
    _impl_.Msg_.alljoinablespacesresp_ = CreateMaybeMessage< ::ServerData::AllJoinableSpacesResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.alljoinablespacesresp_;
}
inline ::ServerData::AllJoinableSpacesResp* RelayRemoteMessage::mutable_alljoinablespacesresp() {
  ::ServerData::AllJoinableSpacesResp* _msg = _internal_mutable_alljoinablespacesresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.AllJoinableSpacesResp)
  return _msg;
}

// .ServerData.GetSpaceInfoResp GetSpaceInfoResp = 101;
inline bool RelayRemoteMessage::_internal_has_getspaceinforesp() const {
  return Msg_case() == kGetSpaceInfoResp;
}
inline bool RelayRemoteMessage::has_getspaceinforesp() const {
  return _internal_has_getspaceinforesp();
}
inline void RelayRemoteMessage::set_has_getspaceinforesp() {
  _impl_._oneof_case_[0] = kGetSpaceInfoResp;
}
inline void RelayRemoteMessage::clear_getspaceinforesp() {
  if (_internal_has_getspaceinforesp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.getspaceinforesp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::GetSpaceInfoResp* RelayRemoteMessage::release_getspaceinforesp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.GetSpaceInfoResp)
  if (_internal_has_getspaceinforesp()) {
    clear_has_Msg();
    ::ServerData::GetSpaceInfoResp* temp = _impl_.Msg_.getspaceinforesp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.getspaceinforesp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::GetSpaceInfoResp& RelayRemoteMessage::_internal_getspaceinforesp() const {
  return _internal_has_getspaceinforesp()
      ? *_impl_.Msg_.getspaceinforesp_
      : reinterpret_cast< ::ServerData::GetSpaceInfoResp&>(::ServerData::_GetSpaceInfoResp_default_instance_);
}
inline const ::ServerData::GetSpaceInfoResp& RelayRemoteMessage::getspaceinforesp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.GetSpaceInfoResp)
  return _internal_getspaceinforesp();
}
inline ::ServerData::GetSpaceInfoResp* RelayRemoteMessage::unsafe_arena_release_getspaceinforesp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.GetSpaceInfoResp)
  if (_internal_has_getspaceinforesp()) {
    clear_has_Msg();
    ::ServerData::GetSpaceInfoResp* temp = _impl_.Msg_.getspaceinforesp_;
    _impl_.Msg_.getspaceinforesp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_getspaceinforesp(::ServerData::GetSpaceInfoResp* getspaceinforesp) {
  clear_Msg();
  if (getspaceinforesp) {
    set_has_getspaceinforesp();
    _impl_.Msg_.getspaceinforesp_ = getspaceinforesp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.GetSpaceInfoResp)
}
inline ::ServerData::GetSpaceInfoResp* RelayRemoteMessage::_internal_mutable_getspaceinforesp() {
  if (!_internal_has_getspaceinforesp()) {
    clear_Msg();
    set_has_getspaceinforesp();
    _impl_.Msg_.getspaceinforesp_ = CreateMaybeMessage< ::ServerData::GetSpaceInfoResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.getspaceinforesp_;
}
inline ::ServerData::GetSpaceInfoResp* RelayRemoteMessage::mutable_getspaceinforesp() {
  ::ServerData::GetSpaceInfoResp* _msg = _internal_mutable_getspaceinforesp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.GetSpaceInfoResp)
  return _msg;
}

// .ServerData.FetchFileByIdProgressResp FetchFileByIdProgressResp = 110;
inline bool RelayRemoteMessage::_internal_has_fetchfilebyidprogressresp() const {
  return Msg_case() == kFetchFileByIdProgressResp;
}
inline bool RelayRemoteMessage::has_fetchfilebyidprogressresp() const {
  return _internal_has_fetchfilebyidprogressresp();
}
inline void RelayRemoteMessage::set_has_fetchfilebyidprogressresp() {
  _impl_._oneof_case_[0] = kFetchFileByIdProgressResp;
}
inline void RelayRemoteMessage::clear_fetchfilebyidprogressresp() {
  if (_internal_has_fetchfilebyidprogressresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchfilebyidprogressresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchFileByIdProgressResp* RelayRemoteMessage::release_fetchfilebyidprogressresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.FetchFileByIdProgressResp)
  if (_internal_has_fetchfilebyidprogressresp()) {
    clear_has_Msg();
    ::ServerData::FetchFileByIdProgressResp* temp = _impl_.Msg_.fetchfilebyidprogressresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchfilebyidprogressresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchFileByIdProgressResp& RelayRemoteMessage::_internal_fetchfilebyidprogressresp() const {
  return _internal_has_fetchfilebyidprogressresp()
      ? *_impl_.Msg_.fetchfilebyidprogressresp_
      : reinterpret_cast< ::ServerData::FetchFileByIdProgressResp&>(::ServerData::_FetchFileByIdProgressResp_default_instance_);
}
inline const ::ServerData::FetchFileByIdProgressResp& RelayRemoteMessage::fetchfilebyidprogressresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.FetchFileByIdProgressResp)
  return _internal_fetchfilebyidprogressresp();
}
inline ::ServerData::FetchFileByIdProgressResp* RelayRemoteMessage::unsafe_arena_release_fetchfilebyidprogressresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.FetchFileByIdProgressResp)
  if (_internal_has_fetchfilebyidprogressresp()) {
    clear_has_Msg();
    ::ServerData::FetchFileByIdProgressResp* temp = _impl_.Msg_.fetchfilebyidprogressresp_;
    _impl_.Msg_.fetchfilebyidprogressresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_fetchfilebyidprogressresp(::ServerData::FetchFileByIdProgressResp* fetchfilebyidprogressresp) {
  clear_Msg();
  if (fetchfilebyidprogressresp) {
    set_has_fetchfilebyidprogressresp();
    _impl_.Msg_.fetchfilebyidprogressresp_ = fetchfilebyidprogressresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.FetchFileByIdProgressResp)
}
inline ::ServerData::FetchFileByIdProgressResp* RelayRemoteMessage::_internal_mutable_fetchfilebyidprogressresp() {
  if (!_internal_has_fetchfilebyidprogressresp()) {
    clear_Msg();
    set_has_fetchfilebyidprogressresp();
    _impl_.Msg_.fetchfilebyidprogressresp_ = CreateMaybeMessage< ::ServerData::FetchFileByIdProgressResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchfilebyidprogressresp_;
}
inline ::ServerData::FetchFileByIdProgressResp* RelayRemoteMessage::mutable_fetchfilebyidprogressresp() {
  ::ServerData::FetchFileByIdProgressResp* _msg = _internal_mutable_fetchfilebyidprogressresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.FetchFileByIdProgressResp)
  return _msg;
}

// .ServerData.FetchFileByIdCompletedResp FetchFileByIdCompletedResp = 111;
inline bool RelayRemoteMessage::_internal_has_fetchfilebyidcompletedresp() const {
  return Msg_case() == kFetchFileByIdCompletedResp;
}
inline bool RelayRemoteMessage::has_fetchfilebyidcompletedresp() const {
  return _internal_has_fetchfilebyidcompletedresp();
}
inline void RelayRemoteMessage::set_has_fetchfilebyidcompletedresp() {
  _impl_._oneof_case_[0] = kFetchFileByIdCompletedResp;
}
inline void RelayRemoteMessage::clear_fetchfilebyidcompletedresp() {
  if (_internal_has_fetchfilebyidcompletedresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchfilebyidcompletedresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchFileByIdCompletedResp* RelayRemoteMessage::release_fetchfilebyidcompletedresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.FetchFileByIdCompletedResp)
  if (_internal_has_fetchfilebyidcompletedresp()) {
    clear_has_Msg();
    ::ServerData::FetchFileByIdCompletedResp* temp = _impl_.Msg_.fetchfilebyidcompletedresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchfilebyidcompletedresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchFileByIdCompletedResp& RelayRemoteMessage::_internal_fetchfilebyidcompletedresp() const {
  return _internal_has_fetchfilebyidcompletedresp()
      ? *_impl_.Msg_.fetchfilebyidcompletedresp_
      : reinterpret_cast< ::ServerData::FetchFileByIdCompletedResp&>(::ServerData::_FetchFileByIdCompletedResp_default_instance_);
}
inline const ::ServerData::FetchFileByIdCompletedResp& RelayRemoteMessage::fetchfilebyidcompletedresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.FetchFileByIdCompletedResp)
  return _internal_fetchfilebyidcompletedresp();
}
inline ::ServerData::FetchFileByIdCompletedResp* RelayRemoteMessage::unsafe_arena_release_fetchfilebyidcompletedresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.FetchFileByIdCompletedResp)
  if (_internal_has_fetchfilebyidcompletedresp()) {
    clear_has_Msg();
    ::ServerData::FetchFileByIdCompletedResp* temp = _impl_.Msg_.fetchfilebyidcompletedresp_;
    _impl_.Msg_.fetchfilebyidcompletedresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_fetchfilebyidcompletedresp(::ServerData::FetchFileByIdCompletedResp* fetchfilebyidcompletedresp) {
  clear_Msg();
  if (fetchfilebyidcompletedresp) {
    set_has_fetchfilebyidcompletedresp();
    _impl_.Msg_.fetchfilebyidcompletedresp_ = fetchfilebyidcompletedresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.FetchFileByIdCompletedResp)
}
inline ::ServerData::FetchFileByIdCompletedResp* RelayRemoteMessage::_internal_mutable_fetchfilebyidcompletedresp() {
  if (!_internal_has_fetchfilebyidcompletedresp()) {
    clear_Msg();
    set_has_fetchfilebyidcompletedresp();
    _impl_.Msg_.fetchfilebyidcompletedresp_ = CreateMaybeMessage< ::ServerData::FetchFileByIdCompletedResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchfilebyidcompletedresp_;
}
inline ::ServerData::FetchFileByIdCompletedResp* RelayRemoteMessage::mutable_fetchfilebyidcompletedresp() {
  ::ServerData::FetchFileByIdCompletedResp* _msg = _internal_mutable_fetchfilebyidcompletedresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.FetchFileByIdCompletedResp)
  return _msg;
}

// .ServerData.FetchFileByIdFailureResp FetchFileByIdFailureResp = 119;
inline bool RelayRemoteMessage::_internal_has_fetchfilebyidfailureresp() const {
  return Msg_case() == kFetchFileByIdFailureResp;
}
inline bool RelayRemoteMessage::has_fetchfilebyidfailureresp() const {
  return _internal_has_fetchfilebyidfailureresp();
}
inline void RelayRemoteMessage::set_has_fetchfilebyidfailureresp() {
  _impl_._oneof_case_[0] = kFetchFileByIdFailureResp;
}
inline void RelayRemoteMessage::clear_fetchfilebyidfailureresp() {
  if (_internal_has_fetchfilebyidfailureresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchfilebyidfailureresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchFileByIdFailureResp* RelayRemoteMessage::release_fetchfilebyidfailureresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.FetchFileByIdFailureResp)
  if (_internal_has_fetchfilebyidfailureresp()) {
    clear_has_Msg();
    ::ServerData::FetchFileByIdFailureResp* temp = _impl_.Msg_.fetchfilebyidfailureresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchfilebyidfailureresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchFileByIdFailureResp& RelayRemoteMessage::_internal_fetchfilebyidfailureresp() const {
  return _internal_has_fetchfilebyidfailureresp()
      ? *_impl_.Msg_.fetchfilebyidfailureresp_
      : reinterpret_cast< ::ServerData::FetchFileByIdFailureResp&>(::ServerData::_FetchFileByIdFailureResp_default_instance_);
}
inline const ::ServerData::FetchFileByIdFailureResp& RelayRemoteMessage::fetchfilebyidfailureresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.FetchFileByIdFailureResp)
  return _internal_fetchfilebyidfailureresp();
}
inline ::ServerData::FetchFileByIdFailureResp* RelayRemoteMessage::unsafe_arena_release_fetchfilebyidfailureresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.FetchFileByIdFailureResp)
  if (_internal_has_fetchfilebyidfailureresp()) {
    clear_has_Msg();
    ::ServerData::FetchFileByIdFailureResp* temp = _impl_.Msg_.fetchfilebyidfailureresp_;
    _impl_.Msg_.fetchfilebyidfailureresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_fetchfilebyidfailureresp(::ServerData::FetchFileByIdFailureResp* fetchfilebyidfailureresp) {
  clear_Msg();
  if (fetchfilebyidfailureresp) {
    set_has_fetchfilebyidfailureresp();
    _impl_.Msg_.fetchfilebyidfailureresp_ = fetchfilebyidfailureresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.FetchFileByIdFailureResp)
}
inline ::ServerData::FetchFileByIdFailureResp* RelayRemoteMessage::_internal_mutable_fetchfilebyidfailureresp() {
  if (!_internal_has_fetchfilebyidfailureresp()) {
    clear_Msg();
    set_has_fetchfilebyidfailureresp();
    _impl_.Msg_.fetchfilebyidfailureresp_ = CreateMaybeMessage< ::ServerData::FetchFileByIdFailureResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchfilebyidfailureresp_;
}
inline ::ServerData::FetchFileByIdFailureResp* RelayRemoteMessage::mutable_fetchfilebyidfailureresp() {
  ::ServerData::FetchFileByIdFailureResp* _msg = _internal_mutable_fetchfilebyidfailureresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.FetchFileByIdFailureResp)
  return _msg;
}

// .ServerData.FetchAllUploadedContentResp FetchAllUploadedContentResp = 112;
inline bool RelayRemoteMessage::_internal_has_fetchalluploadedcontentresp() const {
  return Msg_case() == kFetchAllUploadedContentResp;
}
inline bool RelayRemoteMessage::has_fetchalluploadedcontentresp() const {
  return _internal_has_fetchalluploadedcontentresp();
}
inline void RelayRemoteMessage::set_has_fetchalluploadedcontentresp() {
  _impl_._oneof_case_[0] = kFetchAllUploadedContentResp;
}
inline void RelayRemoteMessage::clear_fetchalluploadedcontentresp() {
  if (_internal_has_fetchalluploadedcontentresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchalluploadedcontentresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchAllUploadedContentResp* RelayRemoteMessage::release_fetchalluploadedcontentresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.FetchAllUploadedContentResp)
  if (_internal_has_fetchalluploadedcontentresp()) {
    clear_has_Msg();
    ::ServerData::FetchAllUploadedContentResp* temp = _impl_.Msg_.fetchalluploadedcontentresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchalluploadedcontentresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchAllUploadedContentResp& RelayRemoteMessage::_internal_fetchalluploadedcontentresp() const {
  return _internal_has_fetchalluploadedcontentresp()
      ? *_impl_.Msg_.fetchalluploadedcontentresp_
      : reinterpret_cast< ::ServerData::FetchAllUploadedContentResp&>(::ServerData::_FetchAllUploadedContentResp_default_instance_);
}
inline const ::ServerData::FetchAllUploadedContentResp& RelayRemoteMessage::fetchalluploadedcontentresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.FetchAllUploadedContentResp)
  return _internal_fetchalluploadedcontentresp();
}
inline ::ServerData::FetchAllUploadedContentResp* RelayRemoteMessage::unsafe_arena_release_fetchalluploadedcontentresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.FetchAllUploadedContentResp)
  if (_internal_has_fetchalluploadedcontentresp()) {
    clear_has_Msg();
    ::ServerData::FetchAllUploadedContentResp* temp = _impl_.Msg_.fetchalluploadedcontentresp_;
    _impl_.Msg_.fetchalluploadedcontentresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_fetchalluploadedcontentresp(::ServerData::FetchAllUploadedContentResp* fetchalluploadedcontentresp) {
  clear_Msg();
  if (fetchalluploadedcontentresp) {
    set_has_fetchalluploadedcontentresp();
    _impl_.Msg_.fetchalluploadedcontentresp_ = fetchalluploadedcontentresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.FetchAllUploadedContentResp)
}
inline ::ServerData::FetchAllUploadedContentResp* RelayRemoteMessage::_internal_mutable_fetchalluploadedcontentresp() {
  if (!_internal_has_fetchalluploadedcontentresp()) {
    clear_Msg();
    set_has_fetchalluploadedcontentresp();
    _impl_.Msg_.fetchalluploadedcontentresp_ = CreateMaybeMessage< ::ServerData::FetchAllUploadedContentResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchalluploadedcontentresp_;
}
inline ::ServerData::FetchAllUploadedContentResp* RelayRemoteMessage::mutable_fetchalluploadedcontentresp() {
  ::ServerData::FetchAllUploadedContentResp* _msg = _internal_mutable_fetchalluploadedcontentresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.FetchAllUploadedContentResp)
  return _msg;
}

// .ServerData.UploadLocalFileResp UploadLocalFileResp = 113;
inline bool RelayRemoteMessage::_internal_has_uploadlocalfileresp() const {
  return Msg_case() == kUploadLocalFileResp;
}
inline bool RelayRemoteMessage::has_uploadlocalfileresp() const {
  return _internal_has_uploadlocalfileresp();
}
inline void RelayRemoteMessage::set_has_uploadlocalfileresp() {
  _impl_._oneof_case_[0] = kUploadLocalFileResp;
}
inline void RelayRemoteMessage::clear_uploadlocalfileresp() {
  if (_internal_has_uploadlocalfileresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.uploadlocalfileresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UploadLocalFileResp* RelayRemoteMessage::release_uploadlocalfileresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.UploadLocalFileResp)
  if (_internal_has_uploadlocalfileresp()) {
    clear_has_Msg();
    ::ServerData::UploadLocalFileResp* temp = _impl_.Msg_.uploadlocalfileresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.uploadlocalfileresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UploadLocalFileResp& RelayRemoteMessage::_internal_uploadlocalfileresp() const {
  return _internal_has_uploadlocalfileresp()
      ? *_impl_.Msg_.uploadlocalfileresp_
      : reinterpret_cast< ::ServerData::UploadLocalFileResp&>(::ServerData::_UploadLocalFileResp_default_instance_);
}
inline const ::ServerData::UploadLocalFileResp& RelayRemoteMessage::uploadlocalfileresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.UploadLocalFileResp)
  return _internal_uploadlocalfileresp();
}
inline ::ServerData::UploadLocalFileResp* RelayRemoteMessage::unsafe_arena_release_uploadlocalfileresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.UploadLocalFileResp)
  if (_internal_has_uploadlocalfileresp()) {
    clear_has_Msg();
    ::ServerData::UploadLocalFileResp* temp = _impl_.Msg_.uploadlocalfileresp_;
    _impl_.Msg_.uploadlocalfileresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_uploadlocalfileresp(::ServerData::UploadLocalFileResp* uploadlocalfileresp) {
  clear_Msg();
  if (uploadlocalfileresp) {
    set_has_uploadlocalfileresp();
    _impl_.Msg_.uploadlocalfileresp_ = uploadlocalfileresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.UploadLocalFileResp)
}
inline ::ServerData::UploadLocalFileResp* RelayRemoteMessage::_internal_mutable_uploadlocalfileresp() {
  if (!_internal_has_uploadlocalfileresp()) {
    clear_Msg();
    set_has_uploadlocalfileresp();
    _impl_.Msg_.uploadlocalfileresp_ = CreateMaybeMessage< ::ServerData::UploadLocalFileResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.uploadlocalfileresp_;
}
inline ::ServerData::UploadLocalFileResp* RelayRemoteMessage::mutable_uploadlocalfileresp() {
  ::ServerData::UploadLocalFileResp* _msg = _internal_mutable_uploadlocalfileresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.UploadLocalFileResp)
  return _msg;
}

// .ServerData.ContentDestinationFolderResp ContentDestinationFolderResp = 114;
inline bool RelayRemoteMessage::_internal_has_contentdestinationfolderresp() const {
  return Msg_case() == kContentDestinationFolderResp;
}
inline bool RelayRemoteMessage::has_contentdestinationfolderresp() const {
  return _internal_has_contentdestinationfolderresp();
}
inline void RelayRemoteMessage::set_has_contentdestinationfolderresp() {
  _impl_._oneof_case_[0] = kContentDestinationFolderResp;
}
inline void RelayRemoteMessage::clear_contentdestinationfolderresp() {
  if (_internal_has_contentdestinationfolderresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.contentdestinationfolderresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ContentDestinationFolderResp* RelayRemoteMessage::release_contentdestinationfolderresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ContentDestinationFolderResp)
  if (_internal_has_contentdestinationfolderresp()) {
    clear_has_Msg();
    ::ServerData::ContentDestinationFolderResp* temp = _impl_.Msg_.contentdestinationfolderresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.contentdestinationfolderresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ContentDestinationFolderResp& RelayRemoteMessage::_internal_contentdestinationfolderresp() const {
  return _internal_has_contentdestinationfolderresp()
      ? *_impl_.Msg_.contentdestinationfolderresp_
      : reinterpret_cast< ::ServerData::ContentDestinationFolderResp&>(::ServerData::_ContentDestinationFolderResp_default_instance_);
}
inline const ::ServerData::ContentDestinationFolderResp& RelayRemoteMessage::contentdestinationfolderresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ContentDestinationFolderResp)
  return _internal_contentdestinationfolderresp();
}
inline ::ServerData::ContentDestinationFolderResp* RelayRemoteMessage::unsafe_arena_release_contentdestinationfolderresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ContentDestinationFolderResp)
  if (_internal_has_contentdestinationfolderresp()) {
    clear_has_Msg();
    ::ServerData::ContentDestinationFolderResp* temp = _impl_.Msg_.contentdestinationfolderresp_;
    _impl_.Msg_.contentdestinationfolderresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_contentdestinationfolderresp(::ServerData::ContentDestinationFolderResp* contentdestinationfolderresp) {
  clear_Msg();
  if (contentdestinationfolderresp) {
    set_has_contentdestinationfolderresp();
    _impl_.Msg_.contentdestinationfolderresp_ = contentdestinationfolderresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ContentDestinationFolderResp)
}
inline ::ServerData::ContentDestinationFolderResp* RelayRemoteMessage::_internal_mutable_contentdestinationfolderresp() {
  if (!_internal_has_contentdestinationfolderresp()) {
    clear_Msg();
    set_has_contentdestinationfolderresp();
    _impl_.Msg_.contentdestinationfolderresp_ = CreateMaybeMessage< ::ServerData::ContentDestinationFolderResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.contentdestinationfolderresp_;
}
inline ::ServerData::ContentDestinationFolderResp* RelayRemoteMessage::mutable_contentdestinationfolderresp() {
  ::ServerData::ContentDestinationFolderResp* _msg = _internal_mutable_contentdestinationfolderresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ContentDestinationFolderResp)
  return _msg;
}

// .ServerData.FetchRemoteContentInfoResp FetchRemoteContentInfoResp = 115;
inline bool RelayRemoteMessage::_internal_has_fetchremotecontentinforesp() const {
  return Msg_case() == kFetchRemoteContentInfoResp;
}
inline bool RelayRemoteMessage::has_fetchremotecontentinforesp() const {
  return _internal_has_fetchremotecontentinforesp();
}
inline void RelayRemoteMessage::set_has_fetchremotecontentinforesp() {
  _impl_._oneof_case_[0] = kFetchRemoteContentInfoResp;
}
inline void RelayRemoteMessage::clear_fetchremotecontentinforesp() {
  if (_internal_has_fetchremotecontentinforesp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.fetchremotecontentinforesp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::FetchRemoteContentInfoResp* RelayRemoteMessage::release_fetchremotecontentinforesp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.FetchRemoteContentInfoResp)
  if (_internal_has_fetchremotecontentinforesp()) {
    clear_has_Msg();
    ::ServerData::FetchRemoteContentInfoResp* temp = _impl_.Msg_.fetchremotecontentinforesp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.fetchremotecontentinforesp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::FetchRemoteContentInfoResp& RelayRemoteMessage::_internal_fetchremotecontentinforesp() const {
  return _internal_has_fetchremotecontentinforesp()
      ? *_impl_.Msg_.fetchremotecontentinforesp_
      : reinterpret_cast< ::ServerData::FetchRemoteContentInfoResp&>(::ServerData::_FetchRemoteContentInfoResp_default_instance_);
}
inline const ::ServerData::FetchRemoteContentInfoResp& RelayRemoteMessage::fetchremotecontentinforesp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.FetchRemoteContentInfoResp)
  return _internal_fetchremotecontentinforesp();
}
inline ::ServerData::FetchRemoteContentInfoResp* RelayRemoteMessage::unsafe_arena_release_fetchremotecontentinforesp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.FetchRemoteContentInfoResp)
  if (_internal_has_fetchremotecontentinforesp()) {
    clear_has_Msg();
    ::ServerData::FetchRemoteContentInfoResp* temp = _impl_.Msg_.fetchremotecontentinforesp_;
    _impl_.Msg_.fetchremotecontentinforesp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_fetchremotecontentinforesp(::ServerData::FetchRemoteContentInfoResp* fetchremotecontentinforesp) {
  clear_Msg();
  if (fetchremotecontentinforesp) {
    set_has_fetchremotecontentinforesp();
    _impl_.Msg_.fetchremotecontentinforesp_ = fetchremotecontentinforesp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.FetchRemoteContentInfoResp)
}
inline ::ServerData::FetchRemoteContentInfoResp* RelayRemoteMessage::_internal_mutable_fetchremotecontentinforesp() {
  if (!_internal_has_fetchremotecontentinforesp()) {
    clear_Msg();
    set_has_fetchremotecontentinforesp();
    _impl_.Msg_.fetchremotecontentinforesp_ = CreateMaybeMessage< ::ServerData::FetchRemoteContentInfoResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.fetchremotecontentinforesp_;
}
inline ::ServerData::FetchRemoteContentInfoResp* RelayRemoteMessage::mutable_fetchremotecontentinforesp() {
  ::ServerData::FetchRemoteContentInfoResp* _msg = _internal_mutable_fetchremotecontentinforesp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.FetchRemoteContentInfoResp)
  return _msg;
}

// .ServerData.RemoteContentAdded RemoteContentAdded = 116;
inline bool RelayRemoteMessage::_internal_has_remotecontentadded() const {
  return Msg_case() == kRemoteContentAdded;
}
inline bool RelayRemoteMessage::has_remotecontentadded() const {
  return _internal_has_remotecontentadded();
}
inline void RelayRemoteMessage::set_has_remotecontentadded() {
  _impl_._oneof_case_[0] = kRemoteContentAdded;
}
inline void RelayRemoteMessage::clear_remotecontentadded() {
  if (_internal_has_remotecontentadded()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.remotecontentadded_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::RemoteContentAdded* RelayRemoteMessage::release_remotecontentadded() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.RemoteContentAdded)
  if (_internal_has_remotecontentadded()) {
    clear_has_Msg();
    ::ServerData::RemoteContentAdded* temp = _impl_.Msg_.remotecontentadded_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.remotecontentadded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::RemoteContentAdded& RelayRemoteMessage::_internal_remotecontentadded() const {
  return _internal_has_remotecontentadded()
      ? *_impl_.Msg_.remotecontentadded_
      : reinterpret_cast< ::ServerData::RemoteContentAdded&>(::ServerData::_RemoteContentAdded_default_instance_);
}
inline const ::ServerData::RemoteContentAdded& RelayRemoteMessage::remotecontentadded() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.RemoteContentAdded)
  return _internal_remotecontentadded();
}
inline ::ServerData::RemoteContentAdded* RelayRemoteMessage::unsafe_arena_release_remotecontentadded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.RemoteContentAdded)
  if (_internal_has_remotecontentadded()) {
    clear_has_Msg();
    ::ServerData::RemoteContentAdded* temp = _impl_.Msg_.remotecontentadded_;
    _impl_.Msg_.remotecontentadded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_remotecontentadded(::ServerData::RemoteContentAdded* remotecontentadded) {
  clear_Msg();
  if (remotecontentadded) {
    set_has_remotecontentadded();
    _impl_.Msg_.remotecontentadded_ = remotecontentadded;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.RemoteContentAdded)
}
inline ::ServerData::RemoteContentAdded* RelayRemoteMessage::_internal_mutable_remotecontentadded() {
  if (!_internal_has_remotecontentadded()) {
    clear_Msg();
    set_has_remotecontentadded();
    _impl_.Msg_.remotecontentadded_ = CreateMaybeMessage< ::ServerData::RemoteContentAdded >(GetArenaForAllocation());
  }
  return _impl_.Msg_.remotecontentadded_;
}
inline ::ServerData::RemoteContentAdded* RelayRemoteMessage::mutable_remotecontentadded() {
  ::ServerData::RemoteContentAdded* _msg = _internal_mutable_remotecontentadded();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.RemoteContentAdded)
  return _msg;
}

// .ServerData.RemoteContentRemoved RemoteContentRemoved = 117;
inline bool RelayRemoteMessage::_internal_has_remotecontentremoved() const {
  return Msg_case() == kRemoteContentRemoved;
}
inline bool RelayRemoteMessage::has_remotecontentremoved() const {
  return _internal_has_remotecontentremoved();
}
inline void RelayRemoteMessage::set_has_remotecontentremoved() {
  _impl_._oneof_case_[0] = kRemoteContentRemoved;
}
inline void RelayRemoteMessage::clear_remotecontentremoved() {
  if (_internal_has_remotecontentremoved()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.remotecontentremoved_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::RemoteContentRemoved* RelayRemoteMessage::release_remotecontentremoved() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.RemoteContentRemoved)
  if (_internal_has_remotecontentremoved()) {
    clear_has_Msg();
    ::ServerData::RemoteContentRemoved* temp = _impl_.Msg_.remotecontentremoved_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.remotecontentremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::RemoteContentRemoved& RelayRemoteMessage::_internal_remotecontentremoved() const {
  return _internal_has_remotecontentremoved()
      ? *_impl_.Msg_.remotecontentremoved_
      : reinterpret_cast< ::ServerData::RemoteContentRemoved&>(::ServerData::_RemoteContentRemoved_default_instance_);
}
inline const ::ServerData::RemoteContentRemoved& RelayRemoteMessage::remotecontentremoved() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.RemoteContentRemoved)
  return _internal_remotecontentremoved();
}
inline ::ServerData::RemoteContentRemoved* RelayRemoteMessage::unsafe_arena_release_remotecontentremoved() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.RemoteContentRemoved)
  if (_internal_has_remotecontentremoved()) {
    clear_has_Msg();
    ::ServerData::RemoteContentRemoved* temp = _impl_.Msg_.remotecontentremoved_;
    _impl_.Msg_.remotecontentremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_remotecontentremoved(::ServerData::RemoteContentRemoved* remotecontentremoved) {
  clear_Msg();
  if (remotecontentremoved) {
    set_has_remotecontentremoved();
    _impl_.Msg_.remotecontentremoved_ = remotecontentremoved;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.RemoteContentRemoved)
}
inline ::ServerData::RemoteContentRemoved* RelayRemoteMessage::_internal_mutable_remotecontentremoved() {
  if (!_internal_has_remotecontentremoved()) {
    clear_Msg();
    set_has_remotecontentremoved();
    _impl_.Msg_.remotecontentremoved_ = CreateMaybeMessage< ::ServerData::RemoteContentRemoved >(GetArenaForAllocation());
  }
  return _impl_.Msg_.remotecontentremoved_;
}
inline ::ServerData::RemoteContentRemoved* RelayRemoteMessage::mutable_remotecontentremoved() {
  ::ServerData::RemoteContentRemoved* _msg = _internal_mutable_remotecontentremoved();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.RemoteContentRemoved)
  return _msg;
}

// .ServerData.UploadLocalFileProgressResp UploadLocalFileProgressResp = 118;
inline bool RelayRemoteMessage::_internal_has_uploadlocalfileprogressresp() const {
  return Msg_case() == kUploadLocalFileProgressResp;
}
inline bool RelayRemoteMessage::has_uploadlocalfileprogressresp() const {
  return _internal_has_uploadlocalfileprogressresp();
}
inline void RelayRemoteMessage::set_has_uploadlocalfileprogressresp() {
  _impl_._oneof_case_[0] = kUploadLocalFileProgressResp;
}
inline void RelayRemoteMessage::clear_uploadlocalfileprogressresp() {
  if (_internal_has_uploadlocalfileprogressresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.uploadlocalfileprogressresp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::UploadLocalFileProgressResp* RelayRemoteMessage::release_uploadlocalfileprogressresp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.UploadLocalFileProgressResp)
  if (_internal_has_uploadlocalfileprogressresp()) {
    clear_has_Msg();
    ::ServerData::UploadLocalFileProgressResp* temp = _impl_.Msg_.uploadlocalfileprogressresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.uploadlocalfileprogressresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::UploadLocalFileProgressResp& RelayRemoteMessage::_internal_uploadlocalfileprogressresp() const {
  return _internal_has_uploadlocalfileprogressresp()
      ? *_impl_.Msg_.uploadlocalfileprogressresp_
      : reinterpret_cast< ::ServerData::UploadLocalFileProgressResp&>(::ServerData::_UploadLocalFileProgressResp_default_instance_);
}
inline const ::ServerData::UploadLocalFileProgressResp& RelayRemoteMessage::uploadlocalfileprogressresp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.UploadLocalFileProgressResp)
  return _internal_uploadlocalfileprogressresp();
}
inline ::ServerData::UploadLocalFileProgressResp* RelayRemoteMessage::unsafe_arena_release_uploadlocalfileprogressresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.UploadLocalFileProgressResp)
  if (_internal_has_uploadlocalfileprogressresp()) {
    clear_has_Msg();
    ::ServerData::UploadLocalFileProgressResp* temp = _impl_.Msg_.uploadlocalfileprogressresp_;
    _impl_.Msg_.uploadlocalfileprogressresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_uploadlocalfileprogressresp(::ServerData::UploadLocalFileProgressResp* uploadlocalfileprogressresp) {
  clear_Msg();
  if (uploadlocalfileprogressresp) {
    set_has_uploadlocalfileprogressresp();
    _impl_.Msg_.uploadlocalfileprogressresp_ = uploadlocalfileprogressresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.UploadLocalFileProgressResp)
}
inline ::ServerData::UploadLocalFileProgressResp* RelayRemoteMessage::_internal_mutable_uploadlocalfileprogressresp() {
  if (!_internal_has_uploadlocalfileprogressresp()) {
    clear_Msg();
    set_has_uploadlocalfileprogressresp();
    _impl_.Msg_.uploadlocalfileprogressresp_ = CreateMaybeMessage< ::ServerData::UploadLocalFileProgressResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.uploadlocalfileprogressresp_;
}
inline ::ServerData::UploadLocalFileProgressResp* RelayRemoteMessage::mutable_uploadlocalfileprogressresp() {
  ::ServerData::UploadLocalFileProgressResp* _msg = _internal_mutable_uploadlocalfileprogressresp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.UploadLocalFileProgressResp)
  return _msg;
}

// .ServerData.ChatAdded ChatAdded = 120;
inline bool RelayRemoteMessage::_internal_has_chatadded() const {
  return Msg_case() == kChatAdded;
}
inline bool RelayRemoteMessage::has_chatadded() const {
  return _internal_has_chatadded();
}
inline void RelayRemoteMessage::set_has_chatadded() {
  _impl_._oneof_case_[0] = kChatAdded;
}
inline void RelayRemoteMessage::clear_chatadded() {
  if (_internal_has_chatadded()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.chatadded_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ChatAdded* RelayRemoteMessage::release_chatadded() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ChatAdded)
  if (_internal_has_chatadded()) {
    clear_has_Msg();
    ::ServerData::ChatAdded* temp = _impl_.Msg_.chatadded_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.chatadded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ChatAdded& RelayRemoteMessage::_internal_chatadded() const {
  return _internal_has_chatadded()
      ? *_impl_.Msg_.chatadded_
      : reinterpret_cast< ::ServerData::ChatAdded&>(::ServerData::_ChatAdded_default_instance_);
}
inline const ::ServerData::ChatAdded& RelayRemoteMessage::chatadded() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ChatAdded)
  return _internal_chatadded();
}
inline ::ServerData::ChatAdded* RelayRemoteMessage::unsafe_arena_release_chatadded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ChatAdded)
  if (_internal_has_chatadded()) {
    clear_has_Msg();
    ::ServerData::ChatAdded* temp = _impl_.Msg_.chatadded_;
    _impl_.Msg_.chatadded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_chatadded(::ServerData::ChatAdded* chatadded) {
  clear_Msg();
  if (chatadded) {
    set_has_chatadded();
    _impl_.Msg_.chatadded_ = chatadded;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ChatAdded)
}
inline ::ServerData::ChatAdded* RelayRemoteMessage::_internal_mutable_chatadded() {
  if (!_internal_has_chatadded()) {
    clear_Msg();
    set_has_chatadded();
    _impl_.Msg_.chatadded_ = CreateMaybeMessage< ::ServerData::ChatAdded >(GetArenaForAllocation());
  }
  return _impl_.Msg_.chatadded_;
}
inline ::ServerData::ChatAdded* RelayRemoteMessage::mutable_chatadded() {
  ::ServerData::ChatAdded* _msg = _internal_mutable_chatadded();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ChatAdded)
  return _msg;
}

// .ServerData.ChatUpdated ChatUpdated = 121;
inline bool RelayRemoteMessage::_internal_has_chatupdated() const {
  return Msg_case() == kChatUpdated;
}
inline bool RelayRemoteMessage::has_chatupdated() const {
  return _internal_has_chatupdated();
}
inline void RelayRemoteMessage::set_has_chatupdated() {
  _impl_._oneof_case_[0] = kChatUpdated;
}
inline void RelayRemoteMessage::clear_chatupdated() {
  if (_internal_has_chatupdated()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.chatupdated_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ChatUpdated* RelayRemoteMessage::release_chatupdated() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ChatUpdated)
  if (_internal_has_chatupdated()) {
    clear_has_Msg();
    ::ServerData::ChatUpdated* temp = _impl_.Msg_.chatupdated_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.chatupdated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ChatUpdated& RelayRemoteMessage::_internal_chatupdated() const {
  return _internal_has_chatupdated()
      ? *_impl_.Msg_.chatupdated_
      : reinterpret_cast< ::ServerData::ChatUpdated&>(::ServerData::_ChatUpdated_default_instance_);
}
inline const ::ServerData::ChatUpdated& RelayRemoteMessage::chatupdated() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ChatUpdated)
  return _internal_chatupdated();
}
inline ::ServerData::ChatUpdated* RelayRemoteMessage::unsafe_arena_release_chatupdated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ChatUpdated)
  if (_internal_has_chatupdated()) {
    clear_has_Msg();
    ::ServerData::ChatUpdated* temp = _impl_.Msg_.chatupdated_;
    _impl_.Msg_.chatupdated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_chatupdated(::ServerData::ChatUpdated* chatupdated) {
  clear_Msg();
  if (chatupdated) {
    set_has_chatupdated();
    _impl_.Msg_.chatupdated_ = chatupdated;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ChatUpdated)
}
inline ::ServerData::ChatUpdated* RelayRemoteMessage::_internal_mutable_chatupdated() {
  if (!_internal_has_chatupdated()) {
    clear_Msg();
    set_has_chatupdated();
    _impl_.Msg_.chatupdated_ = CreateMaybeMessage< ::ServerData::ChatUpdated >(GetArenaForAllocation());
  }
  return _impl_.Msg_.chatupdated_;
}
inline ::ServerData::ChatUpdated* RelayRemoteMessage::mutable_chatupdated() {
  ::ServerData::ChatUpdated* _msg = _internal_mutable_chatupdated();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ChatUpdated)
  return _msg;
}

// .ServerData.ChatRemoved ChatRemoved = 122;
inline bool RelayRemoteMessage::_internal_has_chatremoved() const {
  return Msg_case() == kChatRemoved;
}
inline bool RelayRemoteMessage::has_chatremoved() const {
  return _internal_has_chatremoved();
}
inline void RelayRemoteMessage::set_has_chatremoved() {
  _impl_._oneof_case_[0] = kChatRemoved;
}
inline void RelayRemoteMessage::clear_chatremoved() {
  if (_internal_has_chatremoved()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.chatremoved_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::ChatRemoved* RelayRemoteMessage::release_chatremoved() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.ChatRemoved)
  if (_internal_has_chatremoved()) {
    clear_has_Msg();
    ::ServerData::ChatRemoved* temp = _impl_.Msg_.chatremoved_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.chatremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::ChatRemoved& RelayRemoteMessage::_internal_chatremoved() const {
  return _internal_has_chatremoved()
      ? *_impl_.Msg_.chatremoved_
      : reinterpret_cast< ::ServerData::ChatRemoved&>(::ServerData::_ChatRemoved_default_instance_);
}
inline const ::ServerData::ChatRemoved& RelayRemoteMessage::chatremoved() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.ChatRemoved)
  return _internal_chatremoved();
}
inline ::ServerData::ChatRemoved* RelayRemoteMessage::unsafe_arena_release_chatremoved() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.ChatRemoved)
  if (_internal_has_chatremoved()) {
    clear_has_Msg();
    ::ServerData::ChatRemoved* temp = _impl_.Msg_.chatremoved_;
    _impl_.Msg_.chatremoved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_chatremoved(::ServerData::ChatRemoved* chatremoved) {
  clear_Msg();
  if (chatremoved) {
    set_has_chatremoved();
    _impl_.Msg_.chatremoved_ = chatremoved;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.ChatRemoved)
}
inline ::ServerData::ChatRemoved* RelayRemoteMessage::_internal_mutable_chatremoved() {
  if (!_internal_has_chatremoved()) {
    clear_Msg();
    set_has_chatremoved();
    _impl_.Msg_.chatremoved_ = CreateMaybeMessage< ::ServerData::ChatRemoved >(GetArenaForAllocation());
  }
  return _impl_.Msg_.chatremoved_;
}
inline ::ServerData::ChatRemoved* RelayRemoteMessage::mutable_chatremoved() {
  ::ServerData::ChatRemoved* _msg = _internal_mutable_chatremoved();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.ChatRemoved)
  return _msg;
}

// .ServerData.QueryAiResp QueryAiResp = 130;
inline bool RelayRemoteMessage::_internal_has_queryairesp() const {
  return Msg_case() == kQueryAiResp;
}
inline bool RelayRemoteMessage::has_queryairesp() const {
  return _internal_has_queryairesp();
}
inline void RelayRemoteMessage::set_has_queryairesp() {
  _impl_._oneof_case_[0] = kQueryAiResp;
}
inline void RelayRemoteMessage::clear_queryairesp() {
  if (_internal_has_queryairesp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Msg_.queryairesp_;
    }
    clear_has_Msg();
  }
}
inline ::ServerData::QueryAiResp* RelayRemoteMessage::release_queryairesp() {
  // @@protoc_insertion_point(field_release:ServerData.RelayRemoteMessage.QueryAiResp)
  if (_internal_has_queryairesp()) {
    clear_has_Msg();
    ::ServerData::QueryAiResp* temp = _impl_.Msg_.queryairesp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Msg_.queryairesp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::QueryAiResp& RelayRemoteMessage::_internal_queryairesp() const {
  return _internal_has_queryairesp()
      ? *_impl_.Msg_.queryairesp_
      : reinterpret_cast< ::ServerData::QueryAiResp&>(::ServerData::_QueryAiResp_default_instance_);
}
inline const ::ServerData::QueryAiResp& RelayRemoteMessage::queryairesp() const {
  // @@protoc_insertion_point(field_get:ServerData.RelayRemoteMessage.QueryAiResp)
  return _internal_queryairesp();
}
inline ::ServerData::QueryAiResp* RelayRemoteMessage::unsafe_arena_release_queryairesp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.RelayRemoteMessage.QueryAiResp)
  if (_internal_has_queryairesp()) {
    clear_has_Msg();
    ::ServerData::QueryAiResp* temp = _impl_.Msg_.queryairesp_;
    _impl_.Msg_.queryairesp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelayRemoteMessage::unsafe_arena_set_allocated_queryairesp(::ServerData::QueryAiResp* queryairesp) {
  clear_Msg();
  if (queryairesp) {
    set_has_queryairesp();
    _impl_.Msg_.queryairesp_ = queryairesp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RelayRemoteMessage.QueryAiResp)
}
inline ::ServerData::QueryAiResp* RelayRemoteMessage::_internal_mutable_queryairesp() {
  if (!_internal_has_queryairesp()) {
    clear_Msg();
    set_has_queryairesp();
    _impl_.Msg_.queryairesp_ = CreateMaybeMessage< ::ServerData::QueryAiResp >(GetArenaForAllocation());
  }
  return _impl_.Msg_.queryairesp_;
}
inline ::ServerData::QueryAiResp* RelayRemoteMessage::mutable_queryairesp() {
  ::ServerData::QueryAiResp* _msg = _internal_mutable_queryairesp();
  // @@protoc_insertion_point(field_mutable:ServerData.RelayRemoteMessage.QueryAiResp)
  return _msg;
}

inline bool RelayRemoteMessage::has_Msg() const {
  return Msg_case() != MSG_NOT_SET;
}
inline void RelayRemoteMessage::clear_has_Msg() {
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}
inline RelayRemoteMessage::MsgCase RelayRemoteMessage::Msg_case() const {
  return RelayRemoteMessage::MsgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// KeepAlive

// -------------------------------------------------------------------

// UpdateTime

// double time = 1;
inline void UpdateTime::clear_time() {
  _impl_.time_ = 0;
}
inline double UpdateTime::_internal_time() const {
  return _impl_.time_;
}
inline double UpdateTime::time() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateTime.time)
  return _internal_time();
}
inline void UpdateTime::_internal_set_time(double value) {
  
  _impl_.time_ = value;
}
inline void UpdateTime::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:ServerData.UpdateTime.time)
}

// -------------------------------------------------------------------

// SetForceKeepAlive

// -------------------------------------------------------------------

// EndForceKeepAlive

// -------------------------------------------------------------------

// StatusMessage

// string error = 1;
inline bool StatusMessage::_internal_has_error() const {
  return Message_case() == kError;
}
inline bool StatusMessage::has_error() const {
  return _internal_has_error();
}
inline void StatusMessage::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void StatusMessage::clear_error() {
  if (_internal_has_error()) {
    _impl_.Message_.error_.Destroy();
    clear_has_Message();
  }
}
inline const std::string& StatusMessage::error() const {
  // @@protoc_insertion_point(field_get:ServerData.StatusMessage.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void StatusMessage::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_Message();
    set_has_error();
    _impl_.Message_.error_.InitDefault();
  }
  _impl_.Message_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.StatusMessage.error)
}
inline std::string* StatusMessage::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ServerData.StatusMessage.error)
  return _s;
}
inline const std::string& StatusMessage::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.Message_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void StatusMessage::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_Message();
    set_has_error();
    _impl_.Message_.error_.InitDefault();
  }
  _impl_.Message_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusMessage::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Message();
    set_has_error();
    _impl_.Message_.error_.InitDefault();
  }
  return _impl_.Message_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* StatusMessage::release_error() {
  // @@protoc_insertion_point(field_release:ServerData.StatusMessage.error)
  if (_internal_has_error()) {
    clear_has_Message();
    return _impl_.Message_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void StatusMessage::set_allocated_error(std::string* error) {
  if (has_Message()) {
    clear_Message();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.Message_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.StatusMessage.error)
}

// string warning = 2;
inline bool StatusMessage::_internal_has_warning() const {
  return Message_case() == kWarning;
}
inline bool StatusMessage::has_warning() const {
  return _internal_has_warning();
}
inline void StatusMessage::set_has_warning() {
  _impl_._oneof_case_[0] = kWarning;
}
inline void StatusMessage::clear_warning() {
  if (_internal_has_warning()) {
    _impl_.Message_.warning_.Destroy();
    clear_has_Message();
  }
}
inline const std::string& StatusMessage::warning() const {
  // @@protoc_insertion_point(field_get:ServerData.StatusMessage.warning)
  return _internal_warning();
}
template <typename ArgT0, typename... ArgT>
inline void StatusMessage::set_warning(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_warning()) {
    clear_Message();
    set_has_warning();
    _impl_.Message_.warning_.InitDefault();
  }
  _impl_.Message_.warning_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.StatusMessage.warning)
}
inline std::string* StatusMessage::mutable_warning() {
  std::string* _s = _internal_mutable_warning();
  // @@protoc_insertion_point(field_mutable:ServerData.StatusMessage.warning)
  return _s;
}
inline const std::string& StatusMessage::_internal_warning() const {
  if (_internal_has_warning()) {
    return _impl_.Message_.warning_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void StatusMessage::_internal_set_warning(const std::string& value) {
  if (!_internal_has_warning()) {
    clear_Message();
    set_has_warning();
    _impl_.Message_.warning_.InitDefault();
  }
  _impl_.Message_.warning_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusMessage::_internal_mutable_warning() {
  if (!_internal_has_warning()) {
    clear_Message();
    set_has_warning();
    _impl_.Message_.warning_.InitDefault();
  }
  return _impl_.Message_.warning_.Mutable(      GetArenaForAllocation());
}
inline std::string* StatusMessage::release_warning() {
  // @@protoc_insertion_point(field_release:ServerData.StatusMessage.warning)
  if (_internal_has_warning()) {
    clear_has_Message();
    return _impl_.Message_.warning_.Release();
  } else {
    return nullptr;
  }
}
inline void StatusMessage::set_allocated_warning(std::string* warning) {
  if (has_Message()) {
    clear_Message();
  }
  if (warning != nullptr) {
    set_has_warning();
    _impl_.Message_.warning_.InitAllocated(warning, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.StatusMessage.warning)
}

// string log = 3;
inline bool StatusMessage::_internal_has_log() const {
  return Message_case() == kLog;
}
inline bool StatusMessage::has_log() const {
  return _internal_has_log();
}
inline void StatusMessage::set_has_log() {
  _impl_._oneof_case_[0] = kLog;
}
inline void StatusMessage::clear_log() {
  if (_internal_has_log()) {
    _impl_.Message_.log_.Destroy();
    clear_has_Message();
  }
}
inline const std::string& StatusMessage::log() const {
  // @@protoc_insertion_point(field_get:ServerData.StatusMessage.log)
  return _internal_log();
}
template <typename ArgT0, typename... ArgT>
inline void StatusMessage::set_log(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_log()) {
    clear_Message();
    set_has_log();
    _impl_.Message_.log_.InitDefault();
  }
  _impl_.Message_.log_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.StatusMessage.log)
}
inline std::string* StatusMessage::mutable_log() {
  std::string* _s = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:ServerData.StatusMessage.log)
  return _s;
}
inline const std::string& StatusMessage::_internal_log() const {
  if (_internal_has_log()) {
    return _impl_.Message_.log_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void StatusMessage::_internal_set_log(const std::string& value) {
  if (!_internal_has_log()) {
    clear_Message();
    set_has_log();
    _impl_.Message_.log_.InitDefault();
  }
  _impl_.Message_.log_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusMessage::_internal_mutable_log() {
  if (!_internal_has_log()) {
    clear_Message();
    set_has_log();
    _impl_.Message_.log_.InitDefault();
  }
  return _impl_.Message_.log_.Mutable(      GetArenaForAllocation());
}
inline std::string* StatusMessage::release_log() {
  // @@protoc_insertion_point(field_release:ServerData.StatusMessage.log)
  if (_internal_has_log()) {
    clear_has_Message();
    return _impl_.Message_.log_.Release();
  } else {
    return nullptr;
  }
}
inline void StatusMessage::set_allocated_log(std::string* log) {
  if (has_Message()) {
    clear_Message();
  }
  if (log != nullptr) {
    set_has_log();
    _impl_.Message_.log_.InitAllocated(log, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.StatusMessage.log)
}

inline bool StatusMessage::has_Message() const {
  return Message_case() != MESSAGE_NOT_SET;
}
inline void StatusMessage::clear_has_Message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline StatusMessage::MessageCase StatusMessage::Message_case() const {
  return StatusMessage::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PostDataCacheUpdate

// string key = 1;
inline void PostDataCacheUpdate::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& PostDataCacheUpdate::key() const {
  // @@protoc_insertion_point(field_get:ServerData.PostDataCacheUpdate.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostDataCacheUpdate::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PostDataCacheUpdate.key)
}
inline std::string* PostDataCacheUpdate::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:ServerData.PostDataCacheUpdate.key)
  return _s;
}
inline const std::string& PostDataCacheUpdate::_internal_key() const {
  return _impl_.key_.Get();
}
inline void PostDataCacheUpdate::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* PostDataCacheUpdate::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* PostDataCacheUpdate::release_key() {
  // @@protoc_insertion_point(field_release:ServerData.PostDataCacheUpdate.key)
  return _impl_.key_.Release();
}
inline void PostDataCacheUpdate::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostDataCacheUpdate.key)
}

// string stringVal = 10;
inline bool PostDataCacheUpdate::_internal_has_stringval() const {
  return value_case() == kStringVal;
}
inline bool PostDataCacheUpdate::has_stringval() const {
  return _internal_has_stringval();
}
inline void PostDataCacheUpdate::set_has_stringval() {
  _impl_._oneof_case_[0] = kStringVal;
}
inline void PostDataCacheUpdate::clear_stringval() {
  if (_internal_has_stringval()) {
    _impl_.value_.stringval_.Destroy();
    clear_has_value();
  }
}
inline const std::string& PostDataCacheUpdate::stringval() const {
  // @@protoc_insertion_point(field_get:ServerData.PostDataCacheUpdate.stringVal)
  return _internal_stringval();
}
template <typename ArgT0, typename... ArgT>
inline void PostDataCacheUpdate::set_stringval(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_stringval()) {
    clear_value();
    set_has_stringval();
    _impl_.value_.stringval_.InitDefault();
  }
  _impl_.value_.stringval_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PostDataCacheUpdate.stringVal)
}
inline std::string* PostDataCacheUpdate::mutable_stringval() {
  std::string* _s = _internal_mutable_stringval();
  // @@protoc_insertion_point(field_mutable:ServerData.PostDataCacheUpdate.stringVal)
  return _s;
}
inline const std::string& PostDataCacheUpdate::_internal_stringval() const {
  if (_internal_has_stringval()) {
    return _impl_.value_.stringval_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PostDataCacheUpdate::_internal_set_stringval(const std::string& value) {
  if (!_internal_has_stringval()) {
    clear_value();
    set_has_stringval();
    _impl_.value_.stringval_.InitDefault();
  }
  _impl_.value_.stringval_.Set(value, GetArenaForAllocation());
}
inline std::string* PostDataCacheUpdate::_internal_mutable_stringval() {
  if (!_internal_has_stringval()) {
    clear_value();
    set_has_stringval();
    _impl_.value_.stringval_.InitDefault();
  }
  return _impl_.value_.stringval_.Mutable(      GetArenaForAllocation());
}
inline std::string* PostDataCacheUpdate::release_stringval() {
  // @@protoc_insertion_point(field_release:ServerData.PostDataCacheUpdate.stringVal)
  if (_internal_has_stringval()) {
    clear_has_value();
    return _impl_.value_.stringval_.Release();
  } else {
    return nullptr;
  }
}
inline void PostDataCacheUpdate::set_allocated_stringval(std::string* stringval) {
  if (has_value()) {
    clear_value();
  }
  if (stringval != nullptr) {
    set_has_stringval();
    _impl_.value_.stringval_.InitAllocated(stringval, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostDataCacheUpdate.stringVal)
}

inline bool PostDataCacheUpdate::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void PostDataCacheUpdate::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline PostDataCacheUpdate::ValueCase PostDataCacheUpdate::value_case() const {
  return PostDataCacheUpdate::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CheckServerStatusReq

// int32 reqId = 1;
inline void CheckServerStatusReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t CheckServerStatusReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t CheckServerStatusReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.CheckServerStatusReq.reqId)
  return _internal_reqid();
}
inline void CheckServerStatusReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void CheckServerStatusReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.CheckServerStatusReq.reqId)
}

// string server = 10;
inline void CheckServerStatusReq::clear_server() {
  _impl_.server_.ClearToEmpty();
}
inline const std::string& CheckServerStatusReq::server() const {
  // @@protoc_insertion_point(field_get:ServerData.CheckServerStatusReq.server)
  return _internal_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckServerStatusReq::set_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CheckServerStatusReq.server)
}
inline std::string* CheckServerStatusReq::mutable_server() {
  std::string* _s = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:ServerData.CheckServerStatusReq.server)
  return _s;
}
inline const std::string& CheckServerStatusReq::_internal_server() const {
  return _impl_.server_.Get();
}
inline void CheckServerStatusReq::_internal_set_server(const std::string& value) {
  
  _impl_.server_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckServerStatusReq::_internal_mutable_server() {
  
  return _impl_.server_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckServerStatusReq::release_server() {
  // @@protoc_insertion_point(field_release:ServerData.CheckServerStatusReq.server)
  return _impl_.server_.Release();
}
inline void CheckServerStatusReq::set_allocated_server(std::string* server) {
  if (server != nullptr) {
    
  } else {
    
  }
  _impl_.server_.SetAllocated(server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_.IsDefault()) {
    _impl_.server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CheckServerStatusReq.server)
}

// -------------------------------------------------------------------

// CheckServerStatusResp

// int32 reqId = 1;
inline void CheckServerStatusResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t CheckServerStatusResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t CheckServerStatusResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.CheckServerStatusResp.reqId)
  return _internal_reqid();
}
inline void CheckServerStatusResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void CheckServerStatusResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.CheckServerStatusResp.reqId)
}

// bool live = 10;
inline void CheckServerStatusResp::clear_live() {
  _impl_.live_ = false;
}
inline bool CheckServerStatusResp::_internal_live() const {
  return _impl_.live_;
}
inline bool CheckServerStatusResp::live() const {
  // @@protoc_insertion_point(field_get:ServerData.CheckServerStatusResp.live)
  return _internal_live();
}
inline void CheckServerStatusResp::_internal_set_live(bool value) {
  
  _impl_.live_ = value;
}
inline void CheckServerStatusResp::set_live(bool value) {
  _internal_set_live(value);
  // @@protoc_insertion_point(field_set:ServerData.CheckServerStatusResp.live)
}

// optional .ServerData.OrganizationInformation info = 11;
inline bool CheckServerStatusResp::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool CheckServerStatusResp::has_info() const {
  return _internal_has_info();
}
inline const ::ServerData::OrganizationInformation& CheckServerStatusResp::_internal_info() const {
  const ::ServerData::OrganizationInformation* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::OrganizationInformation&>(
      ::ServerData::_OrganizationInformation_default_instance_);
}
inline const ::ServerData::OrganizationInformation& CheckServerStatusResp::info() const {
  // @@protoc_insertion_point(field_get:ServerData.CheckServerStatusResp.info)
  return _internal_info();
}
inline void CheckServerStatusResp::unsafe_arena_set_allocated_info(
    ::ServerData::OrganizationInformation* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.CheckServerStatusResp.info)
}
inline ::ServerData::OrganizationInformation* CheckServerStatusResp::release_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ServerData::OrganizationInformation* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::OrganizationInformation* CheckServerStatusResp::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:ServerData.CheckServerStatusResp.info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ServerData::OrganizationInformation* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::ServerData::OrganizationInformation* CheckServerStatusResp::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::OrganizationInformation>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::ServerData::OrganizationInformation* CheckServerStatusResp::mutable_info() {
  ::ServerData::OrganizationInformation* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:ServerData.CheckServerStatusResp.info)
  return _msg;
}
inline void CheckServerStatusResp::set_allocated_info(::ServerData::OrganizationInformation* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:ServerData.CheckServerStatusResp.info)
}

// optional string failReason = 12;
inline bool CheckServerStatusResp::_internal_has_failreason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CheckServerStatusResp::has_failreason() const {
  return _internal_has_failreason();
}
inline void CheckServerStatusResp::clear_failreason() {
  _impl_.failreason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CheckServerStatusResp::failreason() const {
  // @@protoc_insertion_point(field_get:ServerData.CheckServerStatusResp.failReason)
  return _internal_failreason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckServerStatusResp::set_failreason(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.failreason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CheckServerStatusResp.failReason)
}
inline std::string* CheckServerStatusResp::mutable_failreason() {
  std::string* _s = _internal_mutable_failreason();
  // @@protoc_insertion_point(field_mutable:ServerData.CheckServerStatusResp.failReason)
  return _s;
}
inline const std::string& CheckServerStatusResp::_internal_failreason() const {
  return _impl_.failreason_.Get();
}
inline void CheckServerStatusResp::_internal_set_failreason(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.failreason_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckServerStatusResp::_internal_mutable_failreason() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.failreason_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckServerStatusResp::release_failreason() {
  // @@protoc_insertion_point(field_release:ServerData.CheckServerStatusResp.failReason)
  if (!_internal_has_failreason()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.failreason_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.failreason_.IsDefault()) {
    _impl_.failreason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CheckServerStatusResp::set_allocated_failreason(std::string* failreason) {
  if (failreason != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.failreason_.SetAllocated(failreason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.failreason_.IsDefault()) {
    _impl_.failreason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CheckServerStatusResp.failReason)
}

// -------------------------------------------------------------------

// AuthenticateReq

// int32 reqId = 1;
inline void AuthenticateReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateReq.reqId)
  return _internal_reqid();
}
inline void AuthenticateReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateReq.reqId)
}

// string server = 10;
inline void AuthenticateReq::clear_server() {
  _impl_.server_.ClearToEmpty();
}
inline const std::string& AuthenticateReq::server() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateReq.server)
  return _internal_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateReq::set_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateReq.server)
}
inline std::string* AuthenticateReq::mutable_server() {
  std::string* _s = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateReq.server)
  return _s;
}
inline const std::string& AuthenticateReq::_internal_server() const {
  return _impl_.server_.Get();
}
inline void AuthenticateReq::_internal_set_server(const std::string& value) {
  
  _impl_.server_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateReq::_internal_mutable_server() {
  
  return _impl_.server_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateReq::release_server() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateReq.server)
  return _impl_.server_.Release();
}
inline void AuthenticateReq::set_allocated_server(std::string* server) {
  if (server != nullptr) {
    
  } else {
    
  }
  _impl_.server_.SetAllocated(server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_.IsDefault()) {
    _impl_.server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateReq.server)
}

// string email = 11;
inline void AuthenticateReq::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& AuthenticateReq::email() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateReq.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateReq::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateReq.email)
}
inline std::string* AuthenticateReq::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateReq.email)
  return _s;
}
inline const std::string& AuthenticateReq::_internal_email() const {
  return _impl_.email_.Get();
}
inline void AuthenticateReq::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateReq::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateReq::release_email() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateReq.email)
  return _impl_.email_.Release();
}
inline void AuthenticateReq::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateReq.email)
}

// string password = 12;
inline void AuthenticateReq::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& AuthenticateReq::password() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateReq.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateReq.password)
}
inline std::string* AuthenticateReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateReq.password)
  return _s;
}
inline const std::string& AuthenticateReq::_internal_password() const {
  return _impl_.password_.Get();
}
inline void AuthenticateReq::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateReq::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateReq::release_password() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateReq.password)
  return _impl_.password_.Release();
}
inline void AuthenticateReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateReq.password)
}

// -------------------------------------------------------------------

// AuthenticateApiKeyReq

// int32 reqId = 1;
inline void AuthenticateApiKeyReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateApiKeyReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateApiKeyReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateApiKeyReq.reqId)
  return _internal_reqid();
}
inline void AuthenticateApiKeyReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateApiKeyReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateApiKeyReq.reqId)
}

// optional string server = 10;
inline bool AuthenticateApiKeyReq::_internal_has_server() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthenticateApiKeyReq::has_server() const {
  return _internal_has_server();
}
inline void AuthenticateApiKeyReq::clear_server() {
  _impl_.server_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthenticateApiKeyReq::server() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateApiKeyReq.server)
  return _internal_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateApiKeyReq::set_server(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateApiKeyReq.server)
}
inline std::string* AuthenticateApiKeyReq::mutable_server() {
  std::string* _s = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateApiKeyReq.server)
  return _s;
}
inline const std::string& AuthenticateApiKeyReq::_internal_server() const {
  return _impl_.server_.Get();
}
inline void AuthenticateApiKeyReq::_internal_set_server(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.server_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateApiKeyReq::_internal_mutable_server() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.server_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateApiKeyReq::release_server() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateApiKeyReq.server)
  if (!_internal_has_server()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.server_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_.IsDefault()) {
    _impl_.server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AuthenticateApiKeyReq::set_allocated_server(std::string* server) {
  if (server != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.server_.SetAllocated(server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_.IsDefault()) {
    _impl_.server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateApiKeyReq.server)
}

// string accessKey = 11;
inline void AuthenticateApiKeyReq::clear_accesskey() {
  _impl_.accesskey_.ClearToEmpty();
}
inline const std::string& AuthenticateApiKeyReq::accesskey() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateApiKeyReq.accessKey)
  return _internal_accesskey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateApiKeyReq::set_accesskey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.accesskey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateApiKeyReq.accessKey)
}
inline std::string* AuthenticateApiKeyReq::mutable_accesskey() {
  std::string* _s = _internal_mutable_accesskey();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateApiKeyReq.accessKey)
  return _s;
}
inline const std::string& AuthenticateApiKeyReq::_internal_accesskey() const {
  return _impl_.accesskey_.Get();
}
inline void AuthenticateApiKeyReq::_internal_set_accesskey(const std::string& value) {
  
  _impl_.accesskey_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateApiKeyReq::_internal_mutable_accesskey() {
  
  return _impl_.accesskey_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateApiKeyReq::release_accesskey() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateApiKeyReq.accessKey)
  return _impl_.accesskey_.Release();
}
inline void AuthenticateApiKeyReq::set_allocated_accesskey(std::string* accesskey) {
  if (accesskey != nullptr) {
    
  } else {
    
  }
  _impl_.accesskey_.SetAllocated(accesskey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accesskey_.IsDefault()) {
    _impl_.accesskey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateApiKeyReq.accessKey)
}

// string accessToken = 12;
inline void AuthenticateApiKeyReq::clear_accesstoken() {
  _impl_.accesstoken_.ClearToEmpty();
}
inline const std::string& AuthenticateApiKeyReq::accesstoken() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateApiKeyReq.accessToken)
  return _internal_accesstoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateApiKeyReq::set_accesstoken(ArgT0&& arg0, ArgT... args) {
 
 _impl_.accesstoken_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateApiKeyReq.accessToken)
}
inline std::string* AuthenticateApiKeyReq::mutable_accesstoken() {
  std::string* _s = _internal_mutable_accesstoken();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateApiKeyReq.accessToken)
  return _s;
}
inline const std::string& AuthenticateApiKeyReq::_internal_accesstoken() const {
  return _impl_.accesstoken_.Get();
}
inline void AuthenticateApiKeyReq::_internal_set_accesstoken(const std::string& value) {
  
  _impl_.accesstoken_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateApiKeyReq::_internal_mutable_accesstoken() {
  
  return _impl_.accesstoken_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateApiKeyReq::release_accesstoken() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateApiKeyReq.accessToken)
  return _impl_.accesstoken_.Release();
}
inline void AuthenticateApiKeyReq::set_allocated_accesstoken(std::string* accesstoken) {
  if (accesstoken != nullptr) {
    
  } else {
    
  }
  _impl_.accesstoken_.SetAllocated(accesstoken, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accesstoken_.IsDefault()) {
    _impl_.accesstoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateApiKeyReq.accessToken)
}

// -------------------------------------------------------------------

// AuthenticateGuestReq

// int32 reqId = 1;
inline void AuthenticateGuestReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateGuestReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateGuestReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateGuestReq.reqId)
  return _internal_reqid();
}
inline void AuthenticateGuestReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateGuestReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateGuestReq.reqId)
}

// string server = 10;
inline void AuthenticateGuestReq::clear_server() {
  _impl_.server_.ClearToEmpty();
}
inline const std::string& AuthenticateGuestReq::server() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateGuestReq.server)
  return _internal_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateGuestReq::set_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateGuestReq.server)
}
inline std::string* AuthenticateGuestReq::mutable_server() {
  std::string* _s = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateGuestReq.server)
  return _s;
}
inline const std::string& AuthenticateGuestReq::_internal_server() const {
  return _impl_.server_.Get();
}
inline void AuthenticateGuestReq::_internal_set_server(const std::string& value) {
  
  _impl_.server_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateGuestReq::_internal_mutable_server() {
  
  return _impl_.server_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateGuestReq::release_server() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateGuestReq.server)
  return _impl_.server_.Release();
}
inline void AuthenticateGuestReq::set_allocated_server(std::string* server) {
  if (server != nullptr) {
    
  } else {
    
  }
  _impl_.server_.SetAllocated(server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_.IsDefault()) {
    _impl_.server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateGuestReq.server)
}

// string screenName = 11;
inline void AuthenticateGuestReq::clear_screenname() {
  _impl_.screenname_.ClearToEmpty();
}
inline const std::string& AuthenticateGuestReq::screenname() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateGuestReq.screenName)
  return _internal_screenname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateGuestReq::set_screenname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.screenname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateGuestReq.screenName)
}
inline std::string* AuthenticateGuestReq::mutable_screenname() {
  std::string* _s = _internal_mutable_screenname();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateGuestReq.screenName)
  return _s;
}
inline const std::string& AuthenticateGuestReq::_internal_screenname() const {
  return _impl_.screenname_.Get();
}
inline void AuthenticateGuestReq::_internal_set_screenname(const std::string& value) {
  
  _impl_.screenname_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateGuestReq::_internal_mutable_screenname() {
  
  return _impl_.screenname_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateGuestReq::release_screenname() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateGuestReq.screenName)
  return _impl_.screenname_.Release();
}
inline void AuthenticateGuestReq::set_allocated_screenname(std::string* screenname) {
  if (screenname != nullptr) {
    
  } else {
    
  }
  _impl_.screenname_.SetAllocated(screenname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.screenname_.IsDefault()) {
    _impl_.screenname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateGuestReq.screenName)
}

// -------------------------------------------------------------------

// AuthenticateDeviceCodeBeginReq

// int32 reqId = 1;
inline void AuthenticateDeviceCodeBeginReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateDeviceCodeBeginReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateDeviceCodeBeginReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateDeviceCodeBeginReq.reqId)
  return _internal_reqid();
}
inline void AuthenticateDeviceCodeBeginReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateDeviceCodeBeginReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateDeviceCodeBeginReq.reqId)
}

// optional string server = 10;
inline bool AuthenticateDeviceCodeBeginReq::_internal_has_server() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthenticateDeviceCodeBeginReq::has_server() const {
  return _internal_has_server();
}
inline void AuthenticateDeviceCodeBeginReq::clear_server() {
  _impl_.server_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthenticateDeviceCodeBeginReq::server() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateDeviceCodeBeginReq.server)
  return _internal_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateDeviceCodeBeginReq::set_server(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateDeviceCodeBeginReq.server)
}
inline std::string* AuthenticateDeviceCodeBeginReq::mutable_server() {
  std::string* _s = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateDeviceCodeBeginReq.server)
  return _s;
}
inline const std::string& AuthenticateDeviceCodeBeginReq::_internal_server() const {
  return _impl_.server_.Get();
}
inline void AuthenticateDeviceCodeBeginReq::_internal_set_server(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.server_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeBeginReq::_internal_mutable_server() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.server_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeBeginReq::release_server() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateDeviceCodeBeginReq.server)
  if (!_internal_has_server()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.server_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_.IsDefault()) {
    _impl_.server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AuthenticateDeviceCodeBeginReq::set_allocated_server(std::string* server) {
  if (server != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.server_.SetAllocated(server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_.IsDefault()) {
    _impl_.server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateDeviceCodeBeginReq.server)
}

// optional string source = 11;
inline bool AuthenticateDeviceCodeBeginReq::_internal_has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AuthenticateDeviceCodeBeginReq::has_source() const {
  return _internal_has_source();
}
inline void AuthenticateDeviceCodeBeginReq::clear_source() {
  _impl_.source_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AuthenticateDeviceCodeBeginReq::source() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateDeviceCodeBeginReq.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateDeviceCodeBeginReq::set_source(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateDeviceCodeBeginReq.source)
}
inline std::string* AuthenticateDeviceCodeBeginReq::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateDeviceCodeBeginReq.source)
  return _s;
}
inline const std::string& AuthenticateDeviceCodeBeginReq::_internal_source() const {
  return _impl_.source_.Get();
}
inline void AuthenticateDeviceCodeBeginReq::_internal_set_source(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeBeginReq::_internal_mutable_source() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.source_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeBeginReq::release_source() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateDeviceCodeBeginReq.source)
  if (!_internal_has_source()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.source_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AuthenticateDeviceCodeBeginReq::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateDeviceCodeBeginReq.source)
}

// optional string customActivatedMessage = 12;
inline bool AuthenticateDeviceCodeBeginReq::_internal_has_customactivatedmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AuthenticateDeviceCodeBeginReq::has_customactivatedmessage() const {
  return _internal_has_customactivatedmessage();
}
inline void AuthenticateDeviceCodeBeginReq::clear_customactivatedmessage() {
  _impl_.customactivatedmessage_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AuthenticateDeviceCodeBeginReq::customactivatedmessage() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateDeviceCodeBeginReq.customActivatedMessage)
  return _internal_customactivatedmessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateDeviceCodeBeginReq::set_customactivatedmessage(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.customactivatedmessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateDeviceCodeBeginReq.customActivatedMessage)
}
inline std::string* AuthenticateDeviceCodeBeginReq::mutable_customactivatedmessage() {
  std::string* _s = _internal_mutable_customactivatedmessage();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateDeviceCodeBeginReq.customActivatedMessage)
  return _s;
}
inline const std::string& AuthenticateDeviceCodeBeginReq::_internal_customactivatedmessage() const {
  return _impl_.customactivatedmessage_.Get();
}
inline void AuthenticateDeviceCodeBeginReq::_internal_set_customactivatedmessage(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.customactivatedmessage_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeBeginReq::_internal_mutable_customactivatedmessage() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.customactivatedmessage_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeBeginReq::release_customactivatedmessage() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateDeviceCodeBeginReq.customActivatedMessage)
  if (!_internal_has_customactivatedmessage()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.customactivatedmessage_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.customactivatedmessage_.IsDefault()) {
    _impl_.customactivatedmessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AuthenticateDeviceCodeBeginReq::set_allocated_customactivatedmessage(std::string* customactivatedmessage) {
  if (customactivatedmessage != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.customactivatedmessage_.SetAllocated(customactivatedmessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.customactivatedmessage_.IsDefault()) {
    _impl_.customactivatedmessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateDeviceCodeBeginReq.customActivatedMessage)
}

// optional int32 ttlSeconds = 13;
inline bool AuthenticateDeviceCodeBeginReq::_internal_has_ttlseconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AuthenticateDeviceCodeBeginReq::has_ttlseconds() const {
  return _internal_has_ttlseconds();
}
inline void AuthenticateDeviceCodeBeginReq::clear_ttlseconds() {
  _impl_.ttlseconds_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t AuthenticateDeviceCodeBeginReq::_internal_ttlseconds() const {
  return _impl_.ttlseconds_;
}
inline int32_t AuthenticateDeviceCodeBeginReq::ttlseconds() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateDeviceCodeBeginReq.ttlSeconds)
  return _internal_ttlseconds();
}
inline void AuthenticateDeviceCodeBeginReq::_internal_set_ttlseconds(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ttlseconds_ = value;
}
inline void AuthenticateDeviceCodeBeginReq::set_ttlseconds(int32_t value) {
  _internal_set_ttlseconds(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateDeviceCodeBeginReq.ttlSeconds)
}

// optional bool autoOpenUrl = 14;
inline bool AuthenticateDeviceCodeBeginReq::_internal_has_autoopenurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AuthenticateDeviceCodeBeginReq::has_autoopenurl() const {
  return _internal_has_autoopenurl();
}
inline void AuthenticateDeviceCodeBeginReq::clear_autoopenurl() {
  _impl_.autoopenurl_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool AuthenticateDeviceCodeBeginReq::_internal_autoopenurl() const {
  return _impl_.autoopenurl_;
}
inline bool AuthenticateDeviceCodeBeginReq::autoopenurl() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateDeviceCodeBeginReq.autoOpenUrl)
  return _internal_autoopenurl();
}
inline void AuthenticateDeviceCodeBeginReq::_internal_set_autoopenurl(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.autoopenurl_ = value;
}
inline void AuthenticateDeviceCodeBeginReq::set_autoopenurl(bool value) {
  _internal_set_autoopenurl(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateDeviceCodeBeginReq.autoOpenUrl)
}

// -------------------------------------------------------------------

// AuthenticateDeviceCodeBeginResp

// int32 reqId = 1;
inline void AuthenticateDeviceCodeBeginResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateDeviceCodeBeginResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateDeviceCodeBeginResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateDeviceCodeBeginResp.reqId)
  return _internal_reqid();
}
inline void AuthenticateDeviceCodeBeginResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateDeviceCodeBeginResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateDeviceCodeBeginResp.reqId)
}

// string deviceCode = 10;
inline void AuthenticateDeviceCodeBeginResp::clear_devicecode() {
  _impl_.devicecode_.ClearToEmpty();
}
inline const std::string& AuthenticateDeviceCodeBeginResp::devicecode() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateDeviceCodeBeginResp.deviceCode)
  return _internal_devicecode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateDeviceCodeBeginResp::set_devicecode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.devicecode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateDeviceCodeBeginResp.deviceCode)
}
inline std::string* AuthenticateDeviceCodeBeginResp::mutable_devicecode() {
  std::string* _s = _internal_mutable_devicecode();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateDeviceCodeBeginResp.deviceCode)
  return _s;
}
inline const std::string& AuthenticateDeviceCodeBeginResp::_internal_devicecode() const {
  return _impl_.devicecode_.Get();
}
inline void AuthenticateDeviceCodeBeginResp::_internal_set_devicecode(const std::string& value) {
  
  _impl_.devicecode_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeBeginResp::_internal_mutable_devicecode() {
  
  return _impl_.devicecode_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeBeginResp::release_devicecode() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateDeviceCodeBeginResp.deviceCode)
  return _impl_.devicecode_.Release();
}
inline void AuthenticateDeviceCodeBeginResp::set_allocated_devicecode(std::string* devicecode) {
  if (devicecode != nullptr) {
    
  } else {
    
  }
  _impl_.devicecode_.SetAllocated(devicecode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicecode_.IsDefault()) {
    _impl_.devicecode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateDeviceCodeBeginResp.deviceCode)
}

// string userCode = 11;
inline void AuthenticateDeviceCodeBeginResp::clear_usercode() {
  _impl_.usercode_.ClearToEmpty();
}
inline const std::string& AuthenticateDeviceCodeBeginResp::usercode() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateDeviceCodeBeginResp.userCode)
  return _internal_usercode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateDeviceCodeBeginResp::set_usercode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.usercode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateDeviceCodeBeginResp.userCode)
}
inline std::string* AuthenticateDeviceCodeBeginResp::mutable_usercode() {
  std::string* _s = _internal_mutable_usercode();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateDeviceCodeBeginResp.userCode)
  return _s;
}
inline const std::string& AuthenticateDeviceCodeBeginResp::_internal_usercode() const {
  return _impl_.usercode_.Get();
}
inline void AuthenticateDeviceCodeBeginResp::_internal_set_usercode(const std::string& value) {
  
  _impl_.usercode_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeBeginResp::_internal_mutable_usercode() {
  
  return _impl_.usercode_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeBeginResp::release_usercode() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateDeviceCodeBeginResp.userCode)
  return _impl_.usercode_.Release();
}
inline void AuthenticateDeviceCodeBeginResp::set_allocated_usercode(std::string* usercode) {
  if (usercode != nullptr) {
    
  } else {
    
  }
  _impl_.usercode_.SetAllocated(usercode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.usercode_.IsDefault()) {
    _impl_.usercode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateDeviceCodeBeginResp.userCode)
}

// string verificationUrl = 12;
inline void AuthenticateDeviceCodeBeginResp::clear_verificationurl() {
  _impl_.verificationurl_.ClearToEmpty();
}
inline const std::string& AuthenticateDeviceCodeBeginResp::verificationurl() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateDeviceCodeBeginResp.verificationUrl)
  return _internal_verificationurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateDeviceCodeBeginResp::set_verificationurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verificationurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateDeviceCodeBeginResp.verificationUrl)
}
inline std::string* AuthenticateDeviceCodeBeginResp::mutable_verificationurl() {
  std::string* _s = _internal_mutable_verificationurl();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateDeviceCodeBeginResp.verificationUrl)
  return _s;
}
inline const std::string& AuthenticateDeviceCodeBeginResp::_internal_verificationurl() const {
  return _impl_.verificationurl_.Get();
}
inline void AuthenticateDeviceCodeBeginResp::_internal_set_verificationurl(const std::string& value) {
  
  _impl_.verificationurl_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeBeginResp::_internal_mutable_verificationurl() {
  
  return _impl_.verificationurl_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeBeginResp::release_verificationurl() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateDeviceCodeBeginResp.verificationUrl)
  return _impl_.verificationurl_.Release();
}
inline void AuthenticateDeviceCodeBeginResp::set_allocated_verificationurl(std::string* verificationurl) {
  if (verificationurl != nullptr) {
    
  } else {
    
  }
  _impl_.verificationurl_.SetAllocated(verificationurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verificationurl_.IsDefault()) {
    _impl_.verificationurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateDeviceCodeBeginResp.verificationUrl)
}

// -------------------------------------------------------------------

// AuthenticateDeviceCodeConcludeReq

// int32 reqId = 1;
inline void AuthenticateDeviceCodeConcludeReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateDeviceCodeConcludeReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateDeviceCodeConcludeReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateDeviceCodeConcludeReq.reqId)
  return _internal_reqid();
}
inline void AuthenticateDeviceCodeConcludeReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateDeviceCodeConcludeReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateDeviceCodeConcludeReq.reqId)
}

// optional string server = 10;
inline bool AuthenticateDeviceCodeConcludeReq::_internal_has_server() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthenticateDeviceCodeConcludeReq::has_server() const {
  return _internal_has_server();
}
inline void AuthenticateDeviceCodeConcludeReq::clear_server() {
  _impl_.server_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthenticateDeviceCodeConcludeReq::server() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateDeviceCodeConcludeReq.server)
  return _internal_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateDeviceCodeConcludeReq::set_server(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateDeviceCodeConcludeReq.server)
}
inline std::string* AuthenticateDeviceCodeConcludeReq::mutable_server() {
  std::string* _s = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateDeviceCodeConcludeReq.server)
  return _s;
}
inline const std::string& AuthenticateDeviceCodeConcludeReq::_internal_server() const {
  return _impl_.server_.Get();
}
inline void AuthenticateDeviceCodeConcludeReq::_internal_set_server(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.server_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeConcludeReq::_internal_mutable_server() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.server_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeConcludeReq::release_server() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateDeviceCodeConcludeReq.server)
  if (!_internal_has_server()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.server_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_.IsDefault()) {
    _impl_.server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AuthenticateDeviceCodeConcludeReq::set_allocated_server(std::string* server) {
  if (server != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.server_.SetAllocated(server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_.IsDefault()) {
    _impl_.server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateDeviceCodeConcludeReq.server)
}

// string deviceCode = 11;
inline void AuthenticateDeviceCodeConcludeReq::clear_devicecode() {
  _impl_.devicecode_.ClearToEmpty();
}
inline const std::string& AuthenticateDeviceCodeConcludeReq::devicecode() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateDeviceCodeConcludeReq.deviceCode)
  return _internal_devicecode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateDeviceCodeConcludeReq::set_devicecode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.devicecode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateDeviceCodeConcludeReq.deviceCode)
}
inline std::string* AuthenticateDeviceCodeConcludeReq::mutable_devicecode() {
  std::string* _s = _internal_mutable_devicecode();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateDeviceCodeConcludeReq.deviceCode)
  return _s;
}
inline const std::string& AuthenticateDeviceCodeConcludeReq::_internal_devicecode() const {
  return _impl_.devicecode_.Get();
}
inline void AuthenticateDeviceCodeConcludeReq::_internal_set_devicecode(const std::string& value) {
  
  _impl_.devicecode_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeConcludeReq::_internal_mutable_devicecode() {
  
  return _impl_.devicecode_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeConcludeReq::release_devicecode() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateDeviceCodeConcludeReq.deviceCode)
  return _impl_.devicecode_.Release();
}
inline void AuthenticateDeviceCodeConcludeReq::set_allocated_devicecode(std::string* devicecode) {
  if (devicecode != nullptr) {
    
  } else {
    
  }
  _impl_.devicecode_.SetAllocated(devicecode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicecode_.IsDefault()) {
    _impl_.devicecode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateDeviceCodeConcludeReq.deviceCode)
}

// string userCode = 12;
inline void AuthenticateDeviceCodeConcludeReq::clear_usercode() {
  _impl_.usercode_.ClearToEmpty();
}
inline const std::string& AuthenticateDeviceCodeConcludeReq::usercode() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateDeviceCodeConcludeReq.userCode)
  return _internal_usercode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateDeviceCodeConcludeReq::set_usercode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.usercode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateDeviceCodeConcludeReq.userCode)
}
inline std::string* AuthenticateDeviceCodeConcludeReq::mutable_usercode() {
  std::string* _s = _internal_mutable_usercode();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateDeviceCodeConcludeReq.userCode)
  return _s;
}
inline const std::string& AuthenticateDeviceCodeConcludeReq::_internal_usercode() const {
  return _impl_.usercode_.Get();
}
inline void AuthenticateDeviceCodeConcludeReq::_internal_set_usercode(const std::string& value) {
  
  _impl_.usercode_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeConcludeReq::_internal_mutable_usercode() {
  
  return _impl_.usercode_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateDeviceCodeConcludeReq::release_usercode() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateDeviceCodeConcludeReq.userCode)
  return _impl_.usercode_.Release();
}
inline void AuthenticateDeviceCodeConcludeReq::set_allocated_usercode(std::string* usercode) {
  if (usercode != nullptr) {
    
  } else {
    
  }
  _impl_.usercode_.SetAllocated(usercode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.usercode_.IsDefault()) {
    _impl_.usercode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateDeviceCodeConcludeReq.userCode)
}

// int32 pollForSeconds = 13;
inline void AuthenticateDeviceCodeConcludeReq::clear_pollforseconds() {
  _impl_.pollforseconds_ = 0;
}
inline int32_t AuthenticateDeviceCodeConcludeReq::_internal_pollforseconds() const {
  return _impl_.pollforseconds_;
}
inline int32_t AuthenticateDeviceCodeConcludeReq::pollforseconds() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateDeviceCodeConcludeReq.pollForSeconds)
  return _internal_pollforseconds();
}
inline void AuthenticateDeviceCodeConcludeReq::_internal_set_pollforseconds(int32_t value) {
  
  _impl_.pollforseconds_ = value;
}
inline void AuthenticateDeviceCodeConcludeReq::set_pollforseconds(int32_t value) {
  _internal_set_pollforseconds(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateDeviceCodeConcludeReq.pollForSeconds)
}

// -------------------------------------------------------------------

// AuthenticateResp

// int32 reqId = 1;
inline void AuthenticateResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateResp.reqId)
  return _internal_reqid();
}
inline void AuthenticateResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateResp.reqId)
}

// .ServerData.CavrnusAuth auth = 10;
inline bool AuthenticateResp::_internal_has_auth() const {
  return this != internal_default_instance() && _impl_.auth_ != nullptr;
}
inline bool AuthenticateResp::has_auth() const {
  return _internal_has_auth();
}
inline const ::ServerData::CavrnusAuth& AuthenticateResp::_internal_auth() const {
  const ::ServerData::CavrnusAuth* p = _impl_.auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusAuth&>(
      ::ServerData::_CavrnusAuth_default_instance_);
}
inline const ::ServerData::CavrnusAuth& AuthenticateResp::auth() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateResp.auth)
  return _internal_auth();
}
inline void AuthenticateResp::unsafe_arena_set_allocated_auth(
    ::ServerData::CavrnusAuth* auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auth_);
  }
  _impl_.auth_ = auth;
  if (auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.AuthenticateResp.auth)
}
inline ::ServerData::CavrnusAuth* AuthenticateResp::release_auth() {
  
  ::ServerData::CavrnusAuth* temp = _impl_.auth_;
  _impl_.auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusAuth* AuthenticateResp::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateResp.auth)
  
  ::ServerData::CavrnusAuth* temp = _impl_.auth_;
  _impl_.auth_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusAuth* AuthenticateResp::_internal_mutable_auth() {
  
  if (_impl_.auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusAuth>(GetArenaForAllocation());
    _impl_.auth_ = p;
  }
  return _impl_.auth_;
}
inline ::ServerData::CavrnusAuth* AuthenticateResp::mutable_auth() {
  ::ServerData::CavrnusAuth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateResp.auth)
  return _msg;
}
inline void AuthenticateResp::set_allocated_auth(::ServerData::CavrnusAuth* auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auth_);
  }
  if (auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auth));
    if (message_arena != submessage_arena) {
      auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateResp.auth)
}

// -------------------------------------------------------------------

// AuthenticateTokenReq

// int32 reqId = 1;
inline void AuthenticateTokenReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateTokenReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateTokenReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateTokenReq.reqId)
  return _internal_reqid();
}
inline void AuthenticateTokenReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateTokenReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateTokenReq.reqId)
}

// optional string server = 10;
inline bool AuthenticateTokenReq::_internal_has_server() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthenticateTokenReq::has_server() const {
  return _internal_has_server();
}
inline void AuthenticateTokenReq::clear_server() {
  _impl_.server_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthenticateTokenReq::server() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateTokenReq.server)
  return _internal_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateTokenReq::set_server(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateTokenReq.server)
}
inline std::string* AuthenticateTokenReq::mutable_server() {
  std::string* _s = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateTokenReq.server)
  return _s;
}
inline const std::string& AuthenticateTokenReq::_internal_server() const {
  return _impl_.server_.Get();
}
inline void AuthenticateTokenReq::_internal_set_server(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.server_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateTokenReq::_internal_mutable_server() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.server_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateTokenReq::release_server() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateTokenReq.server)
  if (!_internal_has_server()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.server_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_.IsDefault()) {
    _impl_.server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AuthenticateTokenReq::set_allocated_server(std::string* server) {
  if (server != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.server_.SetAllocated(server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_.IsDefault()) {
    _impl_.server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateTokenReq.server)
}

// string token = 11;
inline void AuthenticateTokenReq::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& AuthenticateTokenReq::token() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateTokenReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateTokenReq::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateTokenReq.token)
}
inline std::string* AuthenticateTokenReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateTokenReq.token)
  return _s;
}
inline const std::string& AuthenticateTokenReq::_internal_token() const {
  return _impl_.token_.Get();
}
inline void AuthenticateTokenReq::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateTokenReq::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateTokenReq::release_token() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateTokenReq.token)
  return _impl_.token_.Release();
}
inline void AuthenticateTokenReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateTokenReq.token)
}

// -------------------------------------------------------------------

// AuthenticateWithLinkReq

// int32 reqId = 1;
inline void AuthenticateWithLinkReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateWithLinkReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateWithLinkReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateWithLinkReq.reqId)
  return _internal_reqid();
}
inline void AuthenticateWithLinkReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateWithLinkReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateWithLinkReq.reqId)
}

// string link = 10;
inline void AuthenticateWithLinkReq::clear_link() {
  _impl_.link_.ClearToEmpty();
}
inline const std::string& AuthenticateWithLinkReq::link() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateWithLinkReq.link)
  return _internal_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateWithLinkReq::set_link(ArgT0&& arg0, ArgT... args) {
 
 _impl_.link_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateWithLinkReq.link)
}
inline std::string* AuthenticateWithLinkReq::mutable_link() {
  std::string* _s = _internal_mutable_link();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateWithLinkReq.link)
  return _s;
}
inline const std::string& AuthenticateWithLinkReq::_internal_link() const {
  return _impl_.link_.Get();
}
inline void AuthenticateWithLinkReq::_internal_set_link(const std::string& value) {
  
  _impl_.link_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateWithLinkReq::_internal_mutable_link() {
  
  return _impl_.link_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticateWithLinkReq::release_link() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateWithLinkReq.link)
  return _impl_.link_.Release();
}
inline void AuthenticateWithLinkReq::set_allocated_link(std::string* link) {
  if (link != nullptr) {
    
  } else {
    
  }
  _impl_.link_.SetAllocated(link, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.link_.IsDefault()) {
    _impl_.link_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateWithLinkReq.link)
}

// -------------------------------------------------------------------

// AuthenticateWithLinkResp

// int32 reqId = 1;
inline void AuthenticateWithLinkResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AuthenticateWithLinkResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AuthenticateWithLinkResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateWithLinkResp.reqId)
  return _internal_reqid();
}
inline void AuthenticateWithLinkResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AuthenticateWithLinkResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AuthenticateWithLinkResp.reqId)
}

// .ServerData.CavrnusAuthLinkResponse linkAuth = 10;
inline bool AuthenticateWithLinkResp::_internal_has_linkauth() const {
  return this != internal_default_instance() && _impl_.linkauth_ != nullptr;
}
inline bool AuthenticateWithLinkResp::has_linkauth() const {
  return _internal_has_linkauth();
}
inline const ::ServerData::CavrnusAuthLinkResponse& AuthenticateWithLinkResp::_internal_linkauth() const {
  const ::ServerData::CavrnusAuthLinkResponse* p = _impl_.linkauth_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusAuthLinkResponse&>(
      ::ServerData::_CavrnusAuthLinkResponse_default_instance_);
}
inline const ::ServerData::CavrnusAuthLinkResponse& AuthenticateWithLinkResp::linkauth() const {
  // @@protoc_insertion_point(field_get:ServerData.AuthenticateWithLinkResp.linkAuth)
  return _internal_linkauth();
}
inline void AuthenticateWithLinkResp::unsafe_arena_set_allocated_linkauth(
    ::ServerData::CavrnusAuthLinkResponse* linkauth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linkauth_);
  }
  _impl_.linkauth_ = linkauth;
  if (linkauth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.AuthenticateWithLinkResp.linkAuth)
}
inline ::ServerData::CavrnusAuthLinkResponse* AuthenticateWithLinkResp::release_linkauth() {
  
  ::ServerData::CavrnusAuthLinkResponse* temp = _impl_.linkauth_;
  _impl_.linkauth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusAuthLinkResponse* AuthenticateWithLinkResp::unsafe_arena_release_linkauth() {
  // @@protoc_insertion_point(field_release:ServerData.AuthenticateWithLinkResp.linkAuth)
  
  ::ServerData::CavrnusAuthLinkResponse* temp = _impl_.linkauth_;
  _impl_.linkauth_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusAuthLinkResponse* AuthenticateWithLinkResp::_internal_mutable_linkauth() {
  
  if (_impl_.linkauth_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusAuthLinkResponse>(GetArenaForAllocation());
    _impl_.linkauth_ = p;
  }
  return _impl_.linkauth_;
}
inline ::ServerData::CavrnusAuthLinkResponse* AuthenticateWithLinkResp::mutable_linkauth() {
  ::ServerData::CavrnusAuthLinkResponse* _msg = _internal_mutable_linkauth();
  // @@protoc_insertion_point(field_mutable:ServerData.AuthenticateWithLinkResp.linkAuth)
  return _msg;
}
inline void AuthenticateWithLinkResp::set_allocated_linkauth(::ServerData::CavrnusAuthLinkResponse* linkauth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linkauth_);
  }
  if (linkauth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linkauth));
    if (message_arena != submessage_arena) {
      linkauth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linkauth, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linkauth_ = linkauth;
  // @@protoc_insertion_point(field_set_allocated:ServerData.AuthenticateWithLinkResp.linkAuth)
}

// -------------------------------------------------------------------

// ConstructApiKeyReq

// int32 reqId = 1;
inline void ConstructApiKeyReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t ConstructApiKeyReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t ConstructApiKeyReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.ConstructApiKeyReq.reqId)
  return _internal_reqid();
}
inline void ConstructApiKeyReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void ConstructApiKeyReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.ConstructApiKeyReq.reqId)
}

// optional string keyName = 10;
inline bool ConstructApiKeyReq::_internal_has_keyname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConstructApiKeyReq::has_keyname() const {
  return _internal_has_keyname();
}
inline void ConstructApiKeyReq::clear_keyname() {
  _impl_.keyname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConstructApiKeyReq::keyname() const {
  // @@protoc_insertion_point(field_get:ServerData.ConstructApiKeyReq.keyName)
  return _internal_keyname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConstructApiKeyReq::set_keyname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.keyname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ConstructApiKeyReq.keyName)
}
inline std::string* ConstructApiKeyReq::mutable_keyname() {
  std::string* _s = _internal_mutable_keyname();
  // @@protoc_insertion_point(field_mutable:ServerData.ConstructApiKeyReq.keyName)
  return _s;
}
inline const std::string& ConstructApiKeyReq::_internal_keyname() const {
  return _impl_.keyname_.Get();
}
inline void ConstructApiKeyReq::_internal_set_keyname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.keyname_.Set(value, GetArenaForAllocation());
}
inline std::string* ConstructApiKeyReq::_internal_mutable_keyname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.keyname_.Mutable(GetArenaForAllocation());
}
inline std::string* ConstructApiKeyReq::release_keyname() {
  // @@protoc_insertion_point(field_release:ServerData.ConstructApiKeyReq.keyName)
  if (!_internal_has_keyname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.keyname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.keyname_.IsDefault()) {
    _impl_.keyname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConstructApiKeyReq::set_allocated_keyname(std::string* keyname) {
  if (keyname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.keyname_.SetAllocated(keyname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.keyname_.IsDefault()) {
    _impl_.keyname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ConstructApiKeyReq.keyName)
}

// -------------------------------------------------------------------

// ConstructApiKeyResp

// int32 reqId = 1;
inline void ConstructApiKeyResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t ConstructApiKeyResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t ConstructApiKeyResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.ConstructApiKeyResp.reqId)
  return _internal_reqid();
}
inline void ConstructApiKeyResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void ConstructApiKeyResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.ConstructApiKeyResp.reqId)
}

// string accessKey = 10;
inline void ConstructApiKeyResp::clear_accesskey() {
  _impl_.accesskey_.ClearToEmpty();
}
inline const std::string& ConstructApiKeyResp::accesskey() const {
  // @@protoc_insertion_point(field_get:ServerData.ConstructApiKeyResp.accessKey)
  return _internal_accesskey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConstructApiKeyResp::set_accesskey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.accesskey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ConstructApiKeyResp.accessKey)
}
inline std::string* ConstructApiKeyResp::mutable_accesskey() {
  std::string* _s = _internal_mutable_accesskey();
  // @@protoc_insertion_point(field_mutable:ServerData.ConstructApiKeyResp.accessKey)
  return _s;
}
inline const std::string& ConstructApiKeyResp::_internal_accesskey() const {
  return _impl_.accesskey_.Get();
}
inline void ConstructApiKeyResp::_internal_set_accesskey(const std::string& value) {
  
  _impl_.accesskey_.Set(value, GetArenaForAllocation());
}
inline std::string* ConstructApiKeyResp::_internal_mutable_accesskey() {
  
  return _impl_.accesskey_.Mutable(GetArenaForAllocation());
}
inline std::string* ConstructApiKeyResp::release_accesskey() {
  // @@protoc_insertion_point(field_release:ServerData.ConstructApiKeyResp.accessKey)
  return _impl_.accesskey_.Release();
}
inline void ConstructApiKeyResp::set_allocated_accesskey(std::string* accesskey) {
  if (accesskey != nullptr) {
    
  } else {
    
  }
  _impl_.accesskey_.SetAllocated(accesskey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accesskey_.IsDefault()) {
    _impl_.accesskey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ConstructApiKeyResp.accessKey)
}

// string accessToken = 11;
inline void ConstructApiKeyResp::clear_accesstoken() {
  _impl_.accesstoken_.ClearToEmpty();
}
inline const std::string& ConstructApiKeyResp::accesstoken() const {
  // @@protoc_insertion_point(field_get:ServerData.ConstructApiKeyResp.accessToken)
  return _internal_accesstoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConstructApiKeyResp::set_accesstoken(ArgT0&& arg0, ArgT... args) {
 
 _impl_.accesstoken_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ConstructApiKeyResp.accessToken)
}
inline std::string* ConstructApiKeyResp::mutable_accesstoken() {
  std::string* _s = _internal_mutable_accesstoken();
  // @@protoc_insertion_point(field_mutable:ServerData.ConstructApiKeyResp.accessToken)
  return _s;
}
inline const std::string& ConstructApiKeyResp::_internal_accesstoken() const {
  return _impl_.accesstoken_.Get();
}
inline void ConstructApiKeyResp::_internal_set_accesstoken(const std::string& value) {
  
  _impl_.accesstoken_.Set(value, GetArenaForAllocation());
}
inline std::string* ConstructApiKeyResp::_internal_mutable_accesstoken() {
  
  return _impl_.accesstoken_.Mutable(GetArenaForAllocation());
}
inline std::string* ConstructApiKeyResp::release_accesstoken() {
  // @@protoc_insertion_point(field_release:ServerData.ConstructApiKeyResp.accessToken)
  return _impl_.accesstoken_.Release();
}
inline void ConstructApiKeyResp::set_allocated_accesstoken(std::string* accesstoken) {
  if (accesstoken != nullptr) {
    
  } else {
    
  }
  _impl_.accesstoken_.SetAllocated(accesstoken, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accesstoken_.IsDefault()) {
    _impl_.accesstoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ConstructApiKeyResp.accessToken)
}

// -------------------------------------------------------------------

// ExitAllSpacesAndLogoutReq

// int32 reqId = 1;
inline void ExitAllSpacesAndLogoutReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t ExitAllSpacesAndLogoutReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t ExitAllSpacesAndLogoutReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.ExitAllSpacesAndLogoutReq.reqId)
  return _internal_reqid();
}
inline void ExitAllSpacesAndLogoutReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void ExitAllSpacesAndLogoutReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.ExitAllSpacesAndLogoutReq.reqId)
}

// -------------------------------------------------------------------

// ExitAllSpacesAndLogoutResp

// int32 reqId = 1;
inline void ExitAllSpacesAndLogoutResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t ExitAllSpacesAndLogoutResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t ExitAllSpacesAndLogoutResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.ExitAllSpacesAndLogoutResp.reqId)
  return _internal_reqid();
}
inline void ExitAllSpacesAndLogoutResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void ExitAllSpacesAndLogoutResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.ExitAllSpacesAndLogoutResp.reqId)
}

// repeated int32 spacesExited = 20;
inline int ExitAllSpacesAndLogoutResp::_internal_spacesexited_size() const {
  return _impl_.spacesexited_.size();
}
inline int ExitAllSpacesAndLogoutResp::spacesexited_size() const {
  return _internal_spacesexited_size();
}
inline void ExitAllSpacesAndLogoutResp::clear_spacesexited() {
  _impl_.spacesexited_.Clear();
}
inline int32_t ExitAllSpacesAndLogoutResp::_internal_spacesexited(int index) const {
  return _impl_.spacesexited_.Get(index);
}
inline int32_t ExitAllSpacesAndLogoutResp::spacesexited(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.ExitAllSpacesAndLogoutResp.spacesExited)
  return _internal_spacesexited(index);
}
inline void ExitAllSpacesAndLogoutResp::set_spacesexited(int index, int32_t value) {
  _impl_.spacesexited_.Set(index, value);
  // @@protoc_insertion_point(field_set:ServerData.ExitAllSpacesAndLogoutResp.spacesExited)
}
inline void ExitAllSpacesAndLogoutResp::_internal_add_spacesexited(int32_t value) {
  _impl_.spacesexited_.Add(value);
}
inline void ExitAllSpacesAndLogoutResp::add_spacesexited(int32_t value) {
  _internal_add_spacesexited(value);
  // @@protoc_insertion_point(field_add:ServerData.ExitAllSpacesAndLogoutResp.spacesExited)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ExitAllSpacesAndLogoutResp::_internal_spacesexited() const {
  return _impl_.spacesexited_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ExitAllSpacesAndLogoutResp::spacesexited() const {
  // @@protoc_insertion_point(field_list:ServerData.ExitAllSpacesAndLogoutResp.spacesExited)
  return _internal_spacesexited();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ExitAllSpacesAndLogoutResp::_internal_mutable_spacesexited() {
  return &_impl_.spacesexited_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ExitAllSpacesAndLogoutResp::mutable_spacesexited() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.ExitAllSpacesAndLogoutResp.spacesExited)
  return _internal_mutable_spacesexited();
}

// -------------------------------------------------------------------

// JoinSpaceFromIdReq

// int32 reqId = 1;
inline void JoinSpaceFromIdReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t JoinSpaceFromIdReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t JoinSpaceFromIdReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.JoinSpaceFromIdReq.reqId)
  return _internal_reqid();
}
inline void JoinSpaceFromIdReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void JoinSpaceFromIdReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.JoinSpaceFromIdReq.reqId)
}

// string spaceId = 10;
inline void JoinSpaceFromIdReq::clear_spaceid() {
  _impl_.spaceid_.ClearToEmpty();
}
inline const std::string& JoinSpaceFromIdReq::spaceid() const {
  // @@protoc_insertion_point(field_get:ServerData.JoinSpaceFromIdReq.spaceId)
  return _internal_spaceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinSpaceFromIdReq::set_spaceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spaceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.JoinSpaceFromIdReq.spaceId)
}
inline std::string* JoinSpaceFromIdReq::mutable_spaceid() {
  std::string* _s = _internal_mutable_spaceid();
  // @@protoc_insertion_point(field_mutable:ServerData.JoinSpaceFromIdReq.spaceId)
  return _s;
}
inline const std::string& JoinSpaceFromIdReq::_internal_spaceid() const {
  return _impl_.spaceid_.Get();
}
inline void JoinSpaceFromIdReq::_internal_set_spaceid(const std::string& value) {
  
  _impl_.spaceid_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinSpaceFromIdReq::_internal_mutable_spaceid() {
  
  return _impl_.spaceid_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinSpaceFromIdReq::release_spaceid() {
  // @@protoc_insertion_point(field_release:ServerData.JoinSpaceFromIdReq.spaceId)
  return _impl_.spaceid_.Release();
}
inline void JoinSpaceFromIdReq::set_allocated_spaceid(std::string* spaceid) {
  if (spaceid != nullptr) {
    
  } else {
    
  }
  _impl_.spaceid_.SetAllocated(spaceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spaceid_.IsDefault()) {
    _impl_.spaceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.JoinSpaceFromIdReq.spaceId)
}

// -------------------------------------------------------------------

// JoinSpaceFromIdResp

// int32 reqId = 1;
inline void JoinSpaceFromIdResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t JoinSpaceFromIdResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t JoinSpaceFromIdResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.JoinSpaceFromIdResp.reqId)
  return _internal_reqid();
}
inline void JoinSpaceFromIdResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void JoinSpaceFromIdResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.JoinSpaceFromIdResp.reqId)
}

// .ServerData.CavrnusSpaceConnectionInfo spaceConn = 10;
inline bool JoinSpaceFromIdResp::_internal_has_spaceconn() const {
  return Resp_case() == kSpaceConn;
}
inline bool JoinSpaceFromIdResp::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline void JoinSpaceFromIdResp::set_has_spaceconn() {
  _impl_._oneof_case_[0] = kSpaceConn;
}
inline ::ServerData::CavrnusSpaceConnectionInfo* JoinSpaceFromIdResp::release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.JoinSpaceFromIdResp.spaceConn)
  if (_internal_has_spaceconn()) {
    clear_has_Resp();
    ::ServerData::CavrnusSpaceConnectionInfo* temp = _impl_.Resp_.spaceconn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Resp_.spaceconn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::CavrnusSpaceConnectionInfo& JoinSpaceFromIdResp::_internal_spaceconn() const {
  return _internal_has_spaceconn()
      ? *_impl_.Resp_.spaceconn_
      : reinterpret_cast< ::ServerData::CavrnusSpaceConnectionInfo&>(::ServerData::_CavrnusSpaceConnectionInfo_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnectionInfo& JoinSpaceFromIdResp::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.JoinSpaceFromIdResp.spaceConn)
  return _internal_spaceconn();
}
inline ::ServerData::CavrnusSpaceConnectionInfo* JoinSpaceFromIdResp::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.JoinSpaceFromIdResp.spaceConn)
  if (_internal_has_spaceconn()) {
    clear_has_Resp();
    ::ServerData::CavrnusSpaceConnectionInfo* temp = _impl_.Resp_.spaceconn_;
    _impl_.Resp_.spaceconn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void JoinSpaceFromIdResp::unsafe_arena_set_allocated_spaceconn(::ServerData::CavrnusSpaceConnectionInfo* spaceconn) {
  clear_Resp();
  if (spaceconn) {
    set_has_spaceconn();
    _impl_.Resp_.spaceconn_ = spaceconn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.JoinSpaceFromIdResp.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnectionInfo* JoinSpaceFromIdResp::_internal_mutable_spaceconn() {
  if (!_internal_has_spaceconn()) {
    clear_Resp();
    set_has_spaceconn();
    _impl_.Resp_.spaceconn_ = CreateMaybeMessage< ::ServerData::CavrnusSpaceConnectionInfo >(GetArenaForAllocation());
  }
  return _impl_.Resp_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnectionInfo* JoinSpaceFromIdResp::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnectionInfo* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.JoinSpaceFromIdResp.spaceConn)
  return _msg;
}

// string error = 11;
inline bool JoinSpaceFromIdResp::_internal_has_error() const {
  return Resp_case() == kError;
}
inline bool JoinSpaceFromIdResp::has_error() const {
  return _internal_has_error();
}
inline void JoinSpaceFromIdResp::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void JoinSpaceFromIdResp::clear_error() {
  if (_internal_has_error()) {
    _impl_.Resp_.error_.Destroy();
    clear_has_Resp();
  }
}
inline const std::string& JoinSpaceFromIdResp::error() const {
  // @@protoc_insertion_point(field_get:ServerData.JoinSpaceFromIdResp.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void JoinSpaceFromIdResp::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.JoinSpaceFromIdResp.error)
}
inline std::string* JoinSpaceFromIdResp::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ServerData.JoinSpaceFromIdResp.error)
  return _s;
}
inline const std::string& JoinSpaceFromIdResp::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.Resp_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void JoinSpaceFromIdResp::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  _impl_.Resp_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinSpaceFromIdResp::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Resp();
    set_has_error();
    _impl_.Resp_.error_.InitDefault();
  }
  return _impl_.Resp_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* JoinSpaceFromIdResp::release_error() {
  // @@protoc_insertion_point(field_release:ServerData.JoinSpaceFromIdResp.error)
  if (_internal_has_error()) {
    clear_has_Resp();
    return _impl_.Resp_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void JoinSpaceFromIdResp::set_allocated_error(std::string* error) {
  if (has_Resp()) {
    clear_Resp();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.Resp_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.JoinSpaceFromIdResp.error)
}

inline bool JoinSpaceFromIdResp::has_Resp() const {
  return Resp_case() != RESP_NOT_SET;
}
inline void JoinSpaceFromIdResp::clear_has_Resp() {
  _impl_._oneof_case_[0] = RESP_NOT_SET;
}
inline JoinSpaceFromIdResp::RespCase JoinSpaceFromIdResp::Resp_case() const {
  return JoinSpaceFromIdResp::RespCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerMessage

// .ServerData.CavrnusSpaceConnection messageForConnection = 1;
inline bool ServerMessage::_internal_has_messageforconnection() const {
  return this != internal_default_instance() && _impl_.messageforconnection_ != nullptr;
}
inline bool ServerMessage::has_messageforconnection() const {
  return _internal_has_messageforconnection();
}
inline const ::ServerData::CavrnusSpaceConnection& ServerMessage::_internal_messageforconnection() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.messageforconnection_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ServerMessage::messageforconnection() const {
  // @@protoc_insertion_point(field_get:ServerData.ServerMessage.messageForConnection)
  return _internal_messageforconnection();
}
inline void ServerMessage::unsafe_arena_set_allocated_messageforconnection(
    ::ServerData::CavrnusSpaceConnection* messageforconnection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.messageforconnection_);
  }
  _impl_.messageforconnection_ = messageforconnection;
  if (messageforconnection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ServerMessage.messageForConnection)
}
inline ::ServerData::CavrnusSpaceConnection* ServerMessage::release_messageforconnection() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.messageforconnection_;
  _impl_.messageforconnection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ServerMessage::unsafe_arena_release_messageforconnection() {
  // @@protoc_insertion_point(field_release:ServerData.ServerMessage.messageForConnection)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.messageforconnection_;
  _impl_.messageforconnection_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ServerMessage::_internal_mutable_messageforconnection() {
  
  if (_impl_.messageforconnection_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.messageforconnection_ = p;
  }
  return _impl_.messageforconnection_;
}
inline ::ServerData::CavrnusSpaceConnection* ServerMessage::mutable_messageforconnection() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_messageforconnection();
  // @@protoc_insertion_point(field_mutable:ServerData.ServerMessage.messageForConnection)
  return _msg;
}
inline void ServerMessage::set_allocated_messageforconnection(::ServerData::CavrnusSpaceConnection* messageforconnection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.messageforconnection_);
  }
  if (messageforconnection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(messageforconnection));
    if (message_arena != submessage_arena) {
      messageforconnection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, messageforconnection, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.messageforconnection_ = messageforconnection;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ServerMessage.messageForConnection)
}

// .ServerData.ServerMessage.Category category = 2;
inline void ServerMessage::clear_category() {
  _impl_.category_ = 0;
}
inline ::ServerData::ServerMessage_Category ServerMessage::_internal_category() const {
  return static_cast< ::ServerData::ServerMessage_Category >(_impl_.category_);
}
inline ::ServerData::ServerMessage_Category ServerMessage::category() const {
  // @@protoc_insertion_point(field_get:ServerData.ServerMessage.category)
  return _internal_category();
}
inline void ServerMessage::_internal_set_category(::ServerData::ServerMessage_Category value) {
  
  _impl_.category_ = value;
}
inline void ServerMessage::set_category(::ServerData::ServerMessage_Category value) {
  _internal_set_category(value);
  // @@protoc_insertion_point(field_set:ServerData.ServerMessage.category)
}

// string message = 3;
inline void ServerMessage::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ServerMessage::message() const {
  // @@protoc_insertion_point(field_get:ServerData.ServerMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerMessage::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ServerMessage.message)
}
inline std::string* ServerMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ServerData.ServerMessage.message)
  return _s;
}
inline const std::string& ServerMessage::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ServerMessage::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerMessage::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerMessage::release_message() {
  // @@protoc_insertion_point(field_release:ServerData.ServerMessage.message)
  return _impl_.message_.Release();
}
inline void ServerMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ServerMessage.message)
}

// -------------------------------------------------------------------

// SpaceConnectionStatus

// .ServerData.CavrnusSpaceConnection statusForConnection = 1;
inline bool SpaceConnectionStatus::_internal_has_statusforconnection() const {
  return this != internal_default_instance() && _impl_.statusforconnection_ != nullptr;
}
inline bool SpaceConnectionStatus::has_statusforconnection() const {
  return _internal_has_statusforconnection();
}
inline const ::ServerData::CavrnusSpaceConnection& SpaceConnectionStatus::_internal_statusforconnection() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.statusforconnection_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& SpaceConnectionStatus::statusforconnection() const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceConnectionStatus.statusForConnection)
  return _internal_statusforconnection();
}
inline void SpaceConnectionStatus::unsafe_arena_set_allocated_statusforconnection(
    ::ServerData::CavrnusSpaceConnection* statusforconnection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusforconnection_);
  }
  _impl_.statusforconnection_ = statusforconnection;
  if (statusforconnection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.SpaceConnectionStatus.statusForConnection)
}
inline ::ServerData::CavrnusSpaceConnection* SpaceConnectionStatus::release_statusforconnection() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.statusforconnection_;
  _impl_.statusforconnection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* SpaceConnectionStatus::unsafe_arena_release_statusforconnection() {
  // @@protoc_insertion_point(field_release:ServerData.SpaceConnectionStatus.statusForConnection)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.statusforconnection_;
  _impl_.statusforconnection_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* SpaceConnectionStatus::_internal_mutable_statusforconnection() {
  
  if (_impl_.statusforconnection_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.statusforconnection_ = p;
  }
  return _impl_.statusforconnection_;
}
inline ::ServerData::CavrnusSpaceConnection* SpaceConnectionStatus::mutable_statusforconnection() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_statusforconnection();
  // @@protoc_insertion_point(field_mutable:ServerData.SpaceConnectionStatus.statusForConnection)
  return _msg;
}
inline void SpaceConnectionStatus::set_allocated_statusforconnection(::ServerData::CavrnusSpaceConnection* statusforconnection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusforconnection_);
  }
  if (statusforconnection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusforconnection));
    if (message_arena != submessage_arena) {
      statusforconnection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusforconnection, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.statusforconnection_ = statusforconnection;
  // @@protoc_insertion_point(field_set_allocated:ServerData.SpaceConnectionStatus.statusForConnection)
}

// .ServerData.SpaceConnectionStatus.Status status = 5;
inline void SpaceConnectionStatus::clear_status() {
  _impl_.status_ = 0;
}
inline ::ServerData::SpaceConnectionStatus_Status SpaceConnectionStatus::_internal_status() const {
  return static_cast< ::ServerData::SpaceConnectionStatus_Status >(_impl_.status_);
}
inline ::ServerData::SpaceConnectionStatus_Status SpaceConnectionStatus::status() const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceConnectionStatus.status)
  return _internal_status();
}
inline void SpaceConnectionStatus::_internal_set_status(::ServerData::SpaceConnectionStatus_Status value) {
  
  _impl_.status_ = value;
}
inline void SpaceConnectionStatus::set_status(::ServerData::SpaceConnectionStatus_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ServerData.SpaceConnectionStatus.status)
}

// string lasterror = 6;
inline void SpaceConnectionStatus::clear_lasterror() {
  _impl_.lasterror_.ClearToEmpty();
}
inline const std::string& SpaceConnectionStatus::lasterror() const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceConnectionStatus.lasterror)
  return _internal_lasterror();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpaceConnectionStatus::set_lasterror(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lasterror_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.SpaceConnectionStatus.lasterror)
}
inline std::string* SpaceConnectionStatus::mutable_lasterror() {
  std::string* _s = _internal_mutable_lasterror();
  // @@protoc_insertion_point(field_mutable:ServerData.SpaceConnectionStatus.lasterror)
  return _s;
}
inline const std::string& SpaceConnectionStatus::_internal_lasterror() const {
  return _impl_.lasterror_.Get();
}
inline void SpaceConnectionStatus::_internal_set_lasterror(const std::string& value) {
  
  _impl_.lasterror_.Set(value, GetArenaForAllocation());
}
inline std::string* SpaceConnectionStatus::_internal_mutable_lasterror() {
  
  return _impl_.lasterror_.Mutable(GetArenaForAllocation());
}
inline std::string* SpaceConnectionStatus::release_lasterror() {
  // @@protoc_insertion_point(field_release:ServerData.SpaceConnectionStatus.lasterror)
  return _impl_.lasterror_.Release();
}
inline void SpaceConnectionStatus::set_allocated_lasterror(std::string* lasterror) {
  if (lasterror != nullptr) {
    
  } else {
    
  }
  _impl_.lasterror_.SetAllocated(lasterror, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lasterror_.IsDefault()) {
    _impl_.lasterror_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.SpaceConnectionStatus.lasterror)
}

// -------------------------------------------------------------------

// ShutdownSpaceConnectionReq

// int32 reqId = 1;
inline void ShutdownSpaceConnectionReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t ShutdownSpaceConnectionReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t ShutdownSpaceConnectionReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.ShutdownSpaceConnectionReq.reqId)
  return _internal_reqid();
}
inline void ShutdownSpaceConnectionReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void ShutdownSpaceConnectionReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.ShutdownSpaceConnectionReq.reqId)
}

// .ServerData.CavrnusSpaceConnection SpaceConnection = 10;
inline bool ShutdownSpaceConnectionReq::_internal_has_spaceconnection() const {
  return this != internal_default_instance() && _impl_.spaceconnection_ != nullptr;
}
inline bool ShutdownSpaceConnectionReq::has_spaceconnection() const {
  return _internal_has_spaceconnection();
}
inline const ::ServerData::CavrnusSpaceConnection& ShutdownSpaceConnectionReq::_internal_spaceconnection() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconnection_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ShutdownSpaceConnectionReq::spaceconnection() const {
  // @@protoc_insertion_point(field_get:ServerData.ShutdownSpaceConnectionReq.SpaceConnection)
  return _internal_spaceconnection();
}
inline void ShutdownSpaceConnectionReq::unsafe_arena_set_allocated_spaceconnection(
    ::ServerData::CavrnusSpaceConnection* spaceconnection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconnection_);
  }
  _impl_.spaceconnection_ = spaceconnection;
  if (spaceconnection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ShutdownSpaceConnectionReq.SpaceConnection)
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionReq::release_spaceconnection() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconnection_;
  _impl_.spaceconnection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionReq::unsafe_arena_release_spaceconnection() {
  // @@protoc_insertion_point(field_release:ServerData.ShutdownSpaceConnectionReq.SpaceConnection)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconnection_;
  _impl_.spaceconnection_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionReq::_internal_mutable_spaceconnection() {
  
  if (_impl_.spaceconnection_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconnection_ = p;
  }
  return _impl_.spaceconnection_;
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionReq::mutable_spaceconnection() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconnection();
  // @@protoc_insertion_point(field_mutable:ServerData.ShutdownSpaceConnectionReq.SpaceConnection)
  return _msg;
}
inline void ShutdownSpaceConnectionReq::set_allocated_spaceconnection(::ServerData::CavrnusSpaceConnection* spaceconnection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconnection_);
  }
  if (spaceconnection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconnection));
    if (message_arena != submessage_arena) {
      spaceconnection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconnection, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconnection_ = spaceconnection;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ShutdownSpaceConnectionReq.SpaceConnection)
}

// -------------------------------------------------------------------

// ShutdownSpaceConnectionResp

// int32 reqId = 1;
inline void ShutdownSpaceConnectionResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t ShutdownSpaceConnectionResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t ShutdownSpaceConnectionResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.ShutdownSpaceConnectionResp.reqId)
  return _internal_reqid();
}
inline void ShutdownSpaceConnectionResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void ShutdownSpaceConnectionResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.ShutdownSpaceConnectionResp.reqId)
}

// .ServerData.CavrnusSpaceConnection spaceConn = 10;
inline bool ShutdownSpaceConnectionResp::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool ShutdownSpaceConnectionResp::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& ShutdownSpaceConnectionResp::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ShutdownSpaceConnectionResp::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.ShutdownSpaceConnectionResp.spaceConn)
  return _internal_spaceconn();
}
inline void ShutdownSpaceConnectionResp::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ShutdownSpaceConnectionResp.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionResp::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionResp::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.ShutdownSpaceConnectionResp.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionResp::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* ShutdownSpaceConnectionResp::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.ShutdownSpaceConnectionResp.spaceConn)
  return _msg;
}
inline void ShutdownSpaceConnectionResp::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ShutdownSpaceConnectionResp.spaceConn)
}

// -------------------------------------------------------------------

// CreateSpaceReq

// int32 reqId = 1;
inline void CreateSpaceReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t CreateSpaceReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t CreateSpaceReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.CreateSpaceReq.reqId)
  return _internal_reqid();
}
inline void CreateSpaceReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void CreateSpaceReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.CreateSpaceReq.reqId)
}

// string newSpaceName = 10;
inline void CreateSpaceReq::clear_newspacename() {
  _impl_.newspacename_.ClearToEmpty();
}
inline const std::string& CreateSpaceReq::newspacename() const {
  // @@protoc_insertion_point(field_get:ServerData.CreateSpaceReq.newSpaceName)
  return _internal_newspacename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSpaceReq::set_newspacename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newspacename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CreateSpaceReq.newSpaceName)
}
inline std::string* CreateSpaceReq::mutable_newspacename() {
  std::string* _s = _internal_mutable_newspacename();
  // @@protoc_insertion_point(field_mutable:ServerData.CreateSpaceReq.newSpaceName)
  return _s;
}
inline const std::string& CreateSpaceReq::_internal_newspacename() const {
  return _impl_.newspacename_.Get();
}
inline void CreateSpaceReq::_internal_set_newspacename(const std::string& value) {
  
  _impl_.newspacename_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSpaceReq::_internal_mutable_newspacename() {
  
  return _impl_.newspacename_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSpaceReq::release_newspacename() {
  // @@protoc_insertion_point(field_release:ServerData.CreateSpaceReq.newSpaceName)
  return _impl_.newspacename_.Release();
}
inline void CreateSpaceReq::set_allocated_newspacename(std::string* newspacename) {
  if (newspacename != nullptr) {
    
  } else {
    
  }
  _impl_.newspacename_.SetAllocated(newspacename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newspacename_.IsDefault()) {
    _impl_.newspacename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CreateSpaceReq.newSpaceName)
}

// repeated string keywords = 11;
inline int CreateSpaceReq::_internal_keywords_size() const {
  return _impl_.keywords_.size();
}
inline int CreateSpaceReq::keywords_size() const {
  return _internal_keywords_size();
}
inline void CreateSpaceReq::clear_keywords() {
  _impl_.keywords_.Clear();
}
inline std::string* CreateSpaceReq::add_keywords() {
  std::string* _s = _internal_add_keywords();
  // @@protoc_insertion_point(field_add_mutable:ServerData.CreateSpaceReq.keywords)
  return _s;
}
inline const std::string& CreateSpaceReq::_internal_keywords(int index) const {
  return _impl_.keywords_.Get(index);
}
inline const std::string& CreateSpaceReq::keywords(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.CreateSpaceReq.keywords)
  return _internal_keywords(index);
}
inline std::string* CreateSpaceReq::mutable_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.CreateSpaceReq.keywords)
  return _impl_.keywords_.Mutable(index);
}
inline void CreateSpaceReq::set_keywords(int index, const std::string& value) {
  _impl_.keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerData.CreateSpaceReq.keywords)
}
inline void CreateSpaceReq::set_keywords(int index, std::string&& value) {
  _impl_.keywords_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerData.CreateSpaceReq.keywords)
}
inline void CreateSpaceReq::set_keywords(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerData.CreateSpaceReq.keywords)
}
inline void CreateSpaceReq::set_keywords(int index, const char* value, size_t size) {
  _impl_.keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerData.CreateSpaceReq.keywords)
}
inline std::string* CreateSpaceReq::_internal_add_keywords() {
  return _impl_.keywords_.Add();
}
inline void CreateSpaceReq::add_keywords(const std::string& value) {
  _impl_.keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerData.CreateSpaceReq.keywords)
}
inline void CreateSpaceReq::add_keywords(std::string&& value) {
  _impl_.keywords_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerData.CreateSpaceReq.keywords)
}
inline void CreateSpaceReq::add_keywords(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerData.CreateSpaceReq.keywords)
}
inline void CreateSpaceReq::add_keywords(const char* value, size_t size) {
  _impl_.keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerData.CreateSpaceReq.keywords)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateSpaceReq::keywords() const {
  // @@protoc_insertion_point(field_list:ServerData.CreateSpaceReq.keywords)
  return _impl_.keywords_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateSpaceReq::mutable_keywords() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.CreateSpaceReq.keywords)
  return &_impl_.keywords_;
}

// -------------------------------------------------------------------

// CreateSpaceResp

// int32 reqId = 1;
inline void CreateSpaceResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t CreateSpaceResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t CreateSpaceResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.CreateSpaceResp.reqId)
  return _internal_reqid();
}
inline void CreateSpaceResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void CreateSpaceResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.CreateSpaceResp.reqId)
}

// .ServerData.SpaceInfo newSpaceInfo = 10;
inline bool CreateSpaceResp::_internal_has_newspaceinfo() const {
  return this != internal_default_instance() && _impl_.newspaceinfo_ != nullptr;
}
inline bool CreateSpaceResp::has_newspaceinfo() const {
  return _internal_has_newspaceinfo();
}
inline const ::ServerData::SpaceInfo& CreateSpaceResp::_internal_newspaceinfo() const {
  const ::ServerData::SpaceInfo* p = _impl_.newspaceinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::SpaceInfo&>(
      ::ServerData::_SpaceInfo_default_instance_);
}
inline const ::ServerData::SpaceInfo& CreateSpaceResp::newspaceinfo() const {
  // @@protoc_insertion_point(field_get:ServerData.CreateSpaceResp.newSpaceInfo)
  return _internal_newspaceinfo();
}
inline void CreateSpaceResp::unsafe_arena_set_allocated_newspaceinfo(
    ::ServerData::SpaceInfo* newspaceinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.newspaceinfo_);
  }
  _impl_.newspaceinfo_ = newspaceinfo;
  if (newspaceinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.CreateSpaceResp.newSpaceInfo)
}
inline ::ServerData::SpaceInfo* CreateSpaceResp::release_newspaceinfo() {
  
  ::ServerData::SpaceInfo* temp = _impl_.newspaceinfo_;
  _impl_.newspaceinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::SpaceInfo* CreateSpaceResp::unsafe_arena_release_newspaceinfo() {
  // @@protoc_insertion_point(field_release:ServerData.CreateSpaceResp.newSpaceInfo)
  
  ::ServerData::SpaceInfo* temp = _impl_.newspaceinfo_;
  _impl_.newspaceinfo_ = nullptr;
  return temp;
}
inline ::ServerData::SpaceInfo* CreateSpaceResp::_internal_mutable_newspaceinfo() {
  
  if (_impl_.newspaceinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::SpaceInfo>(GetArenaForAllocation());
    _impl_.newspaceinfo_ = p;
  }
  return _impl_.newspaceinfo_;
}
inline ::ServerData::SpaceInfo* CreateSpaceResp::mutable_newspaceinfo() {
  ::ServerData::SpaceInfo* _msg = _internal_mutable_newspaceinfo();
  // @@protoc_insertion_point(field_mutable:ServerData.CreateSpaceResp.newSpaceInfo)
  return _msg;
}
inline void CreateSpaceResp::set_allocated_newspaceinfo(::ServerData::SpaceInfo* newspaceinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.newspaceinfo_);
  }
  if (newspaceinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newspaceinfo));
    if (message_arena != submessage_arena) {
      newspaceinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newspaceinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.newspaceinfo_ = newspaceinfo;
  // @@protoc_insertion_point(field_set_allocated:ServerData.CreateSpaceResp.newSpaceInfo)
}

// -------------------------------------------------------------------

// FetchAllUserRolesReq

// int32 reqId = 1;
inline void FetchAllUserRolesReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t FetchAllUserRolesReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t FetchAllUserRolesReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchAllUserRolesReq.reqId)
  return _internal_reqid();
}
inline void FetchAllUserRolesReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void FetchAllUserRolesReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.FetchAllUserRolesReq.reqId)
}

// -------------------------------------------------------------------

// FetchAllUserRolesResp

// int32 reqId = 1;
inline void FetchAllUserRolesResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t FetchAllUserRolesResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t FetchAllUserRolesResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchAllUserRolesResp.reqId)
  return _internal_reqid();
}
inline void FetchAllUserRolesResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void FetchAllUserRolesResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.FetchAllUserRolesResp.reqId)
}

// repeated .ServerData.CavrnusRole allRoles = 10;
inline int FetchAllUserRolesResp::_internal_allroles_size() const {
  return _impl_.allroles_.size();
}
inline int FetchAllUserRolesResp::allroles_size() const {
  return _internal_allroles_size();
}
inline ::ServerData::CavrnusRole* FetchAllUserRolesResp::mutable_allroles(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.FetchAllUserRolesResp.allRoles)
  return _impl_.allroles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRole >*
FetchAllUserRolesResp::mutable_allroles() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.FetchAllUserRolesResp.allRoles)
  return &_impl_.allroles_;
}
inline const ::ServerData::CavrnusRole& FetchAllUserRolesResp::_internal_allroles(int index) const {
  return _impl_.allroles_.Get(index);
}
inline const ::ServerData::CavrnusRole& FetchAllUserRolesResp::allroles(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.FetchAllUserRolesResp.allRoles)
  return _internal_allroles(index);
}
inline ::ServerData::CavrnusRole* FetchAllUserRolesResp::_internal_add_allroles() {
  return _impl_.allroles_.Add();
}
inline ::ServerData::CavrnusRole* FetchAllUserRolesResp::add_allroles() {
  ::ServerData::CavrnusRole* _add = _internal_add_allroles();
  // @@protoc_insertion_point(field_add:ServerData.FetchAllUserRolesResp.allRoles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRole >&
FetchAllUserRolesResp::allroles() const {
  // @@protoc_insertion_point(field_list:ServerData.FetchAllUserRolesResp.allRoles)
  return _impl_.allroles_;
}

// -------------------------------------------------------------------

// FetchAllUserAccountsReq

// int32 reqId = 1;
inline void FetchAllUserAccountsReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t FetchAllUserAccountsReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t FetchAllUserAccountsReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchAllUserAccountsReq.reqId)
  return _internal_reqid();
}
inline void FetchAllUserAccountsReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void FetchAllUserAccountsReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.FetchAllUserAccountsReq.reqId)
}

// -------------------------------------------------------------------

// FetchAllUserAccountsResp

// int32 reqId = 1;
inline void FetchAllUserAccountsResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t FetchAllUserAccountsResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t FetchAllUserAccountsResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchAllUserAccountsResp.reqId)
  return _internal_reqid();
}
inline void FetchAllUserAccountsResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void FetchAllUserAccountsResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.FetchAllUserAccountsResp.reqId)
}

// repeated .ServerData.CavrnusUserAccount allUserAccounts = 10;
inline int FetchAllUserAccountsResp::_internal_alluseraccounts_size() const {
  return _impl_.alluseraccounts_.size();
}
inline int FetchAllUserAccountsResp::alluseraccounts_size() const {
  return _internal_alluseraccounts_size();
}
inline ::ServerData::CavrnusUserAccount* FetchAllUserAccountsResp::mutable_alluseraccounts(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.FetchAllUserAccountsResp.allUserAccounts)
  return _impl_.alluseraccounts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusUserAccount >*
FetchAllUserAccountsResp::mutable_alluseraccounts() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.FetchAllUserAccountsResp.allUserAccounts)
  return &_impl_.alluseraccounts_;
}
inline const ::ServerData::CavrnusUserAccount& FetchAllUserAccountsResp::_internal_alluseraccounts(int index) const {
  return _impl_.alluseraccounts_.Get(index);
}
inline const ::ServerData::CavrnusUserAccount& FetchAllUserAccountsResp::alluseraccounts(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.FetchAllUserAccountsResp.allUserAccounts)
  return _internal_alluseraccounts(index);
}
inline ::ServerData::CavrnusUserAccount* FetchAllUserAccountsResp::_internal_add_alluseraccounts() {
  return _impl_.alluseraccounts_.Add();
}
inline ::ServerData::CavrnusUserAccount* FetchAllUserAccountsResp::add_alluseraccounts() {
  ::ServerData::CavrnusUserAccount* _add = _internal_add_alluseraccounts();
  // @@protoc_insertion_point(field_add:ServerData.FetchAllUserAccountsResp.allUserAccounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusUserAccount >&
FetchAllUserAccountsResp::alluseraccounts() const {
  // @@protoc_insertion_point(field_list:ServerData.FetchAllUserAccountsResp.allUserAccounts)
  return _impl_.alluseraccounts_;
}

// -------------------------------------------------------------------

// InviteUserAccountToSpaceReq

// int32 reqId = 1;
inline void InviteUserAccountToSpaceReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t InviteUserAccountToSpaceReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t InviteUserAccountToSpaceReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.InviteUserAccountToSpaceReq.reqId)
  return _internal_reqid();
}
inline void InviteUserAccountToSpaceReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void InviteUserAccountToSpaceReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.InviteUserAccountToSpaceReq.reqId)
}

// string userEmail = 10;
inline void InviteUserAccountToSpaceReq::clear_useremail() {
  _impl_.useremail_.ClearToEmpty();
}
inline const std::string& InviteUserAccountToSpaceReq::useremail() const {
  // @@protoc_insertion_point(field_get:ServerData.InviteUserAccountToSpaceReq.userEmail)
  return _internal_useremail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InviteUserAccountToSpaceReq::set_useremail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.useremail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.InviteUserAccountToSpaceReq.userEmail)
}
inline std::string* InviteUserAccountToSpaceReq::mutable_useremail() {
  std::string* _s = _internal_mutable_useremail();
  // @@protoc_insertion_point(field_mutable:ServerData.InviteUserAccountToSpaceReq.userEmail)
  return _s;
}
inline const std::string& InviteUserAccountToSpaceReq::_internal_useremail() const {
  return _impl_.useremail_.Get();
}
inline void InviteUserAccountToSpaceReq::_internal_set_useremail(const std::string& value) {
  
  _impl_.useremail_.Set(value, GetArenaForAllocation());
}
inline std::string* InviteUserAccountToSpaceReq::_internal_mutable_useremail() {
  
  return _impl_.useremail_.Mutable(GetArenaForAllocation());
}
inline std::string* InviteUserAccountToSpaceReq::release_useremail() {
  // @@protoc_insertion_point(field_release:ServerData.InviteUserAccountToSpaceReq.userEmail)
  return _impl_.useremail_.Release();
}
inline void InviteUserAccountToSpaceReq::set_allocated_useremail(std::string* useremail) {
  if (useremail != nullptr) {
    
  } else {
    
  }
  _impl_.useremail_.SetAllocated(useremail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.useremail_.IsDefault()) {
    _impl_.useremail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.InviteUserAccountToSpaceReq.userEmail)
}

// string spaceId = 11;
inline void InviteUserAccountToSpaceReq::clear_spaceid() {
  _impl_.spaceid_.ClearToEmpty();
}
inline const std::string& InviteUserAccountToSpaceReq::spaceid() const {
  // @@protoc_insertion_point(field_get:ServerData.InviteUserAccountToSpaceReq.spaceId)
  return _internal_spaceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InviteUserAccountToSpaceReq::set_spaceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spaceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.InviteUserAccountToSpaceReq.spaceId)
}
inline std::string* InviteUserAccountToSpaceReq::mutable_spaceid() {
  std::string* _s = _internal_mutable_spaceid();
  // @@protoc_insertion_point(field_mutable:ServerData.InviteUserAccountToSpaceReq.spaceId)
  return _s;
}
inline const std::string& InviteUserAccountToSpaceReq::_internal_spaceid() const {
  return _impl_.spaceid_.Get();
}
inline void InviteUserAccountToSpaceReq::_internal_set_spaceid(const std::string& value) {
  
  _impl_.spaceid_.Set(value, GetArenaForAllocation());
}
inline std::string* InviteUserAccountToSpaceReq::_internal_mutable_spaceid() {
  
  return _impl_.spaceid_.Mutable(GetArenaForAllocation());
}
inline std::string* InviteUserAccountToSpaceReq::release_spaceid() {
  // @@protoc_insertion_point(field_release:ServerData.InviteUserAccountToSpaceReq.spaceId)
  return _impl_.spaceid_.Release();
}
inline void InviteUserAccountToSpaceReq::set_allocated_spaceid(std::string* spaceid) {
  if (spaceid != nullptr) {
    
  } else {
    
  }
  _impl_.spaceid_.SetAllocated(spaceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spaceid_.IsDefault()) {
    _impl_.spaceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.InviteUserAccountToSpaceReq.spaceId)
}

// optional string roleId = 12;
inline bool InviteUserAccountToSpaceReq::_internal_has_roleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InviteUserAccountToSpaceReq::has_roleid() const {
  return _internal_has_roleid();
}
inline void InviteUserAccountToSpaceReq::clear_roleid() {
  _impl_.roleid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InviteUserAccountToSpaceReq::roleid() const {
  // @@protoc_insertion_point(field_get:ServerData.InviteUserAccountToSpaceReq.roleId)
  return _internal_roleid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InviteUserAccountToSpaceReq::set_roleid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.roleid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.InviteUserAccountToSpaceReq.roleId)
}
inline std::string* InviteUserAccountToSpaceReq::mutable_roleid() {
  std::string* _s = _internal_mutable_roleid();
  // @@protoc_insertion_point(field_mutable:ServerData.InviteUserAccountToSpaceReq.roleId)
  return _s;
}
inline const std::string& InviteUserAccountToSpaceReq::_internal_roleid() const {
  return _impl_.roleid_.Get();
}
inline void InviteUserAccountToSpaceReq::_internal_set_roleid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.roleid_.Set(value, GetArenaForAllocation());
}
inline std::string* InviteUserAccountToSpaceReq::_internal_mutable_roleid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.roleid_.Mutable(GetArenaForAllocation());
}
inline std::string* InviteUserAccountToSpaceReq::release_roleid() {
  // @@protoc_insertion_point(field_release:ServerData.InviteUserAccountToSpaceReq.roleId)
  if (!_internal_has_roleid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.roleid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roleid_.IsDefault()) {
    _impl_.roleid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InviteUserAccountToSpaceReq::set_allocated_roleid(std::string* roleid) {
  if (roleid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.roleid_.SetAllocated(roleid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roleid_.IsDefault()) {
    _impl_.roleid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.InviteUserAccountToSpaceReq.roleId)
}

// -------------------------------------------------------------------

// RemoveUserAccountFromSpaceReq

// int32 reqId = 1;
inline void RemoveUserAccountFromSpaceReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t RemoveUserAccountFromSpaceReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t RemoveUserAccountFromSpaceReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.RemoveUserAccountFromSpaceReq.reqId)
  return _internal_reqid();
}
inline void RemoveUserAccountFromSpaceReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void RemoveUserAccountFromSpaceReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.RemoveUserAccountFromSpaceReq.reqId)
}

// string userAccountId = 10;
inline void RemoveUserAccountFromSpaceReq::clear_useraccountid() {
  _impl_.useraccountid_.ClearToEmpty();
}
inline const std::string& RemoveUserAccountFromSpaceReq::useraccountid() const {
  // @@protoc_insertion_point(field_get:ServerData.RemoveUserAccountFromSpaceReq.userAccountId)
  return _internal_useraccountid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveUserAccountFromSpaceReq::set_useraccountid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.useraccountid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RemoveUserAccountFromSpaceReq.userAccountId)
}
inline std::string* RemoveUserAccountFromSpaceReq::mutable_useraccountid() {
  std::string* _s = _internal_mutable_useraccountid();
  // @@protoc_insertion_point(field_mutable:ServerData.RemoveUserAccountFromSpaceReq.userAccountId)
  return _s;
}
inline const std::string& RemoveUserAccountFromSpaceReq::_internal_useraccountid() const {
  return _impl_.useraccountid_.Get();
}
inline void RemoveUserAccountFromSpaceReq::_internal_set_useraccountid(const std::string& value) {
  
  _impl_.useraccountid_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveUserAccountFromSpaceReq::_internal_mutable_useraccountid() {
  
  return _impl_.useraccountid_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveUserAccountFromSpaceReq::release_useraccountid() {
  // @@protoc_insertion_point(field_release:ServerData.RemoveUserAccountFromSpaceReq.userAccountId)
  return _impl_.useraccountid_.Release();
}
inline void RemoveUserAccountFromSpaceReq::set_allocated_useraccountid(std::string* useraccountid) {
  if (useraccountid != nullptr) {
    
  } else {
    
  }
  _impl_.useraccountid_.SetAllocated(useraccountid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.useraccountid_.IsDefault()) {
    _impl_.useraccountid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RemoveUserAccountFromSpaceReq.userAccountId)
}

// string spaceId = 11;
inline void RemoveUserAccountFromSpaceReq::clear_spaceid() {
  _impl_.spaceid_.ClearToEmpty();
}
inline const std::string& RemoveUserAccountFromSpaceReq::spaceid() const {
  // @@protoc_insertion_point(field_get:ServerData.RemoveUserAccountFromSpaceReq.spaceId)
  return _internal_spaceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveUserAccountFromSpaceReq::set_spaceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spaceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RemoveUserAccountFromSpaceReq.spaceId)
}
inline std::string* RemoveUserAccountFromSpaceReq::mutable_spaceid() {
  std::string* _s = _internal_mutable_spaceid();
  // @@protoc_insertion_point(field_mutable:ServerData.RemoveUserAccountFromSpaceReq.spaceId)
  return _s;
}
inline const std::string& RemoveUserAccountFromSpaceReq::_internal_spaceid() const {
  return _impl_.spaceid_.Get();
}
inline void RemoveUserAccountFromSpaceReq::_internal_set_spaceid(const std::string& value) {
  
  _impl_.spaceid_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveUserAccountFromSpaceReq::_internal_mutable_spaceid() {
  
  return _impl_.spaceid_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveUserAccountFromSpaceReq::release_spaceid() {
  // @@protoc_insertion_point(field_release:ServerData.RemoveUserAccountFromSpaceReq.spaceId)
  return _impl_.spaceid_.Release();
}
inline void RemoveUserAccountFromSpaceReq::set_allocated_spaceid(std::string* spaceid) {
  if (spaceid != nullptr) {
    
  } else {
    
  }
  _impl_.spaceid_.SetAllocated(spaceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spaceid_.IsDefault()) {
    _impl_.spaceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RemoveUserAccountFromSpaceReq.spaceId)
}

// -------------------------------------------------------------------

// PropertyValue

// bool boolVal = 10;
inline bool PropertyValue::_internal_has_boolval() const {
  return Value_case() == kBoolVal;
}
inline bool PropertyValue::has_boolval() const {
  return _internal_has_boolval();
}
inline void PropertyValue::set_has_boolval() {
  _impl_._oneof_case_[0] = kBoolVal;
}
inline void PropertyValue::clear_boolval() {
  if (_internal_has_boolval()) {
    _impl_.Value_.boolval_ = false;
    clear_has_Value();
  }
}
inline bool PropertyValue::_internal_boolval() const {
  if (_internal_has_boolval()) {
    return _impl_.Value_.boolval_;
  }
  return false;
}
inline void PropertyValue::_internal_set_boolval(bool value) {
  if (!_internal_has_boolval()) {
    clear_Value();
    set_has_boolval();
  }
  _impl_.Value_.boolval_ = value;
}
inline bool PropertyValue::boolval() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValue.boolVal)
  return _internal_boolval();
}
inline void PropertyValue::set_boolval(bool value) {
  _internal_set_boolval(value);
  // @@protoc_insertion_point(field_set:ServerData.PropertyValue.boolVal)
}

// string stringVal = 11;
inline bool PropertyValue::_internal_has_stringval() const {
  return Value_case() == kStringVal;
}
inline bool PropertyValue::has_stringval() const {
  return _internal_has_stringval();
}
inline void PropertyValue::set_has_stringval() {
  _impl_._oneof_case_[0] = kStringVal;
}
inline void PropertyValue::clear_stringval() {
  if (_internal_has_stringval()) {
    _impl_.Value_.stringval_.Destroy();
    clear_has_Value();
  }
}
inline const std::string& PropertyValue::stringval() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValue.stringVal)
  return _internal_stringval();
}
template <typename ArgT0, typename... ArgT>
inline void PropertyValue::set_stringval(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_stringval()) {
    clear_Value();
    set_has_stringval();
    _impl_.Value_.stringval_.InitDefault();
  }
  _impl_.Value_.stringval_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PropertyValue.stringVal)
}
inline std::string* PropertyValue::mutable_stringval() {
  std::string* _s = _internal_mutable_stringval();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValue.stringVal)
  return _s;
}
inline const std::string& PropertyValue::_internal_stringval() const {
  if (_internal_has_stringval()) {
    return _impl_.Value_.stringval_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PropertyValue::_internal_set_stringval(const std::string& value) {
  if (!_internal_has_stringval()) {
    clear_Value();
    set_has_stringval();
    _impl_.Value_.stringval_.InitDefault();
  }
  _impl_.Value_.stringval_.Set(value, GetArenaForAllocation());
}
inline std::string* PropertyValue::_internal_mutable_stringval() {
  if (!_internal_has_stringval()) {
    clear_Value();
    set_has_stringval();
    _impl_.Value_.stringval_.InitDefault();
  }
  return _impl_.Value_.stringval_.Mutable(      GetArenaForAllocation());
}
inline std::string* PropertyValue::release_stringval() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValue.stringVal)
  if (_internal_has_stringval()) {
    clear_has_Value();
    return _impl_.Value_.stringval_.Release();
  } else {
    return nullptr;
  }
}
inline void PropertyValue::set_allocated_stringval(std::string* stringval) {
  if (has_Value()) {
    clear_Value();
  }
  if (stringval != nullptr) {
    set_has_stringval();
    _impl_.Value_.stringval_.InitAllocated(stringval, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ServerData.PropertyValue.stringVal)
}

// float scalarVal = 12;
inline bool PropertyValue::_internal_has_scalarval() const {
  return Value_case() == kScalarVal;
}
inline bool PropertyValue::has_scalarval() const {
  return _internal_has_scalarval();
}
inline void PropertyValue::set_has_scalarval() {
  _impl_._oneof_case_[0] = kScalarVal;
}
inline void PropertyValue::clear_scalarval() {
  if (_internal_has_scalarval()) {
    _impl_.Value_.scalarval_ = 0;
    clear_has_Value();
  }
}
inline float PropertyValue::_internal_scalarval() const {
  if (_internal_has_scalarval()) {
    return _impl_.Value_.scalarval_;
  }
  return 0;
}
inline void PropertyValue::_internal_set_scalarval(float value) {
  if (!_internal_has_scalarval()) {
    clear_Value();
    set_has_scalarval();
  }
  _impl_.Value_.scalarval_ = value;
}
inline float PropertyValue::scalarval() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValue.scalarVal)
  return _internal_scalarval();
}
inline void PropertyValue::set_scalarval(float value) {
  _internal_set_scalarval(value);
  // @@protoc_insertion_point(field_set:ServerData.PropertyValue.scalarVal)
}

// .Common.Float4 vectorVal = 13;
inline bool PropertyValue::_internal_has_vectorval() const {
  return Value_case() == kVectorVal;
}
inline bool PropertyValue::has_vectorval() const {
  return _internal_has_vectorval();
}
inline void PropertyValue::set_has_vectorval() {
  _impl_._oneof_case_[0] = kVectorVal;
}
inline ::Common::Float4* PropertyValue::release_vectorval() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValue.vectorVal)
  if (_internal_has_vectorval()) {
    clear_has_Value();
    ::Common::Float4* temp = _impl_.Value_.vectorval_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Value_.vectorval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Common::Float4& PropertyValue::_internal_vectorval() const {
  return _internal_has_vectorval()
      ? *_impl_.Value_.vectorval_
      : reinterpret_cast< ::Common::Float4&>(::Common::_Float4_default_instance_);
}
inline const ::Common::Float4& PropertyValue::vectorval() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValue.vectorVal)
  return _internal_vectorval();
}
inline ::Common::Float4* PropertyValue::unsafe_arena_release_vectorval() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.PropertyValue.vectorVal)
  if (_internal_has_vectorval()) {
    clear_has_Value();
    ::Common::Float4* temp = _impl_.Value_.vectorval_;
    _impl_.Value_.vectorval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PropertyValue::unsafe_arena_set_allocated_vectorval(::Common::Float4* vectorval) {
  clear_Value();
  if (vectorval) {
    set_has_vectorval();
    _impl_.Value_.vectorval_ = vectorval;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropertyValue.vectorVal)
}
inline ::Common::Float4* PropertyValue::_internal_mutable_vectorval() {
  if (!_internal_has_vectorval()) {
    clear_Value();
    set_has_vectorval();
    _impl_.Value_.vectorval_ = CreateMaybeMessage< ::Common::Float4 >(GetArenaForAllocation());
  }
  return _impl_.Value_.vectorval_;
}
inline ::Common::Float4* PropertyValue::mutable_vectorval() {
  ::Common::Float4* _msg = _internal_mutable_vectorval();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValue.vectorVal)
  return _msg;
}

// .Common.Color4 colorVal = 14;
inline bool PropertyValue::_internal_has_colorval() const {
  return Value_case() == kColorVal;
}
inline bool PropertyValue::has_colorval() const {
  return _internal_has_colorval();
}
inline void PropertyValue::set_has_colorval() {
  _impl_._oneof_case_[0] = kColorVal;
}
inline ::Common::Color4* PropertyValue::release_colorval() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValue.colorVal)
  if (_internal_has_colorval()) {
    clear_has_Value();
    ::Common::Color4* temp = _impl_.Value_.colorval_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Value_.colorval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Common::Color4& PropertyValue::_internal_colorval() const {
  return _internal_has_colorval()
      ? *_impl_.Value_.colorval_
      : reinterpret_cast< ::Common::Color4&>(::Common::_Color4_default_instance_);
}
inline const ::Common::Color4& PropertyValue::colorval() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValue.colorVal)
  return _internal_colorval();
}
inline ::Common::Color4* PropertyValue::unsafe_arena_release_colorval() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.PropertyValue.colorVal)
  if (_internal_has_colorval()) {
    clear_has_Value();
    ::Common::Color4* temp = _impl_.Value_.colorval_;
    _impl_.Value_.colorval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PropertyValue::unsafe_arena_set_allocated_colorval(::Common::Color4* colorval) {
  clear_Value();
  if (colorval) {
    set_has_colorval();
    _impl_.Value_.colorval_ = colorval;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropertyValue.colorVal)
}
inline ::Common::Color4* PropertyValue::_internal_mutable_colorval() {
  if (!_internal_has_colorval()) {
    clear_Value();
    set_has_colorval();
    _impl_.Value_.colorval_ = CreateMaybeMessage< ::Common::Color4 >(GetArenaForAllocation());
  }
  return _impl_.Value_.colorval_;
}
inline ::Common::Color4* PropertyValue::mutable_colorval() {
  ::Common::Color4* _msg = _internal_mutable_colorval();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValue.colorVal)
  return _msg;
}

// .ServerData.TransformPropertyValue transformVal = 17;
inline bool PropertyValue::_internal_has_transformval() const {
  return Value_case() == kTransformVal;
}
inline bool PropertyValue::has_transformval() const {
  return _internal_has_transformval();
}
inline void PropertyValue::set_has_transformval() {
  _impl_._oneof_case_[0] = kTransformVal;
}
inline void PropertyValue::clear_transformval() {
  if (_internal_has_transformval()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Value_.transformval_;
    }
    clear_has_Value();
  }
}
inline ::ServerData::TransformPropertyValue* PropertyValue::release_transformval() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValue.transformVal)
  if (_internal_has_transformval()) {
    clear_has_Value();
    ::ServerData::TransformPropertyValue* temp = _impl_.Value_.transformval_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Value_.transformval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerData::TransformPropertyValue& PropertyValue::_internal_transformval() const {
  return _internal_has_transformval()
      ? *_impl_.Value_.transformval_
      : reinterpret_cast< ::ServerData::TransformPropertyValue&>(::ServerData::_TransformPropertyValue_default_instance_);
}
inline const ::ServerData::TransformPropertyValue& PropertyValue::transformval() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValue.transformVal)
  return _internal_transformval();
}
inline ::ServerData::TransformPropertyValue* PropertyValue::unsafe_arena_release_transformval() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.PropertyValue.transformVal)
  if (_internal_has_transformval()) {
    clear_has_Value();
    ::ServerData::TransformPropertyValue* temp = _impl_.Value_.transformval_;
    _impl_.Value_.transformval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PropertyValue::unsafe_arena_set_allocated_transformval(::ServerData::TransformPropertyValue* transformval) {
  clear_Value();
  if (transformval) {
    set_has_transformval();
    _impl_.Value_.transformval_ = transformval;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropertyValue.transformVal)
}
inline ::ServerData::TransformPropertyValue* PropertyValue::_internal_mutable_transformval() {
  if (!_internal_has_transformval()) {
    clear_Value();
    set_has_transformval();
    _impl_.Value_.transformval_ = CreateMaybeMessage< ::ServerData::TransformPropertyValue >(GetArenaForAllocation());
  }
  return _impl_.Value_.transformval_;
}
inline ::ServerData::TransformPropertyValue* PropertyValue::mutable_transformval() {
  ::ServerData::TransformPropertyValue* _msg = _internal_mutable_transformval();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValue.transformVal)
  return _msg;
}

// .Property.PropertyIdentifier linkVal = 15;
inline bool PropertyValue::_internal_has_linkval() const {
  return Value_case() == kLinkVal;
}
inline bool PropertyValue::has_linkval() const {
  return _internal_has_linkval();
}
inline void PropertyValue::set_has_linkval() {
  _impl_._oneof_case_[0] = kLinkVal;
}
inline ::Property::PropertyIdentifier* PropertyValue::release_linkval() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValue.linkVal)
  if (_internal_has_linkval()) {
    clear_has_Value();
    ::Property::PropertyIdentifier* temp = _impl_.Value_.linkval_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Value_.linkval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Property::PropertyIdentifier& PropertyValue::_internal_linkval() const {
  return _internal_has_linkval()
      ? *_impl_.Value_.linkval_
      : reinterpret_cast< ::Property::PropertyIdentifier&>(::Property::_PropertyIdentifier_default_instance_);
}
inline const ::Property::PropertyIdentifier& PropertyValue::linkval() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValue.linkVal)
  return _internal_linkval();
}
inline ::Property::PropertyIdentifier* PropertyValue::unsafe_arena_release_linkval() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerData.PropertyValue.linkVal)
  if (_internal_has_linkval()) {
    clear_has_Value();
    ::Property::PropertyIdentifier* temp = _impl_.Value_.linkval_;
    _impl_.Value_.linkval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PropertyValue::unsafe_arena_set_allocated_linkval(::Property::PropertyIdentifier* linkval) {
  clear_Value();
  if (linkval) {
    set_has_linkval();
    _impl_.Value_.linkval_ = linkval;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropertyValue.linkVal)
}
inline ::Property::PropertyIdentifier* PropertyValue::_internal_mutable_linkval() {
  if (!_internal_has_linkval()) {
    clear_Value();
    set_has_linkval();
    _impl_.Value_.linkval_ = CreateMaybeMessage< ::Property::PropertyIdentifier >(GetArenaForAllocation());
  }
  return _impl_.Value_.linkval_;
}
inline ::Property::PropertyIdentifier* PropertyValue::mutable_linkval() {
  ::Property::PropertyIdentifier* _msg = _internal_mutable_linkval();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValue.linkVal)
  return _msg;
}

inline bool PropertyValue::has_Value() const {
  return Value_case() != VALUE_NOT_SET;
}
inline void PropertyValue::clear_has_Value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline PropertyValue::ValueCase PropertyValue::Value_case() const {
  return PropertyValue::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DefinePropertyDefaultValue

// .ServerData.CavrnusSpaceConnection SpaceConn = 1;
inline bool DefinePropertyDefaultValue::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool DefinePropertyDefaultValue::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& DefinePropertyDefaultValue::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& DefinePropertyDefaultValue::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.DefinePropertyDefaultValue.SpaceConn)
  return _internal_spaceconn();
}
inline void DefinePropertyDefaultValue::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.DefinePropertyDefaultValue.SpaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* DefinePropertyDefaultValue::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* DefinePropertyDefaultValue::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.DefinePropertyDefaultValue.SpaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* DefinePropertyDefaultValue::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* DefinePropertyDefaultValue::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.DefinePropertyDefaultValue.SpaceConn)
  return _msg;
}
inline void DefinePropertyDefaultValue::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.DefinePropertyDefaultValue.SpaceConn)
}

// string PropertyId = 2;
inline void DefinePropertyDefaultValue::clear_propertyid() {
  _impl_.propertyid_.ClearToEmpty();
}
inline const std::string& DefinePropertyDefaultValue::propertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.DefinePropertyDefaultValue.PropertyId)
  return _internal_propertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefinePropertyDefaultValue::set_propertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.propertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.DefinePropertyDefaultValue.PropertyId)
}
inline std::string* DefinePropertyDefaultValue::mutable_propertyid() {
  std::string* _s = _internal_mutable_propertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.DefinePropertyDefaultValue.PropertyId)
  return _s;
}
inline const std::string& DefinePropertyDefaultValue::_internal_propertyid() const {
  return _impl_.propertyid_.Get();
}
inline void DefinePropertyDefaultValue::_internal_set_propertyid(const std::string& value) {
  
  _impl_.propertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* DefinePropertyDefaultValue::_internal_mutable_propertyid() {
  
  return _impl_.propertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* DefinePropertyDefaultValue::release_propertyid() {
  // @@protoc_insertion_point(field_release:ServerData.DefinePropertyDefaultValue.PropertyId)
  return _impl_.propertyid_.Release();
}
inline void DefinePropertyDefaultValue::set_allocated_propertyid(std::string* propertyid) {
  if (propertyid != nullptr) {
    
  } else {
    
  }
  _impl_.propertyid_.SetAllocated(propertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propertyid_.IsDefault()) {
    _impl_.propertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.DefinePropertyDefaultValue.PropertyId)
}

// int32 localChangeId = 3;
inline void DefinePropertyDefaultValue::clear_localchangeid() {
  _impl_.localchangeid_ = 0;
}
inline int32_t DefinePropertyDefaultValue::_internal_localchangeid() const {
  return _impl_.localchangeid_;
}
inline int32_t DefinePropertyDefaultValue::localchangeid() const {
  // @@protoc_insertion_point(field_get:ServerData.DefinePropertyDefaultValue.localChangeId)
  return _internal_localchangeid();
}
inline void DefinePropertyDefaultValue::_internal_set_localchangeid(int32_t value) {
  
  _impl_.localchangeid_ = value;
}
inline void DefinePropertyDefaultValue::set_localchangeid(int32_t value) {
  _internal_set_localchangeid(value);
  // @@protoc_insertion_point(field_set:ServerData.DefinePropertyDefaultValue.localChangeId)
}

// .ServerData.PropertyValue PropertyValue = 10;
inline bool DefinePropertyDefaultValue::_internal_has_propertyvalue() const {
  return this != internal_default_instance() && _impl_.propertyvalue_ != nullptr;
}
inline bool DefinePropertyDefaultValue::has_propertyvalue() const {
  return _internal_has_propertyvalue();
}
inline void DefinePropertyDefaultValue::clear_propertyvalue() {
  if (GetArenaForAllocation() == nullptr && _impl_.propertyvalue_ != nullptr) {
    delete _impl_.propertyvalue_;
  }
  _impl_.propertyvalue_ = nullptr;
}
inline const ::ServerData::PropertyValue& DefinePropertyDefaultValue::_internal_propertyvalue() const {
  const ::ServerData::PropertyValue* p = _impl_.propertyvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::PropertyValue&>(
      ::ServerData::_PropertyValue_default_instance_);
}
inline const ::ServerData::PropertyValue& DefinePropertyDefaultValue::propertyvalue() const {
  // @@protoc_insertion_point(field_get:ServerData.DefinePropertyDefaultValue.PropertyValue)
  return _internal_propertyvalue();
}
inline void DefinePropertyDefaultValue::unsafe_arena_set_allocated_propertyvalue(
    ::ServerData::PropertyValue* propertyvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertyvalue_);
  }
  _impl_.propertyvalue_ = propertyvalue;
  if (propertyvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.DefinePropertyDefaultValue.PropertyValue)
}
inline ::ServerData::PropertyValue* DefinePropertyDefaultValue::release_propertyvalue() {
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::PropertyValue* DefinePropertyDefaultValue::unsafe_arena_release_propertyvalue() {
  // @@protoc_insertion_point(field_release:ServerData.DefinePropertyDefaultValue.PropertyValue)
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
  return temp;
}
inline ::ServerData::PropertyValue* DefinePropertyDefaultValue::_internal_mutable_propertyvalue() {
  
  if (_impl_.propertyvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::PropertyValue>(GetArenaForAllocation());
    _impl_.propertyvalue_ = p;
  }
  return _impl_.propertyvalue_;
}
inline ::ServerData::PropertyValue* DefinePropertyDefaultValue::mutable_propertyvalue() {
  ::ServerData::PropertyValue* _msg = _internal_mutable_propertyvalue();
  // @@protoc_insertion_point(field_mutable:ServerData.DefinePropertyDefaultValue.PropertyValue)
  return _msg;
}
inline void DefinePropertyDefaultValue::set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.propertyvalue_;
  }
  if (propertyvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(propertyvalue);
    if (message_arena != submessage_arena) {
      propertyvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertyvalue, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertyvalue_ = propertyvalue;
  // @@protoc_insertion_point(field_set_allocated:ServerData.DefinePropertyDefaultValue.PropertyValue)
}

// -------------------------------------------------------------------

// PostPropertyUpdate

// .ServerData.CavrnusSpaceConnection SpaceConn = 1;
inline bool PostPropertyUpdate::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool PostPropertyUpdate::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PostPropertyUpdate::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PostPropertyUpdate::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PostPropertyUpdate.SpaceConn)
  return _internal_spaceconn();
}
inline void PostPropertyUpdate::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PostPropertyUpdate.SpaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PostPropertyUpdate::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostPropertyUpdate::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PostPropertyUpdate.SpaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostPropertyUpdate::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PostPropertyUpdate::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PostPropertyUpdate.SpaceConn)
  return _msg;
}
inline void PostPropertyUpdate::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostPropertyUpdate.SpaceConn)
}

// string PropertyId = 3;
inline void PostPropertyUpdate::clear_propertyid() {
  _impl_.propertyid_.ClearToEmpty();
}
inline const std::string& PostPropertyUpdate::propertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.PostPropertyUpdate.PropertyId)
  return _internal_propertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostPropertyUpdate::set_propertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.propertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PostPropertyUpdate.PropertyId)
}
inline std::string* PostPropertyUpdate::mutable_propertyid() {
  std::string* _s = _internal_mutable_propertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.PostPropertyUpdate.PropertyId)
  return _s;
}
inline const std::string& PostPropertyUpdate::_internal_propertyid() const {
  return _impl_.propertyid_.Get();
}
inline void PostPropertyUpdate::_internal_set_propertyid(const std::string& value) {
  
  _impl_.propertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* PostPropertyUpdate::_internal_mutable_propertyid() {
  
  return _impl_.propertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* PostPropertyUpdate::release_propertyid() {
  // @@protoc_insertion_point(field_release:ServerData.PostPropertyUpdate.PropertyId)
  return _impl_.propertyid_.Release();
}
inline void PostPropertyUpdate::set_allocated_propertyid(std::string* propertyid) {
  if (propertyid != nullptr) {
    
  } else {
    
  }
  _impl_.propertyid_.SetAllocated(propertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propertyid_.IsDefault()) {
    _impl_.propertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostPropertyUpdate.PropertyId)
}

// int32 localChangeId = 4;
inline void PostPropertyUpdate::clear_localchangeid() {
  _impl_.localchangeid_ = 0;
}
inline int32_t PostPropertyUpdate::_internal_localchangeid() const {
  return _impl_.localchangeid_;
}
inline int32_t PostPropertyUpdate::localchangeid() const {
  // @@protoc_insertion_point(field_get:ServerData.PostPropertyUpdate.localChangeId)
  return _internal_localchangeid();
}
inline void PostPropertyUpdate::_internal_set_localchangeid(int32_t value) {
  
  _impl_.localchangeid_ = value;
}
inline void PostPropertyUpdate::set_localchangeid(int32_t value) {
  _internal_set_localchangeid(value);
  // @@protoc_insertion_point(field_set:ServerData.PostPropertyUpdate.localChangeId)
}

// .ServerData.PropertyValue PropertyValue = 10;
inline bool PostPropertyUpdate::_internal_has_propertyvalue() const {
  return this != internal_default_instance() && _impl_.propertyvalue_ != nullptr;
}
inline bool PostPropertyUpdate::has_propertyvalue() const {
  return _internal_has_propertyvalue();
}
inline void PostPropertyUpdate::clear_propertyvalue() {
  if (GetArenaForAllocation() == nullptr && _impl_.propertyvalue_ != nullptr) {
    delete _impl_.propertyvalue_;
  }
  _impl_.propertyvalue_ = nullptr;
}
inline const ::ServerData::PropertyValue& PostPropertyUpdate::_internal_propertyvalue() const {
  const ::ServerData::PropertyValue* p = _impl_.propertyvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::PropertyValue&>(
      ::ServerData::_PropertyValue_default_instance_);
}
inline const ::ServerData::PropertyValue& PostPropertyUpdate::propertyvalue() const {
  // @@protoc_insertion_point(field_get:ServerData.PostPropertyUpdate.PropertyValue)
  return _internal_propertyvalue();
}
inline void PostPropertyUpdate::unsafe_arena_set_allocated_propertyvalue(
    ::ServerData::PropertyValue* propertyvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertyvalue_);
  }
  _impl_.propertyvalue_ = propertyvalue;
  if (propertyvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PostPropertyUpdate.PropertyValue)
}
inline ::ServerData::PropertyValue* PostPropertyUpdate::release_propertyvalue() {
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::PropertyValue* PostPropertyUpdate::unsafe_arena_release_propertyvalue() {
  // @@protoc_insertion_point(field_release:ServerData.PostPropertyUpdate.PropertyValue)
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
  return temp;
}
inline ::ServerData::PropertyValue* PostPropertyUpdate::_internal_mutable_propertyvalue() {
  
  if (_impl_.propertyvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::PropertyValue>(GetArenaForAllocation());
    _impl_.propertyvalue_ = p;
  }
  return _impl_.propertyvalue_;
}
inline ::ServerData::PropertyValue* PostPropertyUpdate::mutable_propertyvalue() {
  ::ServerData::PropertyValue* _msg = _internal_mutable_propertyvalue();
  // @@protoc_insertion_point(field_mutable:ServerData.PostPropertyUpdate.PropertyValue)
  return _msg;
}
inline void PostPropertyUpdate::set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.propertyvalue_;
  }
  if (propertyvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(propertyvalue);
    if (message_arena != submessage_arena) {
      propertyvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertyvalue, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertyvalue_ = propertyvalue;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostPropertyUpdate.PropertyValue)
}

// bool smooth = 20;
inline void PostPropertyUpdate::clear_smooth() {
  _impl_.smooth_ = false;
}
inline bool PostPropertyUpdate::_internal_smooth() const {
  return _impl_.smooth_;
}
inline bool PostPropertyUpdate::smooth() const {
  // @@protoc_insertion_point(field_get:ServerData.PostPropertyUpdate.smooth)
  return _internal_smooth();
}
inline void PostPropertyUpdate::_internal_set_smooth(bool value) {
  
  _impl_.smooth_ = value;
}
inline void PostPropertyUpdate::set_smooth(bool value) {
  _internal_set_smooth(value);
  // @@protoc_insertion_point(field_set:ServerData.PostPropertyUpdate.smooth)
}

// -------------------------------------------------------------------

// BeginTransientPropertyUpdate

// .ServerData.CavrnusSpaceConnection SpaceConn = 1;
inline bool BeginTransientPropertyUpdate::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool BeginTransientPropertyUpdate::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& BeginTransientPropertyUpdate::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& BeginTransientPropertyUpdate::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.BeginTransientPropertyUpdate.SpaceConn)
  return _internal_spaceconn();
}
inline void BeginTransientPropertyUpdate::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.BeginTransientPropertyUpdate.SpaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* BeginTransientPropertyUpdate::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* BeginTransientPropertyUpdate::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.BeginTransientPropertyUpdate.SpaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* BeginTransientPropertyUpdate::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* BeginTransientPropertyUpdate::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.BeginTransientPropertyUpdate.SpaceConn)
  return _msg;
}
inline void BeginTransientPropertyUpdate::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.BeginTransientPropertyUpdate.SpaceConn)
}

// string LiveUpdaterId = 2;
inline void BeginTransientPropertyUpdate::clear_liveupdaterid() {
  _impl_.liveupdaterid_.ClearToEmpty();
}
inline const std::string& BeginTransientPropertyUpdate::liveupdaterid() const {
  // @@protoc_insertion_point(field_get:ServerData.BeginTransientPropertyUpdate.LiveUpdaterId)
  return _internal_liveupdaterid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BeginTransientPropertyUpdate::set_liveupdaterid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.liveupdaterid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.BeginTransientPropertyUpdate.LiveUpdaterId)
}
inline std::string* BeginTransientPropertyUpdate::mutable_liveupdaterid() {
  std::string* _s = _internal_mutable_liveupdaterid();
  // @@protoc_insertion_point(field_mutable:ServerData.BeginTransientPropertyUpdate.LiveUpdaterId)
  return _s;
}
inline const std::string& BeginTransientPropertyUpdate::_internal_liveupdaterid() const {
  return _impl_.liveupdaterid_.Get();
}
inline void BeginTransientPropertyUpdate::_internal_set_liveupdaterid(const std::string& value) {
  
  _impl_.liveupdaterid_.Set(value, GetArenaForAllocation());
}
inline std::string* BeginTransientPropertyUpdate::_internal_mutable_liveupdaterid() {
  
  return _impl_.liveupdaterid_.Mutable(GetArenaForAllocation());
}
inline std::string* BeginTransientPropertyUpdate::release_liveupdaterid() {
  // @@protoc_insertion_point(field_release:ServerData.BeginTransientPropertyUpdate.LiveUpdaterId)
  return _impl_.liveupdaterid_.Release();
}
inline void BeginTransientPropertyUpdate::set_allocated_liveupdaterid(std::string* liveupdaterid) {
  if (liveupdaterid != nullptr) {
    
  } else {
    
  }
  _impl_.liveupdaterid_.SetAllocated(liveupdaterid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.liveupdaterid_.IsDefault()) {
    _impl_.liveupdaterid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.BeginTransientPropertyUpdate.LiveUpdaterId)
}

// string PropertyId = 3;
inline void BeginTransientPropertyUpdate::clear_propertyid() {
  _impl_.propertyid_.ClearToEmpty();
}
inline const std::string& BeginTransientPropertyUpdate::propertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.BeginTransientPropertyUpdate.PropertyId)
  return _internal_propertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BeginTransientPropertyUpdate::set_propertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.propertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.BeginTransientPropertyUpdate.PropertyId)
}
inline std::string* BeginTransientPropertyUpdate::mutable_propertyid() {
  std::string* _s = _internal_mutable_propertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.BeginTransientPropertyUpdate.PropertyId)
  return _s;
}
inline const std::string& BeginTransientPropertyUpdate::_internal_propertyid() const {
  return _impl_.propertyid_.Get();
}
inline void BeginTransientPropertyUpdate::_internal_set_propertyid(const std::string& value) {
  
  _impl_.propertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* BeginTransientPropertyUpdate::_internal_mutable_propertyid() {
  
  return _impl_.propertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* BeginTransientPropertyUpdate::release_propertyid() {
  // @@protoc_insertion_point(field_release:ServerData.BeginTransientPropertyUpdate.PropertyId)
  return _impl_.propertyid_.Release();
}
inline void BeginTransientPropertyUpdate::set_allocated_propertyid(std::string* propertyid) {
  if (propertyid != nullptr) {
    
  } else {
    
  }
  _impl_.propertyid_.SetAllocated(propertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propertyid_.IsDefault()) {
    _impl_.propertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.BeginTransientPropertyUpdate.PropertyId)
}

// int32 localChangeId = 4;
inline void BeginTransientPropertyUpdate::clear_localchangeid() {
  _impl_.localchangeid_ = 0;
}
inline int32_t BeginTransientPropertyUpdate::_internal_localchangeid() const {
  return _impl_.localchangeid_;
}
inline int32_t BeginTransientPropertyUpdate::localchangeid() const {
  // @@protoc_insertion_point(field_get:ServerData.BeginTransientPropertyUpdate.localChangeId)
  return _internal_localchangeid();
}
inline void BeginTransientPropertyUpdate::_internal_set_localchangeid(int32_t value) {
  
  _impl_.localchangeid_ = value;
}
inline void BeginTransientPropertyUpdate::set_localchangeid(int32_t value) {
  _internal_set_localchangeid(value);
  // @@protoc_insertion_point(field_set:ServerData.BeginTransientPropertyUpdate.localChangeId)
}

// .ServerData.PropertyValue PropertyValue = 10;
inline bool BeginTransientPropertyUpdate::_internal_has_propertyvalue() const {
  return this != internal_default_instance() && _impl_.propertyvalue_ != nullptr;
}
inline bool BeginTransientPropertyUpdate::has_propertyvalue() const {
  return _internal_has_propertyvalue();
}
inline void BeginTransientPropertyUpdate::clear_propertyvalue() {
  if (GetArenaForAllocation() == nullptr && _impl_.propertyvalue_ != nullptr) {
    delete _impl_.propertyvalue_;
  }
  _impl_.propertyvalue_ = nullptr;
}
inline const ::ServerData::PropertyValue& BeginTransientPropertyUpdate::_internal_propertyvalue() const {
  const ::ServerData::PropertyValue* p = _impl_.propertyvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::PropertyValue&>(
      ::ServerData::_PropertyValue_default_instance_);
}
inline const ::ServerData::PropertyValue& BeginTransientPropertyUpdate::propertyvalue() const {
  // @@protoc_insertion_point(field_get:ServerData.BeginTransientPropertyUpdate.PropertyValue)
  return _internal_propertyvalue();
}
inline void BeginTransientPropertyUpdate::unsafe_arena_set_allocated_propertyvalue(
    ::ServerData::PropertyValue* propertyvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertyvalue_);
  }
  _impl_.propertyvalue_ = propertyvalue;
  if (propertyvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.BeginTransientPropertyUpdate.PropertyValue)
}
inline ::ServerData::PropertyValue* BeginTransientPropertyUpdate::release_propertyvalue() {
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::PropertyValue* BeginTransientPropertyUpdate::unsafe_arena_release_propertyvalue() {
  // @@protoc_insertion_point(field_release:ServerData.BeginTransientPropertyUpdate.PropertyValue)
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
  return temp;
}
inline ::ServerData::PropertyValue* BeginTransientPropertyUpdate::_internal_mutable_propertyvalue() {
  
  if (_impl_.propertyvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::PropertyValue>(GetArenaForAllocation());
    _impl_.propertyvalue_ = p;
  }
  return _impl_.propertyvalue_;
}
inline ::ServerData::PropertyValue* BeginTransientPropertyUpdate::mutable_propertyvalue() {
  ::ServerData::PropertyValue* _msg = _internal_mutable_propertyvalue();
  // @@protoc_insertion_point(field_mutable:ServerData.BeginTransientPropertyUpdate.PropertyValue)
  return _msg;
}
inline void BeginTransientPropertyUpdate::set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.propertyvalue_;
  }
  if (propertyvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(propertyvalue);
    if (message_arena != submessage_arena) {
      propertyvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertyvalue, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertyvalue_ = propertyvalue;
  // @@protoc_insertion_point(field_set_allocated:ServerData.BeginTransientPropertyUpdate.PropertyValue)
}

// bool smooth = 20;
inline void BeginTransientPropertyUpdate::clear_smooth() {
  _impl_.smooth_ = false;
}
inline bool BeginTransientPropertyUpdate::_internal_smooth() const {
  return _impl_.smooth_;
}
inline bool BeginTransientPropertyUpdate::smooth() const {
  // @@protoc_insertion_point(field_get:ServerData.BeginTransientPropertyUpdate.smooth)
  return _internal_smooth();
}
inline void BeginTransientPropertyUpdate::_internal_set_smooth(bool value) {
  
  _impl_.smooth_ = value;
}
inline void BeginTransientPropertyUpdate::set_smooth(bool value) {
  _internal_set_smooth(value);
  // @@protoc_insertion_point(field_set:ServerData.BeginTransientPropertyUpdate.smooth)
}

// -------------------------------------------------------------------

// ContinueTransientPropertyUpdate

// .ServerData.CavrnusSpaceConnection SpaceConn = 1;
inline bool ContinueTransientPropertyUpdate::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool ContinueTransientPropertyUpdate::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& ContinueTransientPropertyUpdate::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ContinueTransientPropertyUpdate::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.ContinueTransientPropertyUpdate.SpaceConn)
  return _internal_spaceconn();
}
inline void ContinueTransientPropertyUpdate::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ContinueTransientPropertyUpdate.SpaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* ContinueTransientPropertyUpdate::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ContinueTransientPropertyUpdate::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.ContinueTransientPropertyUpdate.SpaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ContinueTransientPropertyUpdate::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* ContinueTransientPropertyUpdate::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.ContinueTransientPropertyUpdate.SpaceConn)
  return _msg;
}
inline void ContinueTransientPropertyUpdate::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ContinueTransientPropertyUpdate.SpaceConn)
}

// string LiveUpdaterId = 2;
inline void ContinueTransientPropertyUpdate::clear_liveupdaterid() {
  _impl_.liveupdaterid_.ClearToEmpty();
}
inline const std::string& ContinueTransientPropertyUpdate::liveupdaterid() const {
  // @@protoc_insertion_point(field_get:ServerData.ContinueTransientPropertyUpdate.LiveUpdaterId)
  return _internal_liveupdaterid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContinueTransientPropertyUpdate::set_liveupdaterid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.liveupdaterid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ContinueTransientPropertyUpdate.LiveUpdaterId)
}
inline std::string* ContinueTransientPropertyUpdate::mutable_liveupdaterid() {
  std::string* _s = _internal_mutable_liveupdaterid();
  // @@protoc_insertion_point(field_mutable:ServerData.ContinueTransientPropertyUpdate.LiveUpdaterId)
  return _s;
}
inline const std::string& ContinueTransientPropertyUpdate::_internal_liveupdaterid() const {
  return _impl_.liveupdaterid_.Get();
}
inline void ContinueTransientPropertyUpdate::_internal_set_liveupdaterid(const std::string& value) {
  
  _impl_.liveupdaterid_.Set(value, GetArenaForAllocation());
}
inline std::string* ContinueTransientPropertyUpdate::_internal_mutable_liveupdaterid() {
  
  return _impl_.liveupdaterid_.Mutable(GetArenaForAllocation());
}
inline std::string* ContinueTransientPropertyUpdate::release_liveupdaterid() {
  // @@protoc_insertion_point(field_release:ServerData.ContinueTransientPropertyUpdate.LiveUpdaterId)
  return _impl_.liveupdaterid_.Release();
}
inline void ContinueTransientPropertyUpdate::set_allocated_liveupdaterid(std::string* liveupdaterid) {
  if (liveupdaterid != nullptr) {
    
  } else {
    
  }
  _impl_.liveupdaterid_.SetAllocated(liveupdaterid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.liveupdaterid_.IsDefault()) {
    _impl_.liveupdaterid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ContinueTransientPropertyUpdate.LiveUpdaterId)
}

// string PropertyId = 3;
inline void ContinueTransientPropertyUpdate::clear_propertyid() {
  _impl_.propertyid_.ClearToEmpty();
}
inline const std::string& ContinueTransientPropertyUpdate::propertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.ContinueTransientPropertyUpdate.PropertyId)
  return _internal_propertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContinueTransientPropertyUpdate::set_propertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.propertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ContinueTransientPropertyUpdate.PropertyId)
}
inline std::string* ContinueTransientPropertyUpdate::mutable_propertyid() {
  std::string* _s = _internal_mutable_propertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.ContinueTransientPropertyUpdate.PropertyId)
  return _s;
}
inline const std::string& ContinueTransientPropertyUpdate::_internal_propertyid() const {
  return _impl_.propertyid_.Get();
}
inline void ContinueTransientPropertyUpdate::_internal_set_propertyid(const std::string& value) {
  
  _impl_.propertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* ContinueTransientPropertyUpdate::_internal_mutable_propertyid() {
  
  return _impl_.propertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* ContinueTransientPropertyUpdate::release_propertyid() {
  // @@protoc_insertion_point(field_release:ServerData.ContinueTransientPropertyUpdate.PropertyId)
  return _impl_.propertyid_.Release();
}
inline void ContinueTransientPropertyUpdate::set_allocated_propertyid(std::string* propertyid) {
  if (propertyid != nullptr) {
    
  } else {
    
  }
  _impl_.propertyid_.SetAllocated(propertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propertyid_.IsDefault()) {
    _impl_.propertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ContinueTransientPropertyUpdate.PropertyId)
}

// int32 localChangeId = 4;
inline void ContinueTransientPropertyUpdate::clear_localchangeid() {
  _impl_.localchangeid_ = 0;
}
inline int32_t ContinueTransientPropertyUpdate::_internal_localchangeid() const {
  return _impl_.localchangeid_;
}
inline int32_t ContinueTransientPropertyUpdate::localchangeid() const {
  // @@protoc_insertion_point(field_get:ServerData.ContinueTransientPropertyUpdate.localChangeId)
  return _internal_localchangeid();
}
inline void ContinueTransientPropertyUpdate::_internal_set_localchangeid(int32_t value) {
  
  _impl_.localchangeid_ = value;
}
inline void ContinueTransientPropertyUpdate::set_localchangeid(int32_t value) {
  _internal_set_localchangeid(value);
  // @@protoc_insertion_point(field_set:ServerData.ContinueTransientPropertyUpdate.localChangeId)
}

// .ServerData.PropertyValue PropertyValue = 10;
inline bool ContinueTransientPropertyUpdate::_internal_has_propertyvalue() const {
  return this != internal_default_instance() && _impl_.propertyvalue_ != nullptr;
}
inline bool ContinueTransientPropertyUpdate::has_propertyvalue() const {
  return _internal_has_propertyvalue();
}
inline void ContinueTransientPropertyUpdate::clear_propertyvalue() {
  if (GetArenaForAllocation() == nullptr && _impl_.propertyvalue_ != nullptr) {
    delete _impl_.propertyvalue_;
  }
  _impl_.propertyvalue_ = nullptr;
}
inline const ::ServerData::PropertyValue& ContinueTransientPropertyUpdate::_internal_propertyvalue() const {
  const ::ServerData::PropertyValue* p = _impl_.propertyvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::PropertyValue&>(
      ::ServerData::_PropertyValue_default_instance_);
}
inline const ::ServerData::PropertyValue& ContinueTransientPropertyUpdate::propertyvalue() const {
  // @@protoc_insertion_point(field_get:ServerData.ContinueTransientPropertyUpdate.PropertyValue)
  return _internal_propertyvalue();
}
inline void ContinueTransientPropertyUpdate::unsafe_arena_set_allocated_propertyvalue(
    ::ServerData::PropertyValue* propertyvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertyvalue_);
  }
  _impl_.propertyvalue_ = propertyvalue;
  if (propertyvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ContinueTransientPropertyUpdate.PropertyValue)
}
inline ::ServerData::PropertyValue* ContinueTransientPropertyUpdate::release_propertyvalue() {
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::PropertyValue* ContinueTransientPropertyUpdate::unsafe_arena_release_propertyvalue() {
  // @@protoc_insertion_point(field_release:ServerData.ContinueTransientPropertyUpdate.PropertyValue)
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
  return temp;
}
inline ::ServerData::PropertyValue* ContinueTransientPropertyUpdate::_internal_mutable_propertyvalue() {
  
  if (_impl_.propertyvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::PropertyValue>(GetArenaForAllocation());
    _impl_.propertyvalue_ = p;
  }
  return _impl_.propertyvalue_;
}
inline ::ServerData::PropertyValue* ContinueTransientPropertyUpdate::mutable_propertyvalue() {
  ::ServerData::PropertyValue* _msg = _internal_mutable_propertyvalue();
  // @@protoc_insertion_point(field_mutable:ServerData.ContinueTransientPropertyUpdate.PropertyValue)
  return _msg;
}
inline void ContinueTransientPropertyUpdate::set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.propertyvalue_;
  }
  if (propertyvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(propertyvalue);
    if (message_arena != submessage_arena) {
      propertyvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertyvalue, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertyvalue_ = propertyvalue;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ContinueTransientPropertyUpdate.PropertyValue)
}

// bool smooth = 20;
inline void ContinueTransientPropertyUpdate::clear_smooth() {
  _impl_.smooth_ = false;
}
inline bool ContinueTransientPropertyUpdate::_internal_smooth() const {
  return _impl_.smooth_;
}
inline bool ContinueTransientPropertyUpdate::smooth() const {
  // @@protoc_insertion_point(field_get:ServerData.ContinueTransientPropertyUpdate.smooth)
  return _internal_smooth();
}
inline void ContinueTransientPropertyUpdate::_internal_set_smooth(bool value) {
  
  _impl_.smooth_ = value;
}
inline void ContinueTransientPropertyUpdate::set_smooth(bool value) {
  _internal_set_smooth(value);
  // @@protoc_insertion_point(field_set:ServerData.ContinueTransientPropertyUpdate.smooth)
}

// -------------------------------------------------------------------

// FinalizeTransientPropertyUpdate

// .ServerData.CavrnusSpaceConnection SpaceConn = 1;
inline bool FinalizeTransientPropertyUpdate::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool FinalizeTransientPropertyUpdate::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& FinalizeTransientPropertyUpdate::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& FinalizeTransientPropertyUpdate::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.FinalizeTransientPropertyUpdate.SpaceConn)
  return _internal_spaceconn();
}
inline void FinalizeTransientPropertyUpdate::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.FinalizeTransientPropertyUpdate.SpaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* FinalizeTransientPropertyUpdate::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* FinalizeTransientPropertyUpdate::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.FinalizeTransientPropertyUpdate.SpaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* FinalizeTransientPropertyUpdate::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* FinalizeTransientPropertyUpdate::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.FinalizeTransientPropertyUpdate.SpaceConn)
  return _msg;
}
inline void FinalizeTransientPropertyUpdate::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.FinalizeTransientPropertyUpdate.SpaceConn)
}

// string LiveUpdaterId = 2;
inline void FinalizeTransientPropertyUpdate::clear_liveupdaterid() {
  _impl_.liveupdaterid_.ClearToEmpty();
}
inline const std::string& FinalizeTransientPropertyUpdate::liveupdaterid() const {
  // @@protoc_insertion_point(field_get:ServerData.FinalizeTransientPropertyUpdate.LiveUpdaterId)
  return _internal_liveupdaterid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FinalizeTransientPropertyUpdate::set_liveupdaterid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.liveupdaterid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FinalizeTransientPropertyUpdate.LiveUpdaterId)
}
inline std::string* FinalizeTransientPropertyUpdate::mutable_liveupdaterid() {
  std::string* _s = _internal_mutable_liveupdaterid();
  // @@protoc_insertion_point(field_mutable:ServerData.FinalizeTransientPropertyUpdate.LiveUpdaterId)
  return _s;
}
inline const std::string& FinalizeTransientPropertyUpdate::_internal_liveupdaterid() const {
  return _impl_.liveupdaterid_.Get();
}
inline void FinalizeTransientPropertyUpdate::_internal_set_liveupdaterid(const std::string& value) {
  
  _impl_.liveupdaterid_.Set(value, GetArenaForAllocation());
}
inline std::string* FinalizeTransientPropertyUpdate::_internal_mutable_liveupdaterid() {
  
  return _impl_.liveupdaterid_.Mutable(GetArenaForAllocation());
}
inline std::string* FinalizeTransientPropertyUpdate::release_liveupdaterid() {
  // @@protoc_insertion_point(field_release:ServerData.FinalizeTransientPropertyUpdate.LiveUpdaterId)
  return _impl_.liveupdaterid_.Release();
}
inline void FinalizeTransientPropertyUpdate::set_allocated_liveupdaterid(std::string* liveupdaterid) {
  if (liveupdaterid != nullptr) {
    
  } else {
    
  }
  _impl_.liveupdaterid_.SetAllocated(liveupdaterid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.liveupdaterid_.IsDefault()) {
    _impl_.liveupdaterid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FinalizeTransientPropertyUpdate.LiveUpdaterId)
}

// string PropertyId = 3;
inline void FinalizeTransientPropertyUpdate::clear_propertyid() {
  _impl_.propertyid_.ClearToEmpty();
}
inline const std::string& FinalizeTransientPropertyUpdate::propertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.FinalizeTransientPropertyUpdate.PropertyId)
  return _internal_propertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FinalizeTransientPropertyUpdate::set_propertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.propertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FinalizeTransientPropertyUpdate.PropertyId)
}
inline std::string* FinalizeTransientPropertyUpdate::mutable_propertyid() {
  std::string* _s = _internal_mutable_propertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.FinalizeTransientPropertyUpdate.PropertyId)
  return _s;
}
inline const std::string& FinalizeTransientPropertyUpdate::_internal_propertyid() const {
  return _impl_.propertyid_.Get();
}
inline void FinalizeTransientPropertyUpdate::_internal_set_propertyid(const std::string& value) {
  
  _impl_.propertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* FinalizeTransientPropertyUpdate::_internal_mutable_propertyid() {
  
  return _impl_.propertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* FinalizeTransientPropertyUpdate::release_propertyid() {
  // @@protoc_insertion_point(field_release:ServerData.FinalizeTransientPropertyUpdate.PropertyId)
  return _impl_.propertyid_.Release();
}
inline void FinalizeTransientPropertyUpdate::set_allocated_propertyid(std::string* propertyid) {
  if (propertyid != nullptr) {
    
  } else {
    
  }
  _impl_.propertyid_.SetAllocated(propertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propertyid_.IsDefault()) {
    _impl_.propertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FinalizeTransientPropertyUpdate.PropertyId)
}

// int32 localChangeId = 4;
inline void FinalizeTransientPropertyUpdate::clear_localchangeid() {
  _impl_.localchangeid_ = 0;
}
inline int32_t FinalizeTransientPropertyUpdate::_internal_localchangeid() const {
  return _impl_.localchangeid_;
}
inline int32_t FinalizeTransientPropertyUpdate::localchangeid() const {
  // @@protoc_insertion_point(field_get:ServerData.FinalizeTransientPropertyUpdate.localChangeId)
  return _internal_localchangeid();
}
inline void FinalizeTransientPropertyUpdate::_internal_set_localchangeid(int32_t value) {
  
  _impl_.localchangeid_ = value;
}
inline void FinalizeTransientPropertyUpdate::set_localchangeid(int32_t value) {
  _internal_set_localchangeid(value);
  // @@protoc_insertion_point(field_set:ServerData.FinalizeTransientPropertyUpdate.localChangeId)
}

// .ServerData.PropertyValue PropertyValue = 10;
inline bool FinalizeTransientPropertyUpdate::_internal_has_propertyvalue() const {
  return this != internal_default_instance() && _impl_.propertyvalue_ != nullptr;
}
inline bool FinalizeTransientPropertyUpdate::has_propertyvalue() const {
  return _internal_has_propertyvalue();
}
inline void FinalizeTransientPropertyUpdate::clear_propertyvalue() {
  if (GetArenaForAllocation() == nullptr && _impl_.propertyvalue_ != nullptr) {
    delete _impl_.propertyvalue_;
  }
  _impl_.propertyvalue_ = nullptr;
}
inline const ::ServerData::PropertyValue& FinalizeTransientPropertyUpdate::_internal_propertyvalue() const {
  const ::ServerData::PropertyValue* p = _impl_.propertyvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::PropertyValue&>(
      ::ServerData::_PropertyValue_default_instance_);
}
inline const ::ServerData::PropertyValue& FinalizeTransientPropertyUpdate::propertyvalue() const {
  // @@protoc_insertion_point(field_get:ServerData.FinalizeTransientPropertyUpdate.PropertyValue)
  return _internal_propertyvalue();
}
inline void FinalizeTransientPropertyUpdate::unsafe_arena_set_allocated_propertyvalue(
    ::ServerData::PropertyValue* propertyvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertyvalue_);
  }
  _impl_.propertyvalue_ = propertyvalue;
  if (propertyvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.FinalizeTransientPropertyUpdate.PropertyValue)
}
inline ::ServerData::PropertyValue* FinalizeTransientPropertyUpdate::release_propertyvalue() {
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::PropertyValue* FinalizeTransientPropertyUpdate::unsafe_arena_release_propertyvalue() {
  // @@protoc_insertion_point(field_release:ServerData.FinalizeTransientPropertyUpdate.PropertyValue)
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
  return temp;
}
inline ::ServerData::PropertyValue* FinalizeTransientPropertyUpdate::_internal_mutable_propertyvalue() {
  
  if (_impl_.propertyvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::PropertyValue>(GetArenaForAllocation());
    _impl_.propertyvalue_ = p;
  }
  return _impl_.propertyvalue_;
}
inline ::ServerData::PropertyValue* FinalizeTransientPropertyUpdate::mutable_propertyvalue() {
  ::ServerData::PropertyValue* _msg = _internal_mutable_propertyvalue();
  // @@protoc_insertion_point(field_mutable:ServerData.FinalizeTransientPropertyUpdate.PropertyValue)
  return _msg;
}
inline void FinalizeTransientPropertyUpdate::set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.propertyvalue_;
  }
  if (propertyvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(propertyvalue);
    if (message_arena != submessage_arena) {
      propertyvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertyvalue, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertyvalue_ = propertyvalue;
  // @@protoc_insertion_point(field_set_allocated:ServerData.FinalizeTransientPropertyUpdate.PropertyValue)
}

// bool smooth = 20;
inline void FinalizeTransientPropertyUpdate::clear_smooth() {
  _impl_.smooth_ = false;
}
inline bool FinalizeTransientPropertyUpdate::_internal_smooth() const {
  return _impl_.smooth_;
}
inline bool FinalizeTransientPropertyUpdate::smooth() const {
  // @@protoc_insertion_point(field_get:ServerData.FinalizeTransientPropertyUpdate.smooth)
  return _internal_smooth();
}
inline void FinalizeTransientPropertyUpdate::_internal_set_smooth(bool value) {
  
  _impl_.smooth_ = value;
}
inline void FinalizeTransientPropertyUpdate::set_smooth(bool value) {
  _internal_set_smooth(value);
  // @@protoc_insertion_point(field_set:ServerData.FinalizeTransientPropertyUpdate.smooth)
}

// -------------------------------------------------------------------

// CancelTransientPropertyUpdate

// .ServerData.CavrnusSpaceConnection SpaceConn = 1;
inline bool CancelTransientPropertyUpdate::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool CancelTransientPropertyUpdate::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& CancelTransientPropertyUpdate::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& CancelTransientPropertyUpdate::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.CancelTransientPropertyUpdate.SpaceConn)
  return _internal_spaceconn();
}
inline void CancelTransientPropertyUpdate::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.CancelTransientPropertyUpdate.SpaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* CancelTransientPropertyUpdate::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* CancelTransientPropertyUpdate::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.CancelTransientPropertyUpdate.SpaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* CancelTransientPropertyUpdate::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* CancelTransientPropertyUpdate::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.CancelTransientPropertyUpdate.SpaceConn)
  return _msg;
}
inline void CancelTransientPropertyUpdate::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.CancelTransientPropertyUpdate.SpaceConn)
}

// string LiveUpdaterId = 2;
inline void CancelTransientPropertyUpdate::clear_liveupdaterid() {
  _impl_.liveupdaterid_.ClearToEmpty();
}
inline const std::string& CancelTransientPropertyUpdate::liveupdaterid() const {
  // @@protoc_insertion_point(field_get:ServerData.CancelTransientPropertyUpdate.LiveUpdaterId)
  return _internal_liveupdaterid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelTransientPropertyUpdate::set_liveupdaterid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.liveupdaterid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CancelTransientPropertyUpdate.LiveUpdaterId)
}
inline std::string* CancelTransientPropertyUpdate::mutable_liveupdaterid() {
  std::string* _s = _internal_mutable_liveupdaterid();
  // @@protoc_insertion_point(field_mutable:ServerData.CancelTransientPropertyUpdate.LiveUpdaterId)
  return _s;
}
inline const std::string& CancelTransientPropertyUpdate::_internal_liveupdaterid() const {
  return _impl_.liveupdaterid_.Get();
}
inline void CancelTransientPropertyUpdate::_internal_set_liveupdaterid(const std::string& value) {
  
  _impl_.liveupdaterid_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelTransientPropertyUpdate::_internal_mutable_liveupdaterid() {
  
  return _impl_.liveupdaterid_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelTransientPropertyUpdate::release_liveupdaterid() {
  // @@protoc_insertion_point(field_release:ServerData.CancelTransientPropertyUpdate.LiveUpdaterId)
  return _impl_.liveupdaterid_.Release();
}
inline void CancelTransientPropertyUpdate::set_allocated_liveupdaterid(std::string* liveupdaterid) {
  if (liveupdaterid != nullptr) {
    
  } else {
    
  }
  _impl_.liveupdaterid_.SetAllocated(liveupdaterid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.liveupdaterid_.IsDefault()) {
    _impl_.liveupdaterid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CancelTransientPropertyUpdate.LiveUpdaterId)
}

// -------------------------------------------------------------------

// TransformPropertyValue

// .Common.Float3 pos = 1;
inline bool TransformPropertyValue::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool TransformPropertyValue::has_pos() const {
  return _internal_has_pos();
}
inline const ::Common::Float3& TransformPropertyValue::_internal_pos() const {
  const ::Common::Float3* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& TransformPropertyValue::pos() const {
  // @@protoc_insertion_point(field_get:ServerData.TransformPropertyValue.pos)
  return _internal_pos();
}
inline void TransformPropertyValue::unsafe_arena_set_allocated_pos(
    ::Common::Float3* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.TransformPropertyValue.pos)
}
inline ::Common::Float3* TransformPropertyValue::release_pos() {
  
  ::Common::Float3* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* TransformPropertyValue::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:ServerData.TransformPropertyValue.pos)
  
  ::Common::Float3* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::Common::Float3* TransformPropertyValue::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::Common::Float3* TransformPropertyValue::mutable_pos() {
  ::Common::Float3* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:ServerData.TransformPropertyValue.pos)
  return _msg;
}
inline void TransformPropertyValue::set_allocated_pos(::Common::Float3* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos));
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:ServerData.TransformPropertyValue.pos)
}

// .Common.Float3 rot = 2;
inline bool TransformPropertyValue::_internal_has_rot() const {
  return this != internal_default_instance() && _impl_.rot_ != nullptr;
}
inline bool TransformPropertyValue::has_rot() const {
  return _internal_has_rot();
}
inline const ::Common::Float3& TransformPropertyValue::_internal_rot() const {
  const ::Common::Float3* p = _impl_.rot_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& TransformPropertyValue::rot() const {
  // @@protoc_insertion_point(field_get:ServerData.TransformPropertyValue.rot)
  return _internal_rot();
}
inline void TransformPropertyValue::unsafe_arena_set_allocated_rot(
    ::Common::Float3* rot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rot_);
  }
  _impl_.rot_ = rot;
  if (rot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.TransformPropertyValue.rot)
}
inline ::Common::Float3* TransformPropertyValue::release_rot() {
  
  ::Common::Float3* temp = _impl_.rot_;
  _impl_.rot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* TransformPropertyValue::unsafe_arena_release_rot() {
  // @@protoc_insertion_point(field_release:ServerData.TransformPropertyValue.rot)
  
  ::Common::Float3* temp = _impl_.rot_;
  _impl_.rot_ = nullptr;
  return temp;
}
inline ::Common::Float3* TransformPropertyValue::_internal_mutable_rot() {
  
  if (_impl_.rot_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.rot_ = p;
  }
  return _impl_.rot_;
}
inline ::Common::Float3* TransformPropertyValue::mutable_rot() {
  ::Common::Float3* _msg = _internal_mutable_rot();
  // @@protoc_insertion_point(field_mutable:ServerData.TransformPropertyValue.rot)
  return _msg;
}
inline void TransformPropertyValue::set_allocated_rot(::Common::Float3* rot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rot_);
  }
  if (rot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rot));
    if (message_arena != submessage_arena) {
      rot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rot, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rot_ = rot;
  // @@protoc_insertion_point(field_set_allocated:ServerData.TransformPropertyValue.rot)
}

// .Common.Float3 scl = 3;
inline bool TransformPropertyValue::_internal_has_scl() const {
  return this != internal_default_instance() && _impl_.scl_ != nullptr;
}
inline bool TransformPropertyValue::has_scl() const {
  return _internal_has_scl();
}
inline const ::Common::Float3& TransformPropertyValue::_internal_scl() const {
  const ::Common::Float3* p = _impl_.scl_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Float3&>(
      ::Common::_Float3_default_instance_);
}
inline const ::Common::Float3& TransformPropertyValue::scl() const {
  // @@protoc_insertion_point(field_get:ServerData.TransformPropertyValue.scl)
  return _internal_scl();
}
inline void TransformPropertyValue::unsafe_arena_set_allocated_scl(
    ::Common::Float3* scl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scl_);
  }
  _impl_.scl_ = scl;
  if (scl) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.TransformPropertyValue.scl)
}
inline ::Common::Float3* TransformPropertyValue::release_scl() {
  
  ::Common::Float3* temp = _impl_.scl_;
  _impl_.scl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Float3* TransformPropertyValue::unsafe_arena_release_scl() {
  // @@protoc_insertion_point(field_release:ServerData.TransformPropertyValue.scl)
  
  ::Common::Float3* temp = _impl_.scl_;
  _impl_.scl_ = nullptr;
  return temp;
}
inline ::Common::Float3* TransformPropertyValue::_internal_mutable_scl() {
  
  if (_impl_.scl_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Float3>(GetArenaForAllocation());
    _impl_.scl_ = p;
  }
  return _impl_.scl_;
}
inline ::Common::Float3* TransformPropertyValue::mutable_scl() {
  ::Common::Float3* _msg = _internal_mutable_scl();
  // @@protoc_insertion_point(field_mutable:ServerData.TransformPropertyValue.scl)
  return _msg;
}
inline void TransformPropertyValue::set_allocated_scl(::Common::Float3* scl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scl_);
  }
  if (scl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scl));
    if (message_arena != submessage_arena) {
      scl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scl, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.scl_ = scl;
  // @@protoc_insertion_point(field_set_allocated:ServerData.TransformPropertyValue.scl)
}

// -------------------------------------------------------------------

// GetAudioInputDevicesReq

// int32 reqId = 1;
inline void GetAudioInputDevicesReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t GetAudioInputDevicesReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t GetAudioInputDevicesReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.GetAudioInputDevicesReq.reqId)
  return _internal_reqid();
}
inline void GetAudioInputDevicesReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void GetAudioInputDevicesReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.GetAudioInputDevicesReq.reqId)
}

// -------------------------------------------------------------------

// GetAudioOutputDevicesReq

// int32 reqId = 1;
inline void GetAudioOutputDevicesReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t GetAudioOutputDevicesReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t GetAudioOutputDevicesReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.GetAudioOutputDevicesReq.reqId)
  return _internal_reqid();
}
inline void GetAudioOutputDevicesReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void GetAudioOutputDevicesReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.GetAudioOutputDevicesReq.reqId)
}

// -------------------------------------------------------------------

// GetVideoInputDevicesReq

// int32 reqId = 1;
inline void GetVideoInputDevicesReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t GetVideoInputDevicesReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t GetVideoInputDevicesReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.GetVideoInputDevicesReq.reqId)
  return _internal_reqid();
}
inline void GetVideoInputDevicesReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void GetVideoInputDevicesReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.GetVideoInputDevicesReq.reqId)
}

// -------------------------------------------------------------------

// GetAudioInputDevicesResp

// int32 reqId = 1;
inline void GetAudioInputDevicesResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t GetAudioInputDevicesResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t GetAudioInputDevicesResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.GetAudioInputDevicesResp.reqId)
  return _internal_reqid();
}
inline void GetAudioInputDevicesResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void GetAudioInputDevicesResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.GetAudioInputDevicesResp.reqId)
}

// .ServerData.RtcAudioInputDeviceList Devices = 10;
inline bool GetAudioInputDevicesResp::_internal_has_devices() const {
  return this != internal_default_instance() && _impl_.devices_ != nullptr;
}
inline bool GetAudioInputDevicesResp::has_devices() const {
  return _internal_has_devices();
}
inline const ::ServerData::RtcAudioInputDeviceList& GetAudioInputDevicesResp::_internal_devices() const {
  const ::ServerData::RtcAudioInputDeviceList* p = _impl_.devices_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::RtcAudioInputDeviceList&>(
      ::ServerData::_RtcAudioInputDeviceList_default_instance_);
}
inline const ::ServerData::RtcAudioInputDeviceList& GetAudioInputDevicesResp::devices() const {
  // @@protoc_insertion_point(field_get:ServerData.GetAudioInputDevicesResp.Devices)
  return _internal_devices();
}
inline void GetAudioInputDevicesResp::unsafe_arena_set_allocated_devices(
    ::ServerData::RtcAudioInputDeviceList* devices) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.devices_);
  }
  _impl_.devices_ = devices;
  if (devices) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.GetAudioInputDevicesResp.Devices)
}
inline ::ServerData::RtcAudioInputDeviceList* GetAudioInputDevicesResp::release_devices() {
  
  ::ServerData::RtcAudioInputDeviceList* temp = _impl_.devices_;
  _impl_.devices_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::RtcAudioInputDeviceList* GetAudioInputDevicesResp::unsafe_arena_release_devices() {
  // @@protoc_insertion_point(field_release:ServerData.GetAudioInputDevicesResp.Devices)
  
  ::ServerData::RtcAudioInputDeviceList* temp = _impl_.devices_;
  _impl_.devices_ = nullptr;
  return temp;
}
inline ::ServerData::RtcAudioInputDeviceList* GetAudioInputDevicesResp::_internal_mutable_devices() {
  
  if (_impl_.devices_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::RtcAudioInputDeviceList>(GetArenaForAllocation());
    _impl_.devices_ = p;
  }
  return _impl_.devices_;
}
inline ::ServerData::RtcAudioInputDeviceList* GetAudioInputDevicesResp::mutable_devices() {
  ::ServerData::RtcAudioInputDeviceList* _msg = _internal_mutable_devices();
  // @@protoc_insertion_point(field_mutable:ServerData.GetAudioInputDevicesResp.Devices)
  return _msg;
}
inline void GetAudioInputDevicesResp::set_allocated_devices(::ServerData::RtcAudioInputDeviceList* devices) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.devices_);
  }
  if (devices) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(devices));
    if (message_arena != submessage_arena) {
      devices = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, devices, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.devices_ = devices;
  // @@protoc_insertion_point(field_set_allocated:ServerData.GetAudioInputDevicesResp.Devices)
}

// -------------------------------------------------------------------

// GetAudioOutputDevicesResp

// int32 reqId = 1;
inline void GetAudioOutputDevicesResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t GetAudioOutputDevicesResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t GetAudioOutputDevicesResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.GetAudioOutputDevicesResp.reqId)
  return _internal_reqid();
}
inline void GetAudioOutputDevicesResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void GetAudioOutputDevicesResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.GetAudioOutputDevicesResp.reqId)
}

// .ServerData.RtcAudioOutputDeviceList Devices = 10;
inline bool GetAudioOutputDevicesResp::_internal_has_devices() const {
  return this != internal_default_instance() && _impl_.devices_ != nullptr;
}
inline bool GetAudioOutputDevicesResp::has_devices() const {
  return _internal_has_devices();
}
inline const ::ServerData::RtcAudioOutputDeviceList& GetAudioOutputDevicesResp::_internal_devices() const {
  const ::ServerData::RtcAudioOutputDeviceList* p = _impl_.devices_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::RtcAudioOutputDeviceList&>(
      ::ServerData::_RtcAudioOutputDeviceList_default_instance_);
}
inline const ::ServerData::RtcAudioOutputDeviceList& GetAudioOutputDevicesResp::devices() const {
  // @@protoc_insertion_point(field_get:ServerData.GetAudioOutputDevicesResp.Devices)
  return _internal_devices();
}
inline void GetAudioOutputDevicesResp::unsafe_arena_set_allocated_devices(
    ::ServerData::RtcAudioOutputDeviceList* devices) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.devices_);
  }
  _impl_.devices_ = devices;
  if (devices) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.GetAudioOutputDevicesResp.Devices)
}
inline ::ServerData::RtcAudioOutputDeviceList* GetAudioOutputDevicesResp::release_devices() {
  
  ::ServerData::RtcAudioOutputDeviceList* temp = _impl_.devices_;
  _impl_.devices_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::RtcAudioOutputDeviceList* GetAudioOutputDevicesResp::unsafe_arena_release_devices() {
  // @@protoc_insertion_point(field_release:ServerData.GetAudioOutputDevicesResp.Devices)
  
  ::ServerData::RtcAudioOutputDeviceList* temp = _impl_.devices_;
  _impl_.devices_ = nullptr;
  return temp;
}
inline ::ServerData::RtcAudioOutputDeviceList* GetAudioOutputDevicesResp::_internal_mutable_devices() {
  
  if (_impl_.devices_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::RtcAudioOutputDeviceList>(GetArenaForAllocation());
    _impl_.devices_ = p;
  }
  return _impl_.devices_;
}
inline ::ServerData::RtcAudioOutputDeviceList* GetAudioOutputDevicesResp::mutable_devices() {
  ::ServerData::RtcAudioOutputDeviceList* _msg = _internal_mutable_devices();
  // @@protoc_insertion_point(field_mutable:ServerData.GetAudioOutputDevicesResp.Devices)
  return _msg;
}
inline void GetAudioOutputDevicesResp::set_allocated_devices(::ServerData::RtcAudioOutputDeviceList* devices) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.devices_);
  }
  if (devices) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(devices));
    if (message_arena != submessage_arena) {
      devices = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, devices, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.devices_ = devices;
  // @@protoc_insertion_point(field_set_allocated:ServerData.GetAudioOutputDevicesResp.Devices)
}

// -------------------------------------------------------------------

// GetVideoInputDevicesResp

// int32 reqId = 1;
inline void GetVideoInputDevicesResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t GetVideoInputDevicesResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t GetVideoInputDevicesResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.GetVideoInputDevicesResp.reqId)
  return _internal_reqid();
}
inline void GetVideoInputDevicesResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void GetVideoInputDevicesResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.GetVideoInputDevicesResp.reqId)
}

// .ServerData.RtcVideoInputDeviceList Devices = 10;
inline bool GetVideoInputDevicesResp::_internal_has_devices() const {
  return this != internal_default_instance() && _impl_.devices_ != nullptr;
}
inline bool GetVideoInputDevicesResp::has_devices() const {
  return _internal_has_devices();
}
inline const ::ServerData::RtcVideoInputDeviceList& GetVideoInputDevicesResp::_internal_devices() const {
  const ::ServerData::RtcVideoInputDeviceList* p = _impl_.devices_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::RtcVideoInputDeviceList&>(
      ::ServerData::_RtcVideoInputDeviceList_default_instance_);
}
inline const ::ServerData::RtcVideoInputDeviceList& GetVideoInputDevicesResp::devices() const {
  // @@protoc_insertion_point(field_get:ServerData.GetVideoInputDevicesResp.Devices)
  return _internal_devices();
}
inline void GetVideoInputDevicesResp::unsafe_arena_set_allocated_devices(
    ::ServerData::RtcVideoInputDeviceList* devices) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.devices_);
  }
  _impl_.devices_ = devices;
  if (devices) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.GetVideoInputDevicesResp.Devices)
}
inline ::ServerData::RtcVideoInputDeviceList* GetVideoInputDevicesResp::release_devices() {
  
  ::ServerData::RtcVideoInputDeviceList* temp = _impl_.devices_;
  _impl_.devices_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::RtcVideoInputDeviceList* GetVideoInputDevicesResp::unsafe_arena_release_devices() {
  // @@protoc_insertion_point(field_release:ServerData.GetVideoInputDevicesResp.Devices)
  
  ::ServerData::RtcVideoInputDeviceList* temp = _impl_.devices_;
  _impl_.devices_ = nullptr;
  return temp;
}
inline ::ServerData::RtcVideoInputDeviceList* GetVideoInputDevicesResp::_internal_mutable_devices() {
  
  if (_impl_.devices_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::RtcVideoInputDeviceList>(GetArenaForAllocation());
    _impl_.devices_ = p;
  }
  return _impl_.devices_;
}
inline ::ServerData::RtcVideoInputDeviceList* GetVideoInputDevicesResp::mutable_devices() {
  ::ServerData::RtcVideoInputDeviceList* _msg = _internal_mutable_devices();
  // @@protoc_insertion_point(field_mutable:ServerData.GetVideoInputDevicesResp.Devices)
  return _msg;
}
inline void GetVideoInputDevicesResp::set_allocated_devices(::ServerData::RtcVideoInputDeviceList* devices) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.devices_);
  }
  if (devices) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(devices));
    if (message_arena != submessage_arena) {
      devices = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, devices, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.devices_ = devices;
  // @@protoc_insertion_point(field_set_allocated:ServerData.GetVideoInputDevicesResp.Devices)
}

// -------------------------------------------------------------------

// SetAudioInputDeviceReq

// int32 reqId = 1;
inline void SetAudioInputDeviceReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t SetAudioInputDeviceReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t SetAudioInputDeviceReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.SetAudioInputDeviceReq.reqId)
  return _internal_reqid();
}
inline void SetAudioInputDeviceReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void SetAudioInputDeviceReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.SetAudioInputDeviceReq.reqId)
}

// .ServerData.RtcAudioInputDevice Device = 2;
inline bool SetAudioInputDeviceReq::_internal_has_device() const {
  return this != internal_default_instance() && _impl_.device_ != nullptr;
}
inline bool SetAudioInputDeviceReq::has_device() const {
  return _internal_has_device();
}
inline const ::ServerData::RtcAudioInputDevice& SetAudioInputDeviceReq::_internal_device() const {
  const ::ServerData::RtcAudioInputDevice* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::RtcAudioInputDevice&>(
      ::ServerData::_RtcAudioInputDevice_default_instance_);
}
inline const ::ServerData::RtcAudioInputDevice& SetAudioInputDeviceReq::device() const {
  // @@protoc_insertion_point(field_get:ServerData.SetAudioInputDeviceReq.Device)
  return _internal_device();
}
inline void SetAudioInputDeviceReq::unsafe_arena_set_allocated_device(
    ::ServerData::RtcAudioInputDevice* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.SetAudioInputDeviceReq.Device)
}
inline ::ServerData::RtcAudioInputDevice* SetAudioInputDeviceReq::release_device() {
  
  ::ServerData::RtcAudioInputDevice* temp = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::RtcAudioInputDevice* SetAudioInputDeviceReq::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:ServerData.SetAudioInputDeviceReq.Device)
  
  ::ServerData::RtcAudioInputDevice* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::ServerData::RtcAudioInputDevice* SetAudioInputDeviceReq::_internal_mutable_device() {
  
  if (_impl_.device_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::RtcAudioInputDevice>(GetArenaForAllocation());
    _impl_.device_ = p;
  }
  return _impl_.device_;
}
inline ::ServerData::RtcAudioInputDevice* SetAudioInputDeviceReq::mutable_device() {
  ::ServerData::RtcAudioInputDevice* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:ServerData.SetAudioInputDeviceReq.Device)
  return _msg;
}
inline void SetAudioInputDeviceReq::set_allocated_device(::ServerData::RtcAudioInputDevice* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device));
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.device_ = device;
  // @@protoc_insertion_point(field_set_allocated:ServerData.SetAudioInputDeviceReq.Device)
}

// -------------------------------------------------------------------

// SetAudioOutputDeviceReq

// int32 reqId = 1;
inline void SetAudioOutputDeviceReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t SetAudioOutputDeviceReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t SetAudioOutputDeviceReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.SetAudioOutputDeviceReq.reqId)
  return _internal_reqid();
}
inline void SetAudioOutputDeviceReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void SetAudioOutputDeviceReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.SetAudioOutputDeviceReq.reqId)
}

// .ServerData.RtcAudioOutputDevice Device = 2;
inline bool SetAudioOutputDeviceReq::_internal_has_device() const {
  return this != internal_default_instance() && _impl_.device_ != nullptr;
}
inline bool SetAudioOutputDeviceReq::has_device() const {
  return _internal_has_device();
}
inline const ::ServerData::RtcAudioOutputDevice& SetAudioOutputDeviceReq::_internal_device() const {
  const ::ServerData::RtcAudioOutputDevice* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::RtcAudioOutputDevice&>(
      ::ServerData::_RtcAudioOutputDevice_default_instance_);
}
inline const ::ServerData::RtcAudioOutputDevice& SetAudioOutputDeviceReq::device() const {
  // @@protoc_insertion_point(field_get:ServerData.SetAudioOutputDeviceReq.Device)
  return _internal_device();
}
inline void SetAudioOutputDeviceReq::unsafe_arena_set_allocated_device(
    ::ServerData::RtcAudioOutputDevice* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.SetAudioOutputDeviceReq.Device)
}
inline ::ServerData::RtcAudioOutputDevice* SetAudioOutputDeviceReq::release_device() {
  
  ::ServerData::RtcAudioOutputDevice* temp = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::RtcAudioOutputDevice* SetAudioOutputDeviceReq::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:ServerData.SetAudioOutputDeviceReq.Device)
  
  ::ServerData::RtcAudioOutputDevice* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::ServerData::RtcAudioOutputDevice* SetAudioOutputDeviceReq::_internal_mutable_device() {
  
  if (_impl_.device_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::RtcAudioOutputDevice>(GetArenaForAllocation());
    _impl_.device_ = p;
  }
  return _impl_.device_;
}
inline ::ServerData::RtcAudioOutputDevice* SetAudioOutputDeviceReq::mutable_device() {
  ::ServerData::RtcAudioOutputDevice* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:ServerData.SetAudioOutputDeviceReq.Device)
  return _msg;
}
inline void SetAudioOutputDeviceReq::set_allocated_device(::ServerData::RtcAudioOutputDevice* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device));
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.device_ = device;
  // @@protoc_insertion_point(field_set_allocated:ServerData.SetAudioOutputDeviceReq.Device)
}

// -------------------------------------------------------------------

// SetVideoInputDeviceReq

// int32 reqId = 1;
inline void SetVideoInputDeviceReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t SetVideoInputDeviceReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t SetVideoInputDeviceReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.SetVideoInputDeviceReq.reqId)
  return _internal_reqid();
}
inline void SetVideoInputDeviceReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void SetVideoInputDeviceReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.SetVideoInputDeviceReq.reqId)
}

// .ServerData.RtcVideoInputDevice Device = 2;
inline bool SetVideoInputDeviceReq::_internal_has_device() const {
  return this != internal_default_instance() && _impl_.device_ != nullptr;
}
inline bool SetVideoInputDeviceReq::has_device() const {
  return _internal_has_device();
}
inline const ::ServerData::RtcVideoInputDevice& SetVideoInputDeviceReq::_internal_device() const {
  const ::ServerData::RtcVideoInputDevice* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::RtcVideoInputDevice&>(
      ::ServerData::_RtcVideoInputDevice_default_instance_);
}
inline const ::ServerData::RtcVideoInputDevice& SetVideoInputDeviceReq::device() const {
  // @@protoc_insertion_point(field_get:ServerData.SetVideoInputDeviceReq.Device)
  return _internal_device();
}
inline void SetVideoInputDeviceReq::unsafe_arena_set_allocated_device(
    ::ServerData::RtcVideoInputDevice* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.SetVideoInputDeviceReq.Device)
}
inline ::ServerData::RtcVideoInputDevice* SetVideoInputDeviceReq::release_device() {
  
  ::ServerData::RtcVideoInputDevice* temp = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::RtcVideoInputDevice* SetVideoInputDeviceReq::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:ServerData.SetVideoInputDeviceReq.Device)
  
  ::ServerData::RtcVideoInputDevice* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::ServerData::RtcVideoInputDevice* SetVideoInputDeviceReq::_internal_mutable_device() {
  
  if (_impl_.device_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::RtcVideoInputDevice>(GetArenaForAllocation());
    _impl_.device_ = p;
  }
  return _impl_.device_;
}
inline ::ServerData::RtcVideoInputDevice* SetVideoInputDeviceReq::mutable_device() {
  ::ServerData::RtcVideoInputDevice* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:ServerData.SetVideoInputDeviceReq.Device)
  return _msg;
}
inline void SetVideoInputDeviceReq::set_allocated_device(::ServerData::RtcVideoInputDevice* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device));
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.device_ = device;
  // @@protoc_insertion_point(field_set_allocated:ServerData.SetVideoInputDeviceReq.Device)
}

// -------------------------------------------------------------------

// PostCreateObject

// int32 reqId = 5;
inline void PostCreateObject::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t PostCreateObject::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t PostCreateObject::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.PostCreateObject.reqId)
  return _internal_reqid();
}
inline void PostCreateObject::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void PostCreateObject::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.PostCreateObject.reqId)
}

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool PostCreateObject::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool PostCreateObject::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PostCreateObject::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PostCreateObject::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PostCreateObject.spaceConn)
  return _internal_spaceconn();
}
inline void PostCreateObject::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PostCreateObject.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PostCreateObject::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostCreateObject::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PostCreateObject.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostCreateObject::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PostCreateObject::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PostCreateObject.spaceConn)
  return _msg;
}
inline void PostCreateObject::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostCreateObject.spaceConn)
}

// string newInstanceId = 2;
inline void PostCreateObject::clear_newinstanceid() {
  _impl_.newinstanceid_.ClearToEmpty();
}
inline const std::string& PostCreateObject::newinstanceid() const {
  // @@protoc_insertion_point(field_get:ServerData.PostCreateObject.newInstanceId)
  return _internal_newinstanceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostCreateObject::set_newinstanceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newinstanceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PostCreateObject.newInstanceId)
}
inline std::string* PostCreateObject::mutable_newinstanceid() {
  std::string* _s = _internal_mutable_newinstanceid();
  // @@protoc_insertion_point(field_mutable:ServerData.PostCreateObject.newInstanceId)
  return _s;
}
inline const std::string& PostCreateObject::_internal_newinstanceid() const {
  return _impl_.newinstanceid_.Get();
}
inline void PostCreateObject::_internal_set_newinstanceid(const std::string& value) {
  
  _impl_.newinstanceid_.Set(value, GetArenaForAllocation());
}
inline std::string* PostCreateObject::_internal_mutable_newinstanceid() {
  
  return _impl_.newinstanceid_.Mutable(GetArenaForAllocation());
}
inline std::string* PostCreateObject::release_newinstanceid() {
  // @@protoc_insertion_point(field_release:ServerData.PostCreateObject.newInstanceId)
  return _impl_.newinstanceid_.Release();
}
inline void PostCreateObject::set_allocated_newinstanceid(std::string* newinstanceid) {
  if (newinstanceid != nullptr) {
    
  } else {
    
  }
  _impl_.newinstanceid_.SetAllocated(newinstanceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newinstanceid_.IsDefault()) {
    _impl_.newinstanceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostCreateObject.newInstanceId)
}

// string uniqueObjectIdent = 10;
inline void PostCreateObject::clear_uniqueobjectident() {
  _impl_.uniqueobjectident_.ClearToEmpty();
}
inline const std::string& PostCreateObject::uniqueobjectident() const {
  // @@protoc_insertion_point(field_get:ServerData.PostCreateObject.uniqueObjectIdent)
  return _internal_uniqueobjectident();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostCreateObject::set_uniqueobjectident(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uniqueobjectident_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PostCreateObject.uniqueObjectIdent)
}
inline std::string* PostCreateObject::mutable_uniqueobjectident() {
  std::string* _s = _internal_mutable_uniqueobjectident();
  // @@protoc_insertion_point(field_mutable:ServerData.PostCreateObject.uniqueObjectIdent)
  return _s;
}
inline const std::string& PostCreateObject::_internal_uniqueobjectident() const {
  return _impl_.uniqueobjectident_.Get();
}
inline void PostCreateObject::_internal_set_uniqueobjectident(const std::string& value) {
  
  _impl_.uniqueobjectident_.Set(value, GetArenaForAllocation());
}
inline std::string* PostCreateObject::_internal_mutable_uniqueobjectident() {
  
  return _impl_.uniqueobjectident_.Mutable(GetArenaForAllocation());
}
inline std::string* PostCreateObject::release_uniqueobjectident() {
  // @@protoc_insertion_point(field_release:ServerData.PostCreateObject.uniqueObjectIdent)
  return _impl_.uniqueobjectident_.Release();
}
inline void PostCreateObject::set_allocated_uniqueobjectident(std::string* uniqueobjectident) {
  if (uniqueobjectident != nullptr) {
    
  } else {
    
  }
  _impl_.uniqueobjectident_.SetAllocated(uniqueobjectident, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uniqueobjectident_.IsDefault()) {
    _impl_.uniqueobjectident_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostCreateObject.uniqueObjectIdent)
}

// -------------------------------------------------------------------

// PostRemoveObject

// int32 reqId = 5;
inline void PostRemoveObject::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t PostRemoveObject::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t PostRemoveObject::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.PostRemoveObject.reqId)
  return _internal_reqid();
}
inline void PostRemoveObject::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void PostRemoveObject::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.PostRemoveObject.reqId)
}

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool PostRemoveObject::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool PostRemoveObject::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PostRemoveObject::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PostRemoveObject::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PostRemoveObject.spaceConn)
  return _internal_spaceconn();
}
inline void PostRemoveObject::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PostRemoveObject.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PostRemoveObject::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostRemoveObject::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PostRemoveObject.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostRemoveObject::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PostRemoveObject::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PostRemoveObject.spaceConn)
  return _msg;
}
inline void PostRemoveObject::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostRemoveObject.spaceConn)
}

// string containerId = 2;
inline void PostRemoveObject::clear_containerid() {
  _impl_.containerid_.ClearToEmpty();
}
inline const std::string& PostRemoveObject::containerid() const {
  // @@protoc_insertion_point(field_get:ServerData.PostRemoveObject.containerId)
  return _internal_containerid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostRemoveObject::set_containerid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.containerid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PostRemoveObject.containerId)
}
inline std::string* PostRemoveObject::mutable_containerid() {
  std::string* _s = _internal_mutable_containerid();
  // @@protoc_insertion_point(field_mutable:ServerData.PostRemoveObject.containerId)
  return _s;
}
inline const std::string& PostRemoveObject::_internal_containerid() const {
  return _impl_.containerid_.Get();
}
inline void PostRemoveObject::_internal_set_containerid(const std::string& value) {
  
  _impl_.containerid_.Set(value, GetArenaForAllocation());
}
inline std::string* PostRemoveObject::_internal_mutable_containerid() {
  
  return _impl_.containerid_.Mutable(GetArenaForAllocation());
}
inline std::string* PostRemoveObject::release_containerid() {
  // @@protoc_insertion_point(field_release:ServerData.PostRemoveObject.containerId)
  return _impl_.containerid_.Release();
}
inline void PostRemoveObject::set_allocated_containerid(std::string* containerid) {
  if (containerid != nullptr) {
    
  } else {
    
  }
  _impl_.containerid_.SetAllocated(containerid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.containerid_.IsDefault()) {
    _impl_.containerid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostRemoveObject.containerId)
}

// -------------------------------------------------------------------

// FetchFileByIdReq

// string contentId = 1;
inline void FetchFileByIdReq::clear_contentid() {
  _impl_.contentid_.ClearToEmpty();
}
inline const std::string& FetchFileByIdReq::contentid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdReq.contentId)
  return _internal_contentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileByIdReq::set_contentid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contentid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdReq.contentId)
}
inline std::string* FetchFileByIdReq::mutable_contentid() {
  std::string* _s = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchFileByIdReq.contentId)
  return _s;
}
inline const std::string& FetchFileByIdReq::_internal_contentid() const {
  return _impl_.contentid_.Get();
}
inline void FetchFileByIdReq::_internal_set_contentid(const std::string& value) {
  
  _impl_.contentid_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileByIdReq::_internal_mutable_contentid() {
  
  return _impl_.contentid_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileByIdReq::release_contentid() {
  // @@protoc_insertion_point(field_release:ServerData.FetchFileByIdReq.contentId)
  return _impl_.contentid_.Release();
}
inline void FetchFileByIdReq::set_allocated_contentid(std::string* contentid) {
  if (contentid != nullptr) {
    
  } else {
    
  }
  _impl_.contentid_.SetAllocated(contentid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contentid_.IsDefault()) {
    _impl_.contentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchFileByIdReq.contentId)
}

// -------------------------------------------------------------------

// FetchFileByIdProgressResp

// string contentId = 1;
inline void FetchFileByIdProgressResp::clear_contentid() {
  _impl_.contentid_.ClearToEmpty();
}
inline const std::string& FetchFileByIdProgressResp::contentid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdProgressResp.contentId)
  return _internal_contentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileByIdProgressResp::set_contentid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contentid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdProgressResp.contentId)
}
inline std::string* FetchFileByIdProgressResp::mutable_contentid() {
  std::string* _s = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchFileByIdProgressResp.contentId)
  return _s;
}
inline const std::string& FetchFileByIdProgressResp::_internal_contentid() const {
  return _impl_.contentid_.Get();
}
inline void FetchFileByIdProgressResp::_internal_set_contentid(const std::string& value) {
  
  _impl_.contentid_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileByIdProgressResp::_internal_mutable_contentid() {
  
  return _impl_.contentid_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileByIdProgressResp::release_contentid() {
  // @@protoc_insertion_point(field_release:ServerData.FetchFileByIdProgressResp.contentId)
  return _impl_.contentid_.Release();
}
inline void FetchFileByIdProgressResp::set_allocated_contentid(std::string* contentid) {
  if (contentid != nullptr) {
    
  } else {
    
  }
  _impl_.contentid_.SetAllocated(contentid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contentid_.IsDefault()) {
    _impl_.contentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchFileByIdProgressResp.contentId)
}

// float progress = 10;
inline void FetchFileByIdProgressResp::clear_progress() {
  _impl_.progress_ = 0;
}
inline float FetchFileByIdProgressResp::_internal_progress() const {
  return _impl_.progress_;
}
inline float FetchFileByIdProgressResp::progress() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdProgressResp.progress)
  return _internal_progress();
}
inline void FetchFileByIdProgressResp::_internal_set_progress(float value) {
  
  _impl_.progress_ = value;
}
inline void FetchFileByIdProgressResp::set_progress(float value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdProgressResp.progress)
}

// string progressStep = 11;
inline void FetchFileByIdProgressResp::clear_progressstep() {
  _impl_.progressstep_.ClearToEmpty();
}
inline const std::string& FetchFileByIdProgressResp::progressstep() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdProgressResp.progressStep)
  return _internal_progressstep();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileByIdProgressResp::set_progressstep(ArgT0&& arg0, ArgT... args) {
 
 _impl_.progressstep_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdProgressResp.progressStep)
}
inline std::string* FetchFileByIdProgressResp::mutable_progressstep() {
  std::string* _s = _internal_mutable_progressstep();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchFileByIdProgressResp.progressStep)
  return _s;
}
inline const std::string& FetchFileByIdProgressResp::_internal_progressstep() const {
  return _impl_.progressstep_.Get();
}
inline void FetchFileByIdProgressResp::_internal_set_progressstep(const std::string& value) {
  
  _impl_.progressstep_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileByIdProgressResp::_internal_mutable_progressstep() {
  
  return _impl_.progressstep_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileByIdProgressResp::release_progressstep() {
  // @@protoc_insertion_point(field_release:ServerData.FetchFileByIdProgressResp.progressStep)
  return _impl_.progressstep_.Release();
}
inline void FetchFileByIdProgressResp::set_allocated_progressstep(std::string* progressstep) {
  if (progressstep != nullptr) {
    
  } else {
    
  }
  _impl_.progressstep_.SetAllocated(progressstep, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.progressstep_.IsDefault()) {
    _impl_.progressstep_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchFileByIdProgressResp.progressStep)
}

// -------------------------------------------------------------------

// FetchFileByIdCompletedResp

// string contentId = 1;
inline void FetchFileByIdCompletedResp::clear_contentid() {
  _impl_.contentid_.ClearToEmpty();
}
inline const std::string& FetchFileByIdCompletedResp::contentid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdCompletedResp.contentId)
  return _internal_contentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileByIdCompletedResp::set_contentid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contentid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdCompletedResp.contentId)
}
inline std::string* FetchFileByIdCompletedResp::mutable_contentid() {
  std::string* _s = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchFileByIdCompletedResp.contentId)
  return _s;
}
inline const std::string& FetchFileByIdCompletedResp::_internal_contentid() const {
  return _impl_.contentid_.Get();
}
inline void FetchFileByIdCompletedResp::_internal_set_contentid(const std::string& value) {
  
  _impl_.contentid_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileByIdCompletedResp::_internal_mutable_contentid() {
  
  return _impl_.contentid_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileByIdCompletedResp::release_contentid() {
  // @@protoc_insertion_point(field_release:ServerData.FetchFileByIdCompletedResp.contentId)
  return _impl_.contentid_.Release();
}
inline void FetchFileByIdCompletedResp::set_allocated_contentid(std::string* contentid) {
  if (contentid != nullptr) {
    
  } else {
    
  }
  _impl_.contentid_.SetAllocated(contentid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contentid_.IsDefault()) {
    _impl_.contentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchFileByIdCompletedResp.contentId)
}

// string filePath = 10;
inline void FetchFileByIdCompletedResp::clear_filepath() {
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& FetchFileByIdCompletedResp::filepath() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdCompletedResp.filePath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileByIdCompletedResp::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdCompletedResp.filePath)
}
inline std::string* FetchFileByIdCompletedResp::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchFileByIdCompletedResp.filePath)
  return _s;
}
inline const std::string& FetchFileByIdCompletedResp::_internal_filepath() const {
  return _impl_.filepath_.Get();
}
inline void FetchFileByIdCompletedResp::_internal_set_filepath(const std::string& value) {
  
  _impl_.filepath_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileByIdCompletedResp::_internal_mutable_filepath() {
  
  return _impl_.filepath_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileByIdCompletedResp::release_filepath() {
  // @@protoc_insertion_point(field_release:ServerData.FetchFileByIdCompletedResp.filePath)
  return _impl_.filepath_.Release();
}
inline void FetchFileByIdCompletedResp::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  _impl_.filepath_.SetAllocated(filepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchFileByIdCompletedResp.filePath)
}

// string finalFileNameWithExtension = 11;
inline void FetchFileByIdCompletedResp::clear_finalfilenamewithextension() {
  _impl_.finalfilenamewithextension_.ClearToEmpty();
}
inline const std::string& FetchFileByIdCompletedResp::finalfilenamewithextension() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdCompletedResp.finalFileNameWithExtension)
  return _internal_finalfilenamewithextension();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileByIdCompletedResp::set_finalfilenamewithextension(ArgT0&& arg0, ArgT... args) {
 
 _impl_.finalfilenamewithextension_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdCompletedResp.finalFileNameWithExtension)
}
inline std::string* FetchFileByIdCompletedResp::mutable_finalfilenamewithextension() {
  std::string* _s = _internal_mutable_finalfilenamewithextension();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchFileByIdCompletedResp.finalFileNameWithExtension)
  return _s;
}
inline const std::string& FetchFileByIdCompletedResp::_internal_finalfilenamewithextension() const {
  return _impl_.finalfilenamewithextension_.Get();
}
inline void FetchFileByIdCompletedResp::_internal_set_finalfilenamewithextension(const std::string& value) {
  
  _impl_.finalfilenamewithextension_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileByIdCompletedResp::_internal_mutable_finalfilenamewithextension() {
  
  return _impl_.finalfilenamewithextension_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileByIdCompletedResp::release_finalfilenamewithextension() {
  // @@protoc_insertion_point(field_release:ServerData.FetchFileByIdCompletedResp.finalFileNameWithExtension)
  return _impl_.finalfilenamewithextension_.Release();
}
inline void FetchFileByIdCompletedResp::set_allocated_finalfilenamewithextension(std::string* finalfilenamewithextension) {
  if (finalfilenamewithextension != nullptr) {
    
  } else {
    
  }
  _impl_.finalfilenamewithextension_.SetAllocated(finalfilenamewithextension, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.finalfilenamewithextension_.IsDefault()) {
    _impl_.finalfilenamewithextension_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchFileByIdCompletedResp.finalFileNameWithExtension)
}

// -------------------------------------------------------------------

// FetchFileByIdFailureResp

// string contentId = 1;
inline void FetchFileByIdFailureResp::clear_contentid() {
  _impl_.contentid_.ClearToEmpty();
}
inline const std::string& FetchFileByIdFailureResp::contentid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdFailureResp.contentId)
  return _internal_contentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileByIdFailureResp::set_contentid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contentid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdFailureResp.contentId)
}
inline std::string* FetchFileByIdFailureResp::mutable_contentid() {
  std::string* _s = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchFileByIdFailureResp.contentId)
  return _s;
}
inline const std::string& FetchFileByIdFailureResp::_internal_contentid() const {
  return _impl_.contentid_.Get();
}
inline void FetchFileByIdFailureResp::_internal_set_contentid(const std::string& value) {
  
  _impl_.contentid_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileByIdFailureResp::_internal_mutable_contentid() {
  
  return _impl_.contentid_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileByIdFailureResp::release_contentid() {
  // @@protoc_insertion_point(field_release:ServerData.FetchFileByIdFailureResp.contentId)
  return _impl_.contentid_.Release();
}
inline void FetchFileByIdFailureResp::set_allocated_contentid(std::string* contentid) {
  if (contentid != nullptr) {
    
  } else {
    
  }
  _impl_.contentid_.SetAllocated(contentid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contentid_.IsDefault()) {
    _impl_.contentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchFileByIdFailureResp.contentId)
}

// string errorMsg = 2;
inline void FetchFileByIdFailureResp::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
}
inline const std::string& FetchFileByIdFailureResp::errormsg() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchFileByIdFailureResp.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileByIdFailureResp::set_errormsg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FetchFileByIdFailureResp.errorMsg)
}
inline std::string* FetchFileByIdFailureResp::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchFileByIdFailureResp.errorMsg)
  return _s;
}
inline const std::string& FetchFileByIdFailureResp::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void FetchFileByIdFailureResp::_internal_set_errormsg(const std::string& value) {
  
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileByIdFailureResp::_internal_mutable_errormsg() {
  
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileByIdFailureResp::release_errormsg() {
  // @@protoc_insertion_point(field_release:ServerData.FetchFileByIdFailureResp.errorMsg)
  return _impl_.errormsg_.Release();
}
inline void FetchFileByIdFailureResp::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    
  } else {
    
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchFileByIdFailureResp.errorMsg)
}

// -------------------------------------------------------------------

// FetchAllUploadedContentReq

// int32 reqId = 1;
inline void FetchAllUploadedContentReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t FetchAllUploadedContentReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t FetchAllUploadedContentReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchAllUploadedContentReq.reqId)
  return _internal_reqid();
}
inline void FetchAllUploadedContentReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void FetchAllUploadedContentReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.FetchAllUploadedContentReq.reqId)
}

// -------------------------------------------------------------------

// UploadLocalFileResp

// int32 reqId = 1;
inline void UploadLocalFileResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t UploadLocalFileResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t UploadLocalFileResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.UploadLocalFileResp.reqId)
  return _internal_reqid();
}
inline void UploadLocalFileResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void UploadLocalFileResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileResp.reqId)
}

// .ServerData.CavrnusRemoteContent uploadedContent = 10;
inline bool UploadLocalFileResp::_internal_has_uploadedcontent() const {
  return this != internal_default_instance() && _impl_.uploadedcontent_ != nullptr;
}
inline bool UploadLocalFileResp::has_uploadedcontent() const {
  return _internal_has_uploadedcontent();
}
inline const ::ServerData::CavrnusRemoteContent& UploadLocalFileResp::_internal_uploadedcontent() const {
  const ::ServerData::CavrnusRemoteContent* p = _impl_.uploadedcontent_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusRemoteContent&>(
      ::ServerData::_CavrnusRemoteContent_default_instance_);
}
inline const ::ServerData::CavrnusRemoteContent& UploadLocalFileResp::uploadedcontent() const {
  // @@protoc_insertion_point(field_get:ServerData.UploadLocalFileResp.uploadedContent)
  return _internal_uploadedcontent();
}
inline void UploadLocalFileResp::unsafe_arena_set_allocated_uploadedcontent(
    ::ServerData::CavrnusRemoteContent* uploadedcontent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uploadedcontent_);
  }
  _impl_.uploadedcontent_ = uploadedcontent;
  if (uploadedcontent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UploadLocalFileResp.uploadedContent)
}
inline ::ServerData::CavrnusRemoteContent* UploadLocalFileResp::release_uploadedcontent() {
  
  ::ServerData::CavrnusRemoteContent* temp = _impl_.uploadedcontent_;
  _impl_.uploadedcontent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusRemoteContent* UploadLocalFileResp::unsafe_arena_release_uploadedcontent() {
  // @@protoc_insertion_point(field_release:ServerData.UploadLocalFileResp.uploadedContent)
  
  ::ServerData::CavrnusRemoteContent* temp = _impl_.uploadedcontent_;
  _impl_.uploadedcontent_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusRemoteContent* UploadLocalFileResp::_internal_mutable_uploadedcontent() {
  
  if (_impl_.uploadedcontent_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusRemoteContent>(GetArenaForAllocation());
    _impl_.uploadedcontent_ = p;
  }
  return _impl_.uploadedcontent_;
}
inline ::ServerData::CavrnusRemoteContent* UploadLocalFileResp::mutable_uploadedcontent() {
  ::ServerData::CavrnusRemoteContent* _msg = _internal_mutable_uploadedcontent();
  // @@protoc_insertion_point(field_mutable:ServerData.UploadLocalFileResp.uploadedContent)
  return _msg;
}
inline void UploadLocalFileResp::set_allocated_uploadedcontent(::ServerData::CavrnusRemoteContent* uploadedcontent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uploadedcontent_);
  }
  if (uploadedcontent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uploadedcontent));
    if (message_arena != submessage_arena) {
      uploadedcontent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uploadedcontent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.uploadedcontent_ = uploadedcontent;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UploadLocalFileResp.uploadedContent)
}

// -------------------------------------------------------------------

// UploadLocalFileProgressResp

// int32 reqId = 1;
inline void UploadLocalFileProgressResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t UploadLocalFileProgressResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t UploadLocalFileProgressResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.UploadLocalFileProgressResp.reqId)
  return _internal_reqid();
}
inline void UploadLocalFileProgressResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void UploadLocalFileProgressResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileProgressResp.reqId)
}

// float progress = 10;
inline void UploadLocalFileProgressResp::clear_progress() {
  _impl_.progress_ = 0;
}
inline float UploadLocalFileProgressResp::_internal_progress() const {
  return _impl_.progress_;
}
inline float UploadLocalFileProgressResp::progress() const {
  // @@protoc_insertion_point(field_get:ServerData.UploadLocalFileProgressResp.progress)
  return _internal_progress();
}
inline void UploadLocalFileProgressResp::_internal_set_progress(float value) {
  
  _impl_.progress_ = value;
}
inline void UploadLocalFileProgressResp::set_progress(float value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileProgressResp.progress)
}

// string progressStep = 11;
inline void UploadLocalFileProgressResp::clear_progressstep() {
  _impl_.progressstep_.ClearToEmpty();
}
inline const std::string& UploadLocalFileProgressResp::progressstep() const {
  // @@protoc_insertion_point(field_get:ServerData.UploadLocalFileProgressResp.progressStep)
  return _internal_progressstep();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadLocalFileProgressResp::set_progressstep(ArgT0&& arg0, ArgT... args) {
 
 _impl_.progressstep_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileProgressResp.progressStep)
}
inline std::string* UploadLocalFileProgressResp::mutable_progressstep() {
  std::string* _s = _internal_mutable_progressstep();
  // @@protoc_insertion_point(field_mutable:ServerData.UploadLocalFileProgressResp.progressStep)
  return _s;
}
inline const std::string& UploadLocalFileProgressResp::_internal_progressstep() const {
  return _impl_.progressstep_.Get();
}
inline void UploadLocalFileProgressResp::_internal_set_progressstep(const std::string& value) {
  
  _impl_.progressstep_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadLocalFileProgressResp::_internal_mutable_progressstep() {
  
  return _impl_.progressstep_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadLocalFileProgressResp::release_progressstep() {
  // @@protoc_insertion_point(field_release:ServerData.UploadLocalFileProgressResp.progressStep)
  return _impl_.progressstep_.Release();
}
inline void UploadLocalFileProgressResp::set_allocated_progressstep(std::string* progressstep) {
  if (progressstep != nullptr) {
    
  } else {
    
  }
  _impl_.progressstep_.SetAllocated(progressstep, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.progressstep_.IsDefault()) {
    _impl_.progressstep_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.UploadLocalFileProgressResp.progressStep)
}

// -------------------------------------------------------------------

// UploadLocalFileReq

// int32 reqId = 1;
inline void UploadLocalFileReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t UploadLocalFileReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t UploadLocalFileReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.UploadLocalFileReq.reqId)
  return _internal_reqid();
}
inline void UploadLocalFileReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void UploadLocalFileReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileReq.reqId)
}

// string filePath = 10;
inline void UploadLocalFileReq::clear_filepath() {
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& UploadLocalFileReq::filepath() const {
  // @@protoc_insertion_point(field_get:ServerData.UploadLocalFileReq.filePath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadLocalFileReq::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileReq.filePath)
}
inline std::string* UploadLocalFileReq::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:ServerData.UploadLocalFileReq.filePath)
  return _s;
}
inline const std::string& UploadLocalFileReq::_internal_filepath() const {
  return _impl_.filepath_.Get();
}
inline void UploadLocalFileReq::_internal_set_filepath(const std::string& value) {
  
  _impl_.filepath_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadLocalFileReq::_internal_mutable_filepath() {
  
  return _impl_.filepath_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadLocalFileReq::release_filepath() {
  // @@protoc_insertion_point(field_release:ServerData.UploadLocalFileReq.filePath)
  return _impl_.filepath_.Release();
}
inline void UploadLocalFileReq::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  _impl_.filepath_.SetAllocated(filepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.UploadLocalFileReq.filePath)
}

// repeated string tagKeys = 11;
inline int UploadLocalFileReq::_internal_tagkeys_size() const {
  return _impl_.tagkeys_.size();
}
inline int UploadLocalFileReq::tagkeys_size() const {
  return _internal_tagkeys_size();
}
inline void UploadLocalFileReq::clear_tagkeys() {
  _impl_.tagkeys_.Clear();
}
inline std::string* UploadLocalFileReq::add_tagkeys() {
  std::string* _s = _internal_add_tagkeys();
  // @@protoc_insertion_point(field_add_mutable:ServerData.UploadLocalFileReq.tagKeys)
  return _s;
}
inline const std::string& UploadLocalFileReq::_internal_tagkeys(int index) const {
  return _impl_.tagkeys_.Get(index);
}
inline const std::string& UploadLocalFileReq::tagkeys(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.UploadLocalFileReq.tagKeys)
  return _internal_tagkeys(index);
}
inline std::string* UploadLocalFileReq::mutable_tagkeys(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.UploadLocalFileReq.tagKeys)
  return _impl_.tagkeys_.Mutable(index);
}
inline void UploadLocalFileReq::set_tagkeys(int index, const std::string& value) {
  _impl_.tagkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileReq.tagKeys)
}
inline void UploadLocalFileReq::set_tagkeys(int index, std::string&& value) {
  _impl_.tagkeys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileReq.tagKeys)
}
inline void UploadLocalFileReq::set_tagkeys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerData.UploadLocalFileReq.tagKeys)
}
inline void UploadLocalFileReq::set_tagkeys(int index, const char* value, size_t size) {
  _impl_.tagkeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerData.UploadLocalFileReq.tagKeys)
}
inline std::string* UploadLocalFileReq::_internal_add_tagkeys() {
  return _impl_.tagkeys_.Add();
}
inline void UploadLocalFileReq::add_tagkeys(const std::string& value) {
  _impl_.tagkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerData.UploadLocalFileReq.tagKeys)
}
inline void UploadLocalFileReq::add_tagkeys(std::string&& value) {
  _impl_.tagkeys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerData.UploadLocalFileReq.tagKeys)
}
inline void UploadLocalFileReq::add_tagkeys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerData.UploadLocalFileReq.tagKeys)
}
inline void UploadLocalFileReq::add_tagkeys(const char* value, size_t size) {
  _impl_.tagkeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerData.UploadLocalFileReq.tagKeys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UploadLocalFileReq::tagkeys() const {
  // @@protoc_insertion_point(field_list:ServerData.UploadLocalFileReq.tagKeys)
  return _impl_.tagkeys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UploadLocalFileReq::mutable_tagkeys() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.UploadLocalFileReq.tagKeys)
  return &_impl_.tagkeys_;
}

// repeated string tagValues = 12;
inline int UploadLocalFileReq::_internal_tagvalues_size() const {
  return _impl_.tagvalues_.size();
}
inline int UploadLocalFileReq::tagvalues_size() const {
  return _internal_tagvalues_size();
}
inline void UploadLocalFileReq::clear_tagvalues() {
  _impl_.tagvalues_.Clear();
}
inline std::string* UploadLocalFileReq::add_tagvalues() {
  std::string* _s = _internal_add_tagvalues();
  // @@protoc_insertion_point(field_add_mutable:ServerData.UploadLocalFileReq.tagValues)
  return _s;
}
inline const std::string& UploadLocalFileReq::_internal_tagvalues(int index) const {
  return _impl_.tagvalues_.Get(index);
}
inline const std::string& UploadLocalFileReq::tagvalues(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.UploadLocalFileReq.tagValues)
  return _internal_tagvalues(index);
}
inline std::string* UploadLocalFileReq::mutable_tagvalues(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.UploadLocalFileReq.tagValues)
  return _impl_.tagvalues_.Mutable(index);
}
inline void UploadLocalFileReq::set_tagvalues(int index, const std::string& value) {
  _impl_.tagvalues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileReq.tagValues)
}
inline void UploadLocalFileReq::set_tagvalues(int index, std::string&& value) {
  _impl_.tagvalues_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerData.UploadLocalFileReq.tagValues)
}
inline void UploadLocalFileReq::set_tagvalues(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagvalues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerData.UploadLocalFileReq.tagValues)
}
inline void UploadLocalFileReq::set_tagvalues(int index, const char* value, size_t size) {
  _impl_.tagvalues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerData.UploadLocalFileReq.tagValues)
}
inline std::string* UploadLocalFileReq::_internal_add_tagvalues() {
  return _impl_.tagvalues_.Add();
}
inline void UploadLocalFileReq::add_tagvalues(const std::string& value) {
  _impl_.tagvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerData.UploadLocalFileReq.tagValues)
}
inline void UploadLocalFileReq::add_tagvalues(std::string&& value) {
  _impl_.tagvalues_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerData.UploadLocalFileReq.tagValues)
}
inline void UploadLocalFileReq::add_tagvalues(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerData.UploadLocalFileReq.tagValues)
}
inline void UploadLocalFileReq::add_tagvalues(const char* value, size_t size) {
  _impl_.tagvalues_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerData.UploadLocalFileReq.tagValues)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UploadLocalFileReq::tagvalues() const {
  // @@protoc_insertion_point(field_list:ServerData.UploadLocalFileReq.tagValues)
  return _impl_.tagvalues_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UploadLocalFileReq::mutable_tagvalues() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.UploadLocalFileReq.tagValues)
  return &_impl_.tagvalues_;
}

// -------------------------------------------------------------------

// ContentDestinationFolderReq

// int32 reqId = 1;
inline void ContentDestinationFolderReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t ContentDestinationFolderReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t ContentDestinationFolderReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.ContentDestinationFolderReq.reqId)
  return _internal_reqid();
}
inline void ContentDestinationFolderReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void ContentDestinationFolderReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.ContentDestinationFolderReq.reqId)
}

// string folderName = 10;
inline void ContentDestinationFolderReq::clear_foldername() {
  _impl_.foldername_.ClearToEmpty();
}
inline const std::string& ContentDestinationFolderReq::foldername() const {
  // @@protoc_insertion_point(field_get:ServerData.ContentDestinationFolderReq.folderName)
  return _internal_foldername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentDestinationFolderReq::set_foldername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.foldername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ContentDestinationFolderReq.folderName)
}
inline std::string* ContentDestinationFolderReq::mutable_foldername() {
  std::string* _s = _internal_mutable_foldername();
  // @@protoc_insertion_point(field_mutable:ServerData.ContentDestinationFolderReq.folderName)
  return _s;
}
inline const std::string& ContentDestinationFolderReq::_internal_foldername() const {
  return _impl_.foldername_.Get();
}
inline void ContentDestinationFolderReq::_internal_set_foldername(const std::string& value) {
  
  _impl_.foldername_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentDestinationFolderReq::_internal_mutable_foldername() {
  
  return _impl_.foldername_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentDestinationFolderReq::release_foldername() {
  // @@protoc_insertion_point(field_release:ServerData.ContentDestinationFolderReq.folderName)
  return _impl_.foldername_.Release();
}
inline void ContentDestinationFolderReq::set_allocated_foldername(std::string* foldername) {
  if (foldername != nullptr) {
    
  } else {
    
  }
  _impl_.foldername_.SetAllocated(foldername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.foldername_.IsDefault()) {
    _impl_.foldername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ContentDestinationFolderReq.folderName)
}

// -------------------------------------------------------------------

// ContentDestinationFolderResp

// int32 reqId = 1;
inline void ContentDestinationFolderResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t ContentDestinationFolderResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t ContentDestinationFolderResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.ContentDestinationFolderResp.reqId)
  return _internal_reqid();
}
inline void ContentDestinationFolderResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void ContentDestinationFolderResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.ContentDestinationFolderResp.reqId)
}

// string fullFolderName = 10;
inline void ContentDestinationFolderResp::clear_fullfoldername() {
  _impl_.fullfoldername_.ClearToEmpty();
}
inline const std::string& ContentDestinationFolderResp::fullfoldername() const {
  // @@protoc_insertion_point(field_get:ServerData.ContentDestinationFolderResp.fullFolderName)
  return _internal_fullfoldername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentDestinationFolderResp::set_fullfoldername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fullfoldername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ContentDestinationFolderResp.fullFolderName)
}
inline std::string* ContentDestinationFolderResp::mutable_fullfoldername() {
  std::string* _s = _internal_mutable_fullfoldername();
  // @@protoc_insertion_point(field_mutable:ServerData.ContentDestinationFolderResp.fullFolderName)
  return _s;
}
inline const std::string& ContentDestinationFolderResp::_internal_fullfoldername() const {
  return _impl_.fullfoldername_.Get();
}
inline void ContentDestinationFolderResp::_internal_set_fullfoldername(const std::string& value) {
  
  _impl_.fullfoldername_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentDestinationFolderResp::_internal_mutable_fullfoldername() {
  
  return _impl_.fullfoldername_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentDestinationFolderResp::release_fullfoldername() {
  // @@protoc_insertion_point(field_release:ServerData.ContentDestinationFolderResp.fullFolderName)
  return _impl_.fullfoldername_.Release();
}
inline void ContentDestinationFolderResp::set_allocated_fullfoldername(std::string* fullfoldername) {
  if (fullfoldername != nullptr) {
    
  } else {
    
  }
  _impl_.fullfoldername_.SetAllocated(fullfoldername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fullfoldername_.IsDefault()) {
    _impl_.fullfoldername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ContentDestinationFolderResp.fullFolderName)
}

// -------------------------------------------------------------------

// FetchRemoteContentInfoReq

// int32 reqId = 1;
inline void FetchRemoteContentInfoReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t FetchRemoteContentInfoReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t FetchRemoteContentInfoReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchRemoteContentInfoReq.reqId)
  return _internal_reqid();
}
inline void FetchRemoteContentInfoReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void FetchRemoteContentInfoReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.FetchRemoteContentInfoReq.reqId)
}

// string contentId = 10;
inline void FetchRemoteContentInfoReq::clear_contentid() {
  _impl_.contentid_.ClearToEmpty();
}
inline const std::string& FetchRemoteContentInfoReq::contentid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchRemoteContentInfoReq.contentId)
  return _internal_contentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchRemoteContentInfoReq::set_contentid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contentid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.FetchRemoteContentInfoReq.contentId)
}
inline std::string* FetchRemoteContentInfoReq::mutable_contentid() {
  std::string* _s = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchRemoteContentInfoReq.contentId)
  return _s;
}
inline const std::string& FetchRemoteContentInfoReq::_internal_contentid() const {
  return _impl_.contentid_.Get();
}
inline void FetchRemoteContentInfoReq::_internal_set_contentid(const std::string& value) {
  
  _impl_.contentid_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchRemoteContentInfoReq::_internal_mutable_contentid() {
  
  return _impl_.contentid_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchRemoteContentInfoReq::release_contentid() {
  // @@protoc_insertion_point(field_release:ServerData.FetchRemoteContentInfoReq.contentId)
  return _impl_.contentid_.Release();
}
inline void FetchRemoteContentInfoReq::set_allocated_contentid(std::string* contentid) {
  if (contentid != nullptr) {
    
  } else {
    
  }
  _impl_.contentid_.SetAllocated(contentid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contentid_.IsDefault()) {
    _impl_.contentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchRemoteContentInfoReq.contentId)
}

// -------------------------------------------------------------------

// FetchRemoteContentInfoResp

// int32 reqId = 1;
inline void FetchRemoteContentInfoResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t FetchRemoteContentInfoResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t FetchRemoteContentInfoResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchRemoteContentInfoResp.reqId)
  return _internal_reqid();
}
inline void FetchRemoteContentInfoResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void FetchRemoteContentInfoResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.FetchRemoteContentInfoResp.reqId)
}

// .ServerData.CavrnusRemoteContent uploadedContent = 10;
inline bool FetchRemoteContentInfoResp::_internal_has_uploadedcontent() const {
  return this != internal_default_instance() && _impl_.uploadedcontent_ != nullptr;
}
inline bool FetchRemoteContentInfoResp::has_uploadedcontent() const {
  return _internal_has_uploadedcontent();
}
inline const ::ServerData::CavrnusRemoteContent& FetchRemoteContentInfoResp::_internal_uploadedcontent() const {
  const ::ServerData::CavrnusRemoteContent* p = _impl_.uploadedcontent_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusRemoteContent&>(
      ::ServerData::_CavrnusRemoteContent_default_instance_);
}
inline const ::ServerData::CavrnusRemoteContent& FetchRemoteContentInfoResp::uploadedcontent() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchRemoteContentInfoResp.uploadedContent)
  return _internal_uploadedcontent();
}
inline void FetchRemoteContentInfoResp::unsafe_arena_set_allocated_uploadedcontent(
    ::ServerData::CavrnusRemoteContent* uploadedcontent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uploadedcontent_);
  }
  _impl_.uploadedcontent_ = uploadedcontent;
  if (uploadedcontent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.FetchRemoteContentInfoResp.uploadedContent)
}
inline ::ServerData::CavrnusRemoteContent* FetchRemoteContentInfoResp::release_uploadedcontent() {
  
  ::ServerData::CavrnusRemoteContent* temp = _impl_.uploadedcontent_;
  _impl_.uploadedcontent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusRemoteContent* FetchRemoteContentInfoResp::unsafe_arena_release_uploadedcontent() {
  // @@protoc_insertion_point(field_release:ServerData.FetchRemoteContentInfoResp.uploadedContent)
  
  ::ServerData::CavrnusRemoteContent* temp = _impl_.uploadedcontent_;
  _impl_.uploadedcontent_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusRemoteContent* FetchRemoteContentInfoResp::_internal_mutable_uploadedcontent() {
  
  if (_impl_.uploadedcontent_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusRemoteContent>(GetArenaForAllocation());
    _impl_.uploadedcontent_ = p;
  }
  return _impl_.uploadedcontent_;
}
inline ::ServerData::CavrnusRemoteContent* FetchRemoteContentInfoResp::mutable_uploadedcontent() {
  ::ServerData::CavrnusRemoteContent* _msg = _internal_mutable_uploadedcontent();
  // @@protoc_insertion_point(field_mutable:ServerData.FetchRemoteContentInfoResp.uploadedContent)
  return _msg;
}
inline void FetchRemoteContentInfoResp::set_allocated_uploadedcontent(::ServerData::CavrnusRemoteContent* uploadedcontent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uploadedcontent_);
  }
  if (uploadedcontent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uploadedcontent));
    if (message_arena != submessage_arena) {
      uploadedcontent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uploadedcontent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.uploadedcontent_ = uploadedcontent;
  // @@protoc_insertion_point(field_set_allocated:ServerData.FetchRemoteContentInfoResp.uploadedContent)
}

// -------------------------------------------------------------------

// RemoteContentAdded

// .ServerData.CavrnusRemoteContent remoteContent = 1;
inline bool RemoteContentAdded::_internal_has_remotecontent() const {
  return this != internal_default_instance() && _impl_.remotecontent_ != nullptr;
}
inline bool RemoteContentAdded::has_remotecontent() const {
  return _internal_has_remotecontent();
}
inline const ::ServerData::CavrnusRemoteContent& RemoteContentAdded::_internal_remotecontent() const {
  const ::ServerData::CavrnusRemoteContent* p = _impl_.remotecontent_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusRemoteContent&>(
      ::ServerData::_CavrnusRemoteContent_default_instance_);
}
inline const ::ServerData::CavrnusRemoteContent& RemoteContentAdded::remotecontent() const {
  // @@protoc_insertion_point(field_get:ServerData.RemoteContentAdded.remoteContent)
  return _internal_remotecontent();
}
inline void RemoteContentAdded::unsafe_arena_set_allocated_remotecontent(
    ::ServerData::CavrnusRemoteContent* remotecontent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remotecontent_);
  }
  _impl_.remotecontent_ = remotecontent;
  if (remotecontent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.RemoteContentAdded.remoteContent)
}
inline ::ServerData::CavrnusRemoteContent* RemoteContentAdded::release_remotecontent() {
  
  ::ServerData::CavrnusRemoteContent* temp = _impl_.remotecontent_;
  _impl_.remotecontent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusRemoteContent* RemoteContentAdded::unsafe_arena_release_remotecontent() {
  // @@protoc_insertion_point(field_release:ServerData.RemoteContentAdded.remoteContent)
  
  ::ServerData::CavrnusRemoteContent* temp = _impl_.remotecontent_;
  _impl_.remotecontent_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusRemoteContent* RemoteContentAdded::_internal_mutable_remotecontent() {
  
  if (_impl_.remotecontent_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusRemoteContent>(GetArenaForAllocation());
    _impl_.remotecontent_ = p;
  }
  return _impl_.remotecontent_;
}
inline ::ServerData::CavrnusRemoteContent* RemoteContentAdded::mutable_remotecontent() {
  ::ServerData::CavrnusRemoteContent* _msg = _internal_mutable_remotecontent();
  // @@protoc_insertion_point(field_mutable:ServerData.RemoteContentAdded.remoteContent)
  return _msg;
}
inline void RemoteContentAdded::set_allocated_remotecontent(::ServerData::CavrnusRemoteContent* remotecontent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remotecontent_);
  }
  if (remotecontent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(remotecontent));
    if (message_arena != submessage_arena) {
      remotecontent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remotecontent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remotecontent_ = remotecontent;
  // @@protoc_insertion_point(field_set_allocated:ServerData.RemoteContentAdded.remoteContent)
}

// -------------------------------------------------------------------

// RemoteContentRemoved

// string id = 1;
inline void RemoteContentRemoved::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& RemoteContentRemoved::id() const {
  // @@protoc_insertion_point(field_get:ServerData.RemoteContentRemoved.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteContentRemoved::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RemoteContentRemoved.id)
}
inline std::string* RemoteContentRemoved::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ServerData.RemoteContentRemoved.id)
  return _s;
}
inline const std::string& RemoteContentRemoved::_internal_id() const {
  return _impl_.id_.Get();
}
inline void RemoteContentRemoved::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteContentRemoved::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoteContentRemoved::release_id() {
  // @@protoc_insertion_point(field_release:ServerData.RemoteContentRemoved.id)
  return _impl_.id_.Release();
}
inline void RemoteContentRemoved::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RemoteContentRemoved.id)
}

// -------------------------------------------------------------------

// FetchAllUploadedContentResp

// int32 reqId = 1;
inline void FetchAllUploadedContentResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t FetchAllUploadedContentResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t FetchAllUploadedContentResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.FetchAllUploadedContentResp.reqId)
  return _internal_reqid();
}
inline void FetchAllUploadedContentResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void FetchAllUploadedContentResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.FetchAllUploadedContentResp.reqId)
}

// repeated .ServerData.CavrnusRemoteContent availableContent = 10;
inline int FetchAllUploadedContentResp::_internal_availablecontent_size() const {
  return _impl_.availablecontent_.size();
}
inline int FetchAllUploadedContentResp::availablecontent_size() const {
  return _internal_availablecontent_size();
}
inline ::ServerData::CavrnusRemoteContent* FetchAllUploadedContentResp::mutable_availablecontent(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.FetchAllUploadedContentResp.availableContent)
  return _impl_.availablecontent_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRemoteContent >*
FetchAllUploadedContentResp::mutable_availablecontent() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.FetchAllUploadedContentResp.availableContent)
  return &_impl_.availablecontent_;
}
inline const ::ServerData::CavrnusRemoteContent& FetchAllUploadedContentResp::_internal_availablecontent(int index) const {
  return _impl_.availablecontent_.Get(index);
}
inline const ::ServerData::CavrnusRemoteContent& FetchAllUploadedContentResp::availablecontent(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.FetchAllUploadedContentResp.availableContent)
  return _internal_availablecontent(index);
}
inline ::ServerData::CavrnusRemoteContent* FetchAllUploadedContentResp::_internal_add_availablecontent() {
  return _impl_.availablecontent_.Add();
}
inline ::ServerData::CavrnusRemoteContent* FetchAllUploadedContentResp::add_availablecontent() {
  ::ServerData::CavrnusRemoteContent* _add = _internal_add_availablecontent();
  // @@protoc_insertion_point(field_add:ServerData.FetchAllUploadedContentResp.availableContent)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRemoteContent >&
FetchAllUploadedContentResp::availablecontent() const {
  // @@protoc_insertion_point(field_list:ServerData.FetchAllUploadedContentResp.availableContent)
  return _impl_.availablecontent_;
}

// -------------------------------------------------------------------

// PropMetadataStatus

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool PropMetadataStatus::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool PropMetadataStatus::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PropMetadataStatus::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PropMetadataStatus::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PropMetadataStatus.spaceConn)
  return _internal_spaceconn();
}
inline void PropMetadataStatus::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropMetadataStatus.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PropMetadataStatus::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PropMetadataStatus::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PropMetadataStatus.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PropMetadataStatus::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PropMetadataStatus::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PropMetadataStatus.spaceConn)
  return _msg;
}
inline void PropMetadataStatus::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PropMetadataStatus.spaceConn)
}

// .Property.PropertyIdentifier propertyPath = 2;
inline bool PropMetadataStatus::_internal_has_propertypath() const {
  return this != internal_default_instance() && _impl_.propertypath_ != nullptr;
}
inline bool PropMetadataStatus::has_propertypath() const {
  return _internal_has_propertypath();
}
inline const ::Property::PropertyIdentifier& PropMetadataStatus::_internal_propertypath() const {
  const ::Property::PropertyIdentifier* p = _impl_.propertypath_;
  return p != nullptr ? *p : reinterpret_cast<const ::Property::PropertyIdentifier&>(
      ::Property::_PropertyIdentifier_default_instance_);
}
inline const ::Property::PropertyIdentifier& PropMetadataStatus::propertypath() const {
  // @@protoc_insertion_point(field_get:ServerData.PropMetadataStatus.propertyPath)
  return _internal_propertypath();
}
inline void PropMetadataStatus::unsafe_arena_set_allocated_propertypath(
    ::Property::PropertyIdentifier* propertypath) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertypath_);
  }
  _impl_.propertypath_ = propertypath;
  if (propertypath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropMetadataStatus.propertyPath)
}
inline ::Property::PropertyIdentifier* PropMetadataStatus::release_propertypath() {
  
  ::Property::PropertyIdentifier* temp = _impl_.propertypath_;
  _impl_.propertypath_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Property::PropertyIdentifier* PropMetadataStatus::unsafe_arena_release_propertypath() {
  // @@protoc_insertion_point(field_release:ServerData.PropMetadataStatus.propertyPath)
  
  ::Property::PropertyIdentifier* temp = _impl_.propertypath_;
  _impl_.propertypath_ = nullptr;
  return temp;
}
inline ::Property::PropertyIdentifier* PropMetadataStatus::_internal_mutable_propertypath() {
  
  if (_impl_.propertypath_ == nullptr) {
    auto* p = CreateMaybeMessage<::Property::PropertyIdentifier>(GetArenaForAllocation());
    _impl_.propertypath_ = p;
  }
  return _impl_.propertypath_;
}
inline ::Property::PropertyIdentifier* PropMetadataStatus::mutable_propertypath() {
  ::Property::PropertyIdentifier* _msg = _internal_mutable_propertypath();
  // @@protoc_insertion_point(field_mutable:ServerData.PropMetadataStatus.propertyPath)
  return _msg;
}
inline void PropMetadataStatus::set_allocated_propertypath(::Property::PropertyIdentifier* propertypath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertypath_);
  }
  if (propertypath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(propertypath));
    if (message_arena != submessage_arena) {
      propertypath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertypath, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertypath_ = propertypath;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PropMetadataStatus.propertyPath)
}

// bool isReadonly = 10;
inline void PropMetadataStatus::clear_isreadonly() {
  _impl_.isreadonly_ = false;
}
inline bool PropMetadataStatus::_internal_isreadonly() const {
  return _impl_.isreadonly_;
}
inline bool PropMetadataStatus::isreadonly() const {
  // @@protoc_insertion_point(field_get:ServerData.PropMetadataStatus.isReadonly)
  return _internal_isreadonly();
}
inline void PropMetadataStatus::_internal_set_isreadonly(bool value) {
  
  _impl_.isreadonly_ = value;
}
inline void PropMetadataStatus::set_isreadonly(bool value) {
  _internal_set_isreadonly(value);
  // @@protoc_insertion_point(field_set:ServerData.PropMetadataStatus.isReadonly)
}

// -------------------------------------------------------------------

// PropertyValueStatus

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool PropertyValueStatus::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool PropertyValueStatus::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PropertyValueStatus::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PropertyValueStatus::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValueStatus.spaceConn)
  return _internal_spaceconn();
}
inline void PropertyValueStatus::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropertyValueStatus.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PropertyValueStatus::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PropertyValueStatus::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValueStatus.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PropertyValueStatus::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PropertyValueStatus::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValueStatus.spaceConn)
  return _msg;
}
inline void PropertyValueStatus::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PropertyValueStatus.spaceConn)
}

// .Property.PropertyIdentifier propertyPath = 2;
inline bool PropertyValueStatus::_internal_has_propertypath() const {
  return this != internal_default_instance() && _impl_.propertypath_ != nullptr;
}
inline bool PropertyValueStatus::has_propertypath() const {
  return _internal_has_propertypath();
}
inline const ::Property::PropertyIdentifier& PropertyValueStatus::_internal_propertypath() const {
  const ::Property::PropertyIdentifier* p = _impl_.propertypath_;
  return p != nullptr ? *p : reinterpret_cast<const ::Property::PropertyIdentifier&>(
      ::Property::_PropertyIdentifier_default_instance_);
}
inline const ::Property::PropertyIdentifier& PropertyValueStatus::propertypath() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValueStatus.propertyPath)
  return _internal_propertypath();
}
inline void PropertyValueStatus::unsafe_arena_set_allocated_propertypath(
    ::Property::PropertyIdentifier* propertypath) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertypath_);
  }
  _impl_.propertypath_ = propertypath;
  if (propertypath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropertyValueStatus.propertyPath)
}
inline ::Property::PropertyIdentifier* PropertyValueStatus::release_propertypath() {
  
  ::Property::PropertyIdentifier* temp = _impl_.propertypath_;
  _impl_.propertypath_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Property::PropertyIdentifier* PropertyValueStatus::unsafe_arena_release_propertypath() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValueStatus.propertyPath)
  
  ::Property::PropertyIdentifier* temp = _impl_.propertypath_;
  _impl_.propertypath_ = nullptr;
  return temp;
}
inline ::Property::PropertyIdentifier* PropertyValueStatus::_internal_mutable_propertypath() {
  
  if (_impl_.propertypath_ == nullptr) {
    auto* p = CreateMaybeMessage<::Property::PropertyIdentifier>(GetArenaForAllocation());
    _impl_.propertypath_ = p;
  }
  return _impl_.propertypath_;
}
inline ::Property::PropertyIdentifier* PropertyValueStatus::mutable_propertypath() {
  ::Property::PropertyIdentifier* _msg = _internal_mutable_propertypath();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValueStatus.propertyPath)
  return _msg;
}
inline void PropertyValueStatus::set_allocated_propertypath(::Property::PropertyIdentifier* propertypath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertypath_);
  }
  if (propertypath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(propertypath));
    if (message_arena != submessage_arena) {
      propertypath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertypath, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertypath_ = propertypath;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PropertyValueStatus.propertyPath)
}

// .ServerData.PropertyValue PropertyValue = 10;
inline bool PropertyValueStatus::_internal_has_propertyvalue() const {
  return this != internal_default_instance() && _impl_.propertyvalue_ != nullptr;
}
inline bool PropertyValueStatus::has_propertyvalue() const {
  return _internal_has_propertyvalue();
}
inline void PropertyValueStatus::clear_propertyvalue() {
  if (GetArenaForAllocation() == nullptr && _impl_.propertyvalue_ != nullptr) {
    delete _impl_.propertyvalue_;
  }
  _impl_.propertyvalue_ = nullptr;
}
inline const ::ServerData::PropertyValue& PropertyValueStatus::_internal_propertyvalue() const {
  const ::ServerData::PropertyValue* p = _impl_.propertyvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::PropertyValue&>(
      ::ServerData::_PropertyValue_default_instance_);
}
inline const ::ServerData::PropertyValue& PropertyValueStatus::propertyvalue() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValueStatus.PropertyValue)
  return _internal_propertyvalue();
}
inline void PropertyValueStatus::unsafe_arena_set_allocated_propertyvalue(
    ::ServerData::PropertyValue* propertyvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertyvalue_);
  }
  _impl_.propertyvalue_ = propertyvalue;
  if (propertyvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PropertyValueStatus.PropertyValue)
}
inline ::ServerData::PropertyValue* PropertyValueStatus::release_propertyvalue() {
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::PropertyValue* PropertyValueStatus::unsafe_arena_release_propertyvalue() {
  // @@protoc_insertion_point(field_release:ServerData.PropertyValueStatus.PropertyValue)
  
  ::ServerData::PropertyValue* temp = _impl_.propertyvalue_;
  _impl_.propertyvalue_ = nullptr;
  return temp;
}
inline ::ServerData::PropertyValue* PropertyValueStatus::_internal_mutable_propertyvalue() {
  
  if (_impl_.propertyvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::PropertyValue>(GetArenaForAllocation());
    _impl_.propertyvalue_ = p;
  }
  return _impl_.propertyvalue_;
}
inline ::ServerData::PropertyValue* PropertyValueStatus::mutable_propertyvalue() {
  ::ServerData::PropertyValue* _msg = _internal_mutable_propertyvalue();
  // @@protoc_insertion_point(field_mutable:ServerData.PropertyValueStatus.PropertyValue)
  return _msg;
}
inline void PropertyValueStatus::set_allocated_propertyvalue(::ServerData::PropertyValue* propertyvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.propertyvalue_;
  }
  if (propertyvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(propertyvalue);
    if (message_arena != submessage_arena) {
      propertyvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertyvalue, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertyvalue_ = propertyvalue;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PropertyValueStatus.PropertyValue)
}

// int32 priority = 11;
inline void PropertyValueStatus::clear_priority() {
  _impl_.priority_ = 0;
}
inline int32_t PropertyValueStatus::_internal_priority() const {
  return _impl_.priority_;
}
inline int32_t PropertyValueStatus::priority() const {
  // @@protoc_insertion_point(field_get:ServerData.PropertyValueStatus.priority)
  return _internal_priority();
}
inline void PropertyValueStatus::_internal_set_priority(int32_t value) {
  
  _impl_.priority_ = value;
}
inline void PropertyValueStatus::set_priority(int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:ServerData.PropertyValueStatus.priority)
}

// -------------------------------------------------------------------

// LocalPropertyHandledResp

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool LocalPropertyHandledResp::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool LocalPropertyHandledResp::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& LocalPropertyHandledResp::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& LocalPropertyHandledResp::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.LocalPropertyHandledResp.spaceConn)
  return _internal_spaceconn();
}
inline void LocalPropertyHandledResp::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.LocalPropertyHandledResp.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* LocalPropertyHandledResp::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* LocalPropertyHandledResp::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.LocalPropertyHandledResp.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* LocalPropertyHandledResp::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* LocalPropertyHandledResp::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.LocalPropertyHandledResp.spaceConn)
  return _msg;
}
inline void LocalPropertyHandledResp::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.LocalPropertyHandledResp.spaceConn)
}

// .Property.PropertyIdentifier propertyPath = 2;
inline bool LocalPropertyHandledResp::_internal_has_propertypath() const {
  return this != internal_default_instance() && _impl_.propertypath_ != nullptr;
}
inline bool LocalPropertyHandledResp::has_propertypath() const {
  return _internal_has_propertypath();
}
inline const ::Property::PropertyIdentifier& LocalPropertyHandledResp::_internal_propertypath() const {
  const ::Property::PropertyIdentifier* p = _impl_.propertypath_;
  return p != nullptr ? *p : reinterpret_cast<const ::Property::PropertyIdentifier&>(
      ::Property::_PropertyIdentifier_default_instance_);
}
inline const ::Property::PropertyIdentifier& LocalPropertyHandledResp::propertypath() const {
  // @@protoc_insertion_point(field_get:ServerData.LocalPropertyHandledResp.propertyPath)
  return _internal_propertypath();
}
inline void LocalPropertyHandledResp::unsafe_arena_set_allocated_propertypath(
    ::Property::PropertyIdentifier* propertypath) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertypath_);
  }
  _impl_.propertypath_ = propertypath;
  if (propertypath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.LocalPropertyHandledResp.propertyPath)
}
inline ::Property::PropertyIdentifier* LocalPropertyHandledResp::release_propertypath() {
  
  ::Property::PropertyIdentifier* temp = _impl_.propertypath_;
  _impl_.propertypath_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Property::PropertyIdentifier* LocalPropertyHandledResp::unsafe_arena_release_propertypath() {
  // @@protoc_insertion_point(field_release:ServerData.LocalPropertyHandledResp.propertyPath)
  
  ::Property::PropertyIdentifier* temp = _impl_.propertypath_;
  _impl_.propertypath_ = nullptr;
  return temp;
}
inline ::Property::PropertyIdentifier* LocalPropertyHandledResp::_internal_mutable_propertypath() {
  
  if (_impl_.propertypath_ == nullptr) {
    auto* p = CreateMaybeMessage<::Property::PropertyIdentifier>(GetArenaForAllocation());
    _impl_.propertypath_ = p;
  }
  return _impl_.propertypath_;
}
inline ::Property::PropertyIdentifier* LocalPropertyHandledResp::mutable_propertypath() {
  ::Property::PropertyIdentifier* _msg = _internal_mutable_propertypath();
  // @@protoc_insertion_point(field_mutable:ServerData.LocalPropertyHandledResp.propertyPath)
  return _msg;
}
inline void LocalPropertyHandledResp::set_allocated_propertypath(::Property::PropertyIdentifier* propertypath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propertypath_);
  }
  if (propertypath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(propertypath));
    if (message_arena != submessage_arena) {
      propertypath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propertypath, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.propertypath_ = propertypath;
  // @@protoc_insertion_point(field_set_allocated:ServerData.LocalPropertyHandledResp.propertyPath)
}

// int32 localPropChangeId = 10;
inline void LocalPropertyHandledResp::clear_localpropchangeid() {
  _impl_.localpropchangeid_ = 0;
}
inline int32_t LocalPropertyHandledResp::_internal_localpropchangeid() const {
  return _impl_.localpropchangeid_;
}
inline int32_t LocalPropertyHandledResp::localpropchangeid() const {
  // @@protoc_insertion_point(field_get:ServerData.LocalPropertyHandledResp.localPropChangeId)
  return _internal_localpropchangeid();
}
inline void LocalPropertyHandledResp::_internal_set_localpropchangeid(int32_t value) {
  
  _impl_.localpropchangeid_ = value;
}
inline void LocalPropertyHandledResp::set_localpropchangeid(int32_t value) {
  _internal_set_localpropchangeid(value);
  // @@protoc_insertion_point(field_set:ServerData.LocalPropertyHandledResp.localPropChangeId)
}

// -------------------------------------------------------------------

// UserAdded

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool UserAdded::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool UserAdded::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& UserAdded::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& UserAdded::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.UserAdded.spaceConn)
  return _internal_spaceconn();
}
inline void UserAdded::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UserAdded.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* UserAdded::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UserAdded::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.UserAdded.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UserAdded::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* UserAdded::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.UserAdded.spaceConn)
  return _msg;
}
inline void UserAdded::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UserAdded.spaceConn)
}

// .ServerData.CavrnusUser user = 2;
inline bool UserAdded::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool UserAdded::has_user() const {
  return _internal_has_user();
}
inline const ::ServerData::CavrnusUser& UserAdded::_internal_user() const {
  const ::ServerData::CavrnusUser* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusUser&>(
      ::ServerData::_CavrnusUser_default_instance_);
}
inline const ::ServerData::CavrnusUser& UserAdded::user() const {
  // @@protoc_insertion_point(field_get:ServerData.UserAdded.user)
  return _internal_user();
}
inline void UserAdded::unsafe_arena_set_allocated_user(
    ::ServerData::CavrnusUser* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UserAdded.user)
}
inline ::ServerData::CavrnusUser* UserAdded::release_user() {
  
  ::ServerData::CavrnusUser* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusUser* UserAdded::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:ServerData.UserAdded.user)
  
  ::ServerData::CavrnusUser* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusUser* UserAdded::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusUser>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::ServerData::CavrnusUser* UserAdded::mutable_user() {
  ::ServerData::CavrnusUser* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:ServerData.UserAdded.user)
  return _msg;
}
inline void UserAdded::set_allocated_user(::ServerData::CavrnusUser* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user));
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UserAdded.user)
}

// -------------------------------------------------------------------

// UserRemoved

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool UserRemoved::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool UserRemoved::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& UserRemoved::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& UserRemoved::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.UserRemoved.spaceConn)
  return _internal_spaceconn();
}
inline void UserRemoved::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UserRemoved.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* UserRemoved::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UserRemoved::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.UserRemoved.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UserRemoved::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* UserRemoved::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.UserRemoved.spaceConn)
  return _msg;
}
inline void UserRemoved::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UserRemoved.spaceConn)
}

// string userId = 2;
inline void UserRemoved::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& UserRemoved::userid() const {
  // @@protoc_insertion_point(field_get:ServerData.UserRemoved.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRemoved::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.UserRemoved.userId)
}
inline std::string* UserRemoved::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:ServerData.UserRemoved.userId)
  return _s;
}
inline const std::string& UserRemoved::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void UserRemoved::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRemoved::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRemoved::release_userid() {
  // @@protoc_insertion_point(field_release:ServerData.UserRemoved.userId)
  return _impl_.userid_.Release();
}
inline void UserRemoved::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.UserRemoved.userId)
}

// -------------------------------------------------------------------

// UserVideoFrame

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool UserVideoFrame::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool UserVideoFrame::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& UserVideoFrame::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& UserVideoFrame::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.UserVideoFrame.spaceConn)
  return _internal_spaceconn();
}
inline void UserVideoFrame::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UserVideoFrame.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* UserVideoFrame::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UserVideoFrame::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.UserVideoFrame.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UserVideoFrame::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* UserVideoFrame::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.UserVideoFrame.spaceConn)
  return _msg;
}
inline void UserVideoFrame::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UserVideoFrame.spaceConn)
}

// string userId = 2;
inline void UserVideoFrame::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& UserVideoFrame::userid() const {
  // @@protoc_insertion_point(field_get:ServerData.UserVideoFrame.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserVideoFrame::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.UserVideoFrame.userId)
}
inline std::string* UserVideoFrame::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:ServerData.UserVideoFrame.userId)
  return _s;
}
inline const std::string& UserVideoFrame::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void UserVideoFrame::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserVideoFrame::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserVideoFrame::release_userid() {
  // @@protoc_insertion_point(field_release:ServerData.UserVideoFrame.userId)
  return _impl_.userid_.Release();
}
inline void UserVideoFrame::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.UserVideoFrame.userId)
}

// int32 resX = 10;
inline void UserVideoFrame::clear_resx() {
  _impl_.resx_ = 0;
}
inline int32_t UserVideoFrame::_internal_resx() const {
  return _impl_.resx_;
}
inline int32_t UserVideoFrame::resx() const {
  // @@protoc_insertion_point(field_get:ServerData.UserVideoFrame.resX)
  return _internal_resx();
}
inline void UserVideoFrame::_internal_set_resx(int32_t value) {
  
  _impl_.resx_ = value;
}
inline void UserVideoFrame::set_resx(int32_t value) {
  _internal_set_resx(value);
  // @@protoc_insertion_point(field_set:ServerData.UserVideoFrame.resX)
}

// int32 resY = 11;
inline void UserVideoFrame::clear_resy() {
  _impl_.resy_ = 0;
}
inline int32_t UserVideoFrame::_internal_resy() const {
  return _impl_.resy_;
}
inline int32_t UserVideoFrame::resy() const {
  // @@protoc_insertion_point(field_get:ServerData.UserVideoFrame.resY)
  return _internal_resy();
}
inline void UserVideoFrame::_internal_set_resy(int32_t value) {
  
  _impl_.resy_ = value;
}
inline void UserVideoFrame::set_resy(int32_t value) {
  _internal_set_resy(value);
  // @@protoc_insertion_point(field_set:ServerData.UserVideoFrame.resY)
}

// bytes stream = 20;
inline void UserVideoFrame::clear_stream() {
  _impl_.stream_.ClearToEmpty();
}
inline const std::string& UserVideoFrame::stream() const {
  // @@protoc_insertion_point(field_get:ServerData.UserVideoFrame.stream)
  return _internal_stream();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserVideoFrame::set_stream(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stream_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.UserVideoFrame.stream)
}
inline std::string* UserVideoFrame::mutable_stream() {
  std::string* _s = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:ServerData.UserVideoFrame.stream)
  return _s;
}
inline const std::string& UserVideoFrame::_internal_stream() const {
  return _impl_.stream_.Get();
}
inline void UserVideoFrame::_internal_set_stream(const std::string& value) {
  
  _impl_.stream_.Set(value, GetArenaForAllocation());
}
inline std::string* UserVideoFrame::_internal_mutable_stream() {
  
  return _impl_.stream_.Mutable(GetArenaForAllocation());
}
inline std::string* UserVideoFrame::release_stream() {
  // @@protoc_insertion_point(field_release:ServerData.UserVideoFrame.stream)
  return _impl_.stream_.Release();
}
inline void UserVideoFrame::set_allocated_stream(std::string* stream) {
  if (stream != nullptr) {
    
  } else {
    
  }
  _impl_.stream_.SetAllocated(stream, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_.IsDefault()) {
    _impl_.stream_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.UserVideoFrame.stream)
}

// -------------------------------------------------------------------

// ObjectAdded

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool ObjectAdded::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool ObjectAdded::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& ObjectAdded::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ObjectAdded::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.ObjectAdded.spaceConn)
  return _internal_spaceconn();
}
inline void ObjectAdded::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ObjectAdded.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* ObjectAdded::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ObjectAdded::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.ObjectAdded.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ObjectAdded::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* ObjectAdded::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.ObjectAdded.spaceConn)
  return _msg;
}
inline void ObjectAdded::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ObjectAdded.spaceConn)
}

// string propertiesContainer = 3;
inline void ObjectAdded::clear_propertiescontainer() {
  _impl_.propertiescontainer_.ClearToEmpty();
}
inline const std::string& ObjectAdded::propertiescontainer() const {
  // @@protoc_insertion_point(field_get:ServerData.ObjectAdded.propertiesContainer)
  return _internal_propertiescontainer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectAdded::set_propertiescontainer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.propertiescontainer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ObjectAdded.propertiesContainer)
}
inline std::string* ObjectAdded::mutable_propertiescontainer() {
  std::string* _s = _internal_mutable_propertiescontainer();
  // @@protoc_insertion_point(field_mutable:ServerData.ObjectAdded.propertiesContainer)
  return _s;
}
inline const std::string& ObjectAdded::_internal_propertiescontainer() const {
  return _impl_.propertiescontainer_.Get();
}
inline void ObjectAdded::_internal_set_propertiescontainer(const std::string& value) {
  
  _impl_.propertiescontainer_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectAdded::_internal_mutable_propertiescontainer() {
  
  return _impl_.propertiescontainer_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectAdded::release_propertiescontainer() {
  // @@protoc_insertion_point(field_release:ServerData.ObjectAdded.propertiesContainer)
  return _impl_.propertiescontainer_.Release();
}
inline void ObjectAdded::set_allocated_propertiescontainer(std::string* propertiescontainer) {
  if (propertiescontainer != nullptr) {
    
  } else {
    
  }
  _impl_.propertiescontainer_.SetAllocated(propertiescontainer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propertiescontainer_.IsDefault()) {
    _impl_.propertiescontainer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ObjectAdded.propertiesContainer)
}

// string objectCreated = 4;
inline void ObjectAdded::clear_objectcreated() {
  _impl_.objectcreated_.ClearToEmpty();
}
inline const std::string& ObjectAdded::objectcreated() const {
  // @@protoc_insertion_point(field_get:ServerData.ObjectAdded.objectCreated)
  return _internal_objectcreated();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectAdded::set_objectcreated(ArgT0&& arg0, ArgT... args) {
 
 _impl_.objectcreated_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ObjectAdded.objectCreated)
}
inline std::string* ObjectAdded::mutable_objectcreated() {
  std::string* _s = _internal_mutable_objectcreated();
  // @@protoc_insertion_point(field_mutable:ServerData.ObjectAdded.objectCreated)
  return _s;
}
inline const std::string& ObjectAdded::_internal_objectcreated() const {
  return _impl_.objectcreated_.Get();
}
inline void ObjectAdded::_internal_set_objectcreated(const std::string& value) {
  
  _impl_.objectcreated_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectAdded::_internal_mutable_objectcreated() {
  
  return _impl_.objectcreated_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectAdded::release_objectcreated() {
  // @@protoc_insertion_point(field_release:ServerData.ObjectAdded.objectCreated)
  return _impl_.objectcreated_.Release();
}
inline void ObjectAdded::set_allocated_objectcreated(std::string* objectcreated) {
  if (objectcreated != nullptr) {
    
  } else {
    
  }
  _impl_.objectcreated_.SetAllocated(objectcreated, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.objectcreated_.IsDefault()) {
    _impl_.objectcreated_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ObjectAdded.objectCreated)
}

// .google.protobuf.Timestamp createdTime = 5;
inline bool ObjectAdded::_internal_has_createdtime() const {
  return this != internal_default_instance() && _impl_.createdtime_ != nullptr;
}
inline bool ObjectAdded::has_createdtime() const {
  return _internal_has_createdtime();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ObjectAdded::_internal_createdtime() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.createdtime_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ObjectAdded::createdtime() const {
  // @@protoc_insertion_point(field_get:ServerData.ObjectAdded.createdTime)
  return _internal_createdtime();
}
inline void ObjectAdded::unsafe_arena_set_allocated_createdtime(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.createdtime_);
  }
  _impl_.createdtime_ = createdtime;
  if (createdtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ObjectAdded.createdTime)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ObjectAdded::release_createdtime() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.createdtime_;
  _impl_.createdtime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ObjectAdded::unsafe_arena_release_createdtime() {
  // @@protoc_insertion_point(field_release:ServerData.ObjectAdded.createdTime)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.createdtime_;
  _impl_.createdtime_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ObjectAdded::_internal_mutable_createdtime() {
  
  if (_impl_.createdtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.createdtime_ = p;
  }
  return _impl_.createdtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ObjectAdded::mutable_createdtime() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_createdtime();
  // @@protoc_insertion_point(field_mutable:ServerData.ObjectAdded.createdTime)
  return _msg;
}
inline void ObjectAdded::set_allocated_createdtime(::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.createdtime_);
  }
  if (createdtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(createdtime));
    if (message_arena != submessage_arena) {
      createdtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, createdtime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.createdtime_ = createdtime;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ObjectAdded.createdTime)
}

// -------------------------------------------------------------------

// ObjectRemoved

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool ObjectRemoved::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool ObjectRemoved::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& ObjectRemoved::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ObjectRemoved::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.ObjectRemoved.spaceConn)
  return _internal_spaceconn();
}
inline void ObjectRemoved::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ObjectRemoved.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* ObjectRemoved::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ObjectRemoved::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.ObjectRemoved.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ObjectRemoved::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* ObjectRemoved::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.ObjectRemoved.spaceConn)
  return _msg;
}
inline void ObjectRemoved::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ObjectRemoved.spaceConn)
}

// string propertiesContainer = 3;
inline void ObjectRemoved::clear_propertiescontainer() {
  _impl_.propertiescontainer_.ClearToEmpty();
}
inline const std::string& ObjectRemoved::propertiescontainer() const {
  // @@protoc_insertion_point(field_get:ServerData.ObjectRemoved.propertiesContainer)
  return _internal_propertiescontainer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectRemoved::set_propertiescontainer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.propertiescontainer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ObjectRemoved.propertiesContainer)
}
inline std::string* ObjectRemoved::mutable_propertiescontainer() {
  std::string* _s = _internal_mutable_propertiescontainer();
  // @@protoc_insertion_point(field_mutable:ServerData.ObjectRemoved.propertiesContainer)
  return _s;
}
inline const std::string& ObjectRemoved::_internal_propertiescontainer() const {
  return _impl_.propertiescontainer_.Get();
}
inline void ObjectRemoved::_internal_set_propertiescontainer(const std::string& value) {
  
  _impl_.propertiescontainer_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectRemoved::_internal_mutable_propertiescontainer() {
  
  return _impl_.propertiescontainer_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectRemoved::release_propertiescontainer() {
  // @@protoc_insertion_point(field_release:ServerData.ObjectRemoved.propertiesContainer)
  return _impl_.propertiescontainer_.Release();
}
inline void ObjectRemoved::set_allocated_propertiescontainer(std::string* propertiescontainer) {
  if (propertiescontainer != nullptr) {
    
  } else {
    
  }
  _impl_.propertiescontainer_.SetAllocated(propertiescontainer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propertiescontainer_.IsDefault()) {
    _impl_.propertiescontainer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ObjectRemoved.propertiesContainer)
}

// -------------------------------------------------------------------

// UpdateLocalUserMuted

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool UpdateLocalUserMuted::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool UpdateLocalUserMuted::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& UpdateLocalUserMuted::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& UpdateLocalUserMuted::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateLocalUserMuted.spaceConn)
  return _internal_spaceconn();
}
inline void UpdateLocalUserMuted::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UpdateLocalUserMuted.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserMuted::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserMuted::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.UpdateLocalUserMuted.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserMuted::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserMuted::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.UpdateLocalUserMuted.spaceConn)
  return _msg;
}
inline void UpdateLocalUserMuted::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UpdateLocalUserMuted.spaceConn)
}

// bool muted = 2;
inline void UpdateLocalUserMuted::clear_muted() {
  _impl_.muted_ = false;
}
inline bool UpdateLocalUserMuted::_internal_muted() const {
  return _impl_.muted_;
}
inline bool UpdateLocalUserMuted::muted() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateLocalUserMuted.muted)
  return _internal_muted();
}
inline void UpdateLocalUserMuted::_internal_set_muted(bool value) {
  
  _impl_.muted_ = value;
}
inline void UpdateLocalUserMuted::set_muted(bool value) {
  _internal_set_muted(value);
  // @@protoc_insertion_point(field_set:ServerData.UpdateLocalUserMuted.muted)
}

// -------------------------------------------------------------------

// UpdateLocalUserCoPresence

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool UpdateLocalUserCoPresence::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool UpdateLocalUserCoPresence::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& UpdateLocalUserCoPresence::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& UpdateLocalUserCoPresence::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateLocalUserCoPresence.spaceConn)
  return _internal_spaceconn();
}
inline void UpdateLocalUserCoPresence::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UpdateLocalUserCoPresence.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserCoPresence::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserCoPresence::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.UpdateLocalUserCoPresence.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserCoPresence::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserCoPresence::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.UpdateLocalUserCoPresence.spaceConn)
  return _msg;
}
inline void UpdateLocalUserCoPresence::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UpdateLocalUserCoPresence.spaceConn)
}

// .ServerData.TransformPropertyValue localUserRootTransform = 10;
inline bool UpdateLocalUserCoPresence::_internal_has_localuserroottransform() const {
  return this != internal_default_instance() && _impl_.localuserroottransform_ != nullptr;
}
inline bool UpdateLocalUserCoPresence::has_localuserroottransform() const {
  return _internal_has_localuserroottransform();
}
inline void UpdateLocalUserCoPresence::clear_localuserroottransform() {
  if (GetArenaForAllocation() == nullptr && _impl_.localuserroottransform_ != nullptr) {
    delete _impl_.localuserroottransform_;
  }
  _impl_.localuserroottransform_ = nullptr;
}
inline const ::ServerData::TransformPropertyValue& UpdateLocalUserCoPresence::_internal_localuserroottransform() const {
  const ::ServerData::TransformPropertyValue* p = _impl_.localuserroottransform_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::TransformPropertyValue&>(
      ::ServerData::_TransformPropertyValue_default_instance_);
}
inline const ::ServerData::TransformPropertyValue& UpdateLocalUserCoPresence::localuserroottransform() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateLocalUserCoPresence.localUserRootTransform)
  return _internal_localuserroottransform();
}
inline void UpdateLocalUserCoPresence::unsafe_arena_set_allocated_localuserroottransform(
    ::ServerData::TransformPropertyValue* localuserroottransform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.localuserroottransform_);
  }
  _impl_.localuserroottransform_ = localuserroottransform;
  if (localuserroottransform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UpdateLocalUserCoPresence.localUserRootTransform)
}
inline ::ServerData::TransformPropertyValue* UpdateLocalUserCoPresence::release_localuserroottransform() {
  
  ::ServerData::TransformPropertyValue* temp = _impl_.localuserroottransform_;
  _impl_.localuserroottransform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::TransformPropertyValue* UpdateLocalUserCoPresence::unsafe_arena_release_localuserroottransform() {
  // @@protoc_insertion_point(field_release:ServerData.UpdateLocalUserCoPresence.localUserRootTransform)
  
  ::ServerData::TransformPropertyValue* temp = _impl_.localuserroottransform_;
  _impl_.localuserroottransform_ = nullptr;
  return temp;
}
inline ::ServerData::TransformPropertyValue* UpdateLocalUserCoPresence::_internal_mutable_localuserroottransform() {
  
  if (_impl_.localuserroottransform_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::TransformPropertyValue>(GetArenaForAllocation());
    _impl_.localuserroottransform_ = p;
  }
  return _impl_.localuserroottransform_;
}
inline ::ServerData::TransformPropertyValue* UpdateLocalUserCoPresence::mutable_localuserroottransform() {
  ::ServerData::TransformPropertyValue* _msg = _internal_mutable_localuserroottransform();
  // @@protoc_insertion_point(field_mutable:ServerData.UpdateLocalUserCoPresence.localUserRootTransform)
  return _msg;
}
inline void UpdateLocalUserCoPresence::set_allocated_localuserroottransform(::ServerData::TransformPropertyValue* localuserroottransform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.localuserroottransform_;
  }
  if (localuserroottransform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(localuserroottransform);
    if (message_arena != submessage_arena) {
      localuserroottransform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, localuserroottransform, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.localuserroottransform_ = localuserroottransform;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UpdateLocalUserCoPresence.localUserRootTransform)
}

// -------------------------------------------------------------------

// UpdateLocalUserStreamState

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool UpdateLocalUserStreamState::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool UpdateLocalUserStreamState::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& UpdateLocalUserStreamState::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& UpdateLocalUserStreamState::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateLocalUserStreamState.spaceConn)
  return _internal_spaceconn();
}
inline void UpdateLocalUserStreamState::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.UpdateLocalUserStreamState.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserStreamState::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserStreamState::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.UpdateLocalUserStreamState.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserStreamState::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* UpdateLocalUserStreamState::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.UpdateLocalUserStreamState.spaceConn)
  return _msg;
}
inline void UpdateLocalUserStreamState::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.UpdateLocalUserStreamState.spaceConn)
}

// bool streaming = 2;
inline void UpdateLocalUserStreamState::clear_streaming() {
  _impl_.streaming_ = false;
}
inline bool UpdateLocalUserStreamState::_internal_streaming() const {
  return _impl_.streaming_;
}
inline bool UpdateLocalUserStreamState::streaming() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateLocalUserStreamState.streaming)
  return _internal_streaming();
}
inline void UpdateLocalUserStreamState::_internal_set_streaming(bool value) {
  
  _impl_.streaming_ = value;
}
inline void UpdateLocalUserStreamState::set_streaming(bool value) {
  _internal_set_streaming(value);
  // @@protoc_insertion_point(field_set:ServerData.UpdateLocalUserStreamState.streaming)
}

// -------------------------------------------------------------------

// PermissionStatusReq

// optional .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool PermissionStatusReq::_internal_has_spaceconn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spaceconn_ != nullptr);
  return value;
}
inline bool PermissionStatusReq::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PermissionStatusReq::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PermissionStatusReq::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PermissionStatusReq.spaceConn)
  return _internal_spaceconn();
}
inline void PermissionStatusReq::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PermissionStatusReq.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatusReq::release_spaceconn() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatusReq::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PermissionStatusReq.spaceConn)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatusReq::_internal_mutable_spaceconn() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatusReq::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PermissionStatusReq.spaceConn)
  return _msg;
}
inline void PermissionStatusReq::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PermissionStatusReq.spaceConn)
}

// string permission = 2;
inline void PermissionStatusReq::clear_permission() {
  _impl_.permission_.ClearToEmpty();
}
inline const std::string& PermissionStatusReq::permission() const {
  // @@protoc_insertion_point(field_get:ServerData.PermissionStatusReq.permission)
  return _internal_permission();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PermissionStatusReq::set_permission(ArgT0&& arg0, ArgT... args) {
 
 _impl_.permission_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PermissionStatusReq.permission)
}
inline std::string* PermissionStatusReq::mutable_permission() {
  std::string* _s = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:ServerData.PermissionStatusReq.permission)
  return _s;
}
inline const std::string& PermissionStatusReq::_internal_permission() const {
  return _impl_.permission_.Get();
}
inline void PermissionStatusReq::_internal_set_permission(const std::string& value) {
  
  _impl_.permission_.Set(value, GetArenaForAllocation());
}
inline std::string* PermissionStatusReq::_internal_mutable_permission() {
  
  return _impl_.permission_.Mutable(GetArenaForAllocation());
}
inline std::string* PermissionStatusReq::release_permission() {
  // @@protoc_insertion_point(field_release:ServerData.PermissionStatusReq.permission)
  return _impl_.permission_.Release();
}
inline void PermissionStatusReq::set_allocated_permission(std::string* permission) {
  if (permission != nullptr) {
    
  } else {
    
  }
  _impl_.permission_.SetAllocated(permission, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.permission_.IsDefault()) {
    _impl_.permission_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.PermissionStatusReq.permission)
}

// -------------------------------------------------------------------

// PermissionStatus

// optional .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool PermissionStatus::_internal_has_spaceconn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spaceconn_ != nullptr);
  return value;
}
inline bool PermissionStatus::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PermissionStatus::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PermissionStatus::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PermissionStatus.spaceConn)
  return _internal_spaceconn();
}
inline void PermissionStatus::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PermissionStatus.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatus::release_spaceconn() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatus::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PermissionStatus.spaceConn)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatus::_internal_mutable_spaceconn() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PermissionStatus::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PermissionStatus.spaceConn)
  return _msg;
}
inline void PermissionStatus::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PermissionStatus.spaceConn)
}

// string permission = 2;
inline void PermissionStatus::clear_permission() {
  _impl_.permission_.ClearToEmpty();
}
inline const std::string& PermissionStatus::permission() const {
  // @@protoc_insertion_point(field_get:ServerData.PermissionStatus.permission)
  return _internal_permission();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PermissionStatus::set_permission(ArgT0&& arg0, ArgT... args) {
 
 _impl_.permission_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PermissionStatus.permission)
}
inline std::string* PermissionStatus::mutable_permission() {
  std::string* _s = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:ServerData.PermissionStatus.permission)
  return _s;
}
inline const std::string& PermissionStatus::_internal_permission() const {
  return _impl_.permission_.Get();
}
inline void PermissionStatus::_internal_set_permission(const std::string& value) {
  
  _impl_.permission_.Set(value, GetArenaForAllocation());
}
inline std::string* PermissionStatus::_internal_mutable_permission() {
  
  return _impl_.permission_.Mutable(GetArenaForAllocation());
}
inline std::string* PermissionStatus::release_permission() {
  // @@protoc_insertion_point(field_release:ServerData.PermissionStatus.permission)
  return _impl_.permission_.Release();
}
inline void PermissionStatus::set_allocated_permission(std::string* permission) {
  if (permission != nullptr) {
    
  } else {
    
  }
  _impl_.permission_.SetAllocated(permission, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.permission_.IsDefault()) {
    _impl_.permission_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.PermissionStatus.permission)
}

// bool value = 3;
inline void PermissionStatus::clear_value() {
  _impl_.value_ = false;
}
inline bool PermissionStatus::_internal_value() const {
  return _impl_.value_;
}
inline bool PermissionStatus::value() const {
  // @@protoc_insertion_point(field_get:ServerData.PermissionStatus.value)
  return _internal_value();
}
inline void PermissionStatus::_internal_set_value(bool value) {
  
  _impl_.value_ = value;
}
inline void PermissionStatus::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ServerData.PermissionStatus.value)
}

// -------------------------------------------------------------------

// AllJoinableSpacesReq

// int32 reqId = 1;
inline void AllJoinableSpacesReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AllJoinableSpacesReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AllJoinableSpacesReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AllJoinableSpacesReq.reqId)
  return _internal_reqid();
}
inline void AllJoinableSpacesReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AllJoinableSpacesReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AllJoinableSpacesReq.reqId)
}

// -------------------------------------------------------------------

// AllJoinableSpacesResp

// int32 reqId = 1;
inline void AllJoinableSpacesResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t AllJoinableSpacesResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t AllJoinableSpacesResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.AllJoinableSpacesResp.reqId)
  return _internal_reqid();
}
inline void AllJoinableSpacesResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void AllJoinableSpacesResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.AllJoinableSpacesResp.reqId)
}

// repeated .ServerData.SpaceInfo availableSpaces = 10;
inline int AllJoinableSpacesResp::_internal_availablespaces_size() const {
  return _impl_.availablespaces_.size();
}
inline int AllJoinableSpacesResp::availablespaces_size() const {
  return _internal_availablespaces_size();
}
inline ::ServerData::SpaceInfo* AllJoinableSpacesResp::mutable_availablespaces(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.AllJoinableSpacesResp.availableSpaces)
  return _impl_.availablespaces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::SpaceInfo >*
AllJoinableSpacesResp::mutable_availablespaces() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.AllJoinableSpacesResp.availableSpaces)
  return &_impl_.availablespaces_;
}
inline const ::ServerData::SpaceInfo& AllJoinableSpacesResp::_internal_availablespaces(int index) const {
  return _impl_.availablespaces_.Get(index);
}
inline const ::ServerData::SpaceInfo& AllJoinableSpacesResp::availablespaces(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.AllJoinableSpacesResp.availableSpaces)
  return _internal_availablespaces(index);
}
inline ::ServerData::SpaceInfo* AllJoinableSpacesResp::_internal_add_availablespaces() {
  return _impl_.availablespaces_.Add();
}
inline ::ServerData::SpaceInfo* AllJoinableSpacesResp::add_availablespaces() {
  ::ServerData::SpaceInfo* _add = _internal_add_availablespaces();
  // @@protoc_insertion_point(field_add:ServerData.AllJoinableSpacesResp.availableSpaces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::SpaceInfo >&
AllJoinableSpacesResp::availablespaces() const {
  // @@protoc_insertion_point(field_list:ServerData.AllJoinableSpacesResp.availableSpaces)
  return _impl_.availablespaces_;
}

// -------------------------------------------------------------------

// GetSpaceInfoReq

// int32 reqId = 1;
inline void GetSpaceInfoReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t GetSpaceInfoReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t GetSpaceInfoReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.GetSpaceInfoReq.reqId)
  return _internal_reqid();
}
inline void GetSpaceInfoReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void GetSpaceInfoReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.GetSpaceInfoReq.reqId)
}

// string spaceId = 10;
inline void GetSpaceInfoReq::clear_spaceid() {
  _impl_.spaceid_.ClearToEmpty();
}
inline const std::string& GetSpaceInfoReq::spaceid() const {
  // @@protoc_insertion_point(field_get:ServerData.GetSpaceInfoReq.spaceId)
  return _internal_spaceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSpaceInfoReq::set_spaceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spaceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.GetSpaceInfoReq.spaceId)
}
inline std::string* GetSpaceInfoReq::mutable_spaceid() {
  std::string* _s = _internal_mutable_spaceid();
  // @@protoc_insertion_point(field_mutable:ServerData.GetSpaceInfoReq.spaceId)
  return _s;
}
inline const std::string& GetSpaceInfoReq::_internal_spaceid() const {
  return _impl_.spaceid_.Get();
}
inline void GetSpaceInfoReq::_internal_set_spaceid(const std::string& value) {
  
  _impl_.spaceid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSpaceInfoReq::_internal_mutable_spaceid() {
  
  return _impl_.spaceid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSpaceInfoReq::release_spaceid() {
  // @@protoc_insertion_point(field_release:ServerData.GetSpaceInfoReq.spaceId)
  return _impl_.spaceid_.Release();
}
inline void GetSpaceInfoReq::set_allocated_spaceid(std::string* spaceid) {
  if (spaceid != nullptr) {
    
  } else {
    
  }
  _impl_.spaceid_.SetAllocated(spaceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spaceid_.IsDefault()) {
    _impl_.spaceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.GetSpaceInfoReq.spaceId)
}

// -------------------------------------------------------------------

// GetSpaceInfoResp

// int32 reqId = 1;
inline void GetSpaceInfoResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t GetSpaceInfoResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t GetSpaceInfoResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.GetSpaceInfoResp.reqId)
  return _internal_reqid();
}
inline void GetSpaceInfoResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void GetSpaceInfoResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.GetSpaceInfoResp.reqId)
}

// .ServerData.SpaceInfo info = 10;
inline bool GetSpaceInfoResp::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool GetSpaceInfoResp::has_info() const {
  return _internal_has_info();
}
inline const ::ServerData::SpaceInfo& GetSpaceInfoResp::_internal_info() const {
  const ::ServerData::SpaceInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::SpaceInfo&>(
      ::ServerData::_SpaceInfo_default_instance_);
}
inline const ::ServerData::SpaceInfo& GetSpaceInfoResp::info() const {
  // @@protoc_insertion_point(field_get:ServerData.GetSpaceInfoResp.info)
  return _internal_info();
}
inline void GetSpaceInfoResp::unsafe_arena_set_allocated_info(
    ::ServerData::SpaceInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.GetSpaceInfoResp.info)
}
inline ::ServerData::SpaceInfo* GetSpaceInfoResp::release_info() {
  
  ::ServerData::SpaceInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::SpaceInfo* GetSpaceInfoResp::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:ServerData.GetSpaceInfoResp.info)
  
  ::ServerData::SpaceInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::ServerData::SpaceInfo* GetSpaceInfoResp::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::SpaceInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::ServerData::SpaceInfo* GetSpaceInfoResp::mutable_info() {
  ::ServerData::SpaceInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:ServerData.GetSpaceInfoResp.info)
  return _msg;
}
inline void GetSpaceInfoResp::set_allocated_info(::ServerData::SpaceInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:ServerData.GetSpaceInfoResp.info)
}

// -------------------------------------------------------------------

// DeleteSpaceReq

// int32 reqId = 1;
inline void DeleteSpaceReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t DeleteSpaceReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t DeleteSpaceReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.DeleteSpaceReq.reqId)
  return _internal_reqid();
}
inline void DeleteSpaceReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void DeleteSpaceReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.DeleteSpaceReq.reqId)
}

// string spaceId = 10;
inline void DeleteSpaceReq::clear_spaceid() {
  _impl_.spaceid_.ClearToEmpty();
}
inline const std::string& DeleteSpaceReq::spaceid() const {
  // @@protoc_insertion_point(field_get:ServerData.DeleteSpaceReq.spaceId)
  return _internal_spaceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteSpaceReq::set_spaceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spaceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.DeleteSpaceReq.spaceId)
}
inline std::string* DeleteSpaceReq::mutable_spaceid() {
  std::string* _s = _internal_mutable_spaceid();
  // @@protoc_insertion_point(field_mutable:ServerData.DeleteSpaceReq.spaceId)
  return _s;
}
inline const std::string& DeleteSpaceReq::_internal_spaceid() const {
  return _impl_.spaceid_.Get();
}
inline void DeleteSpaceReq::_internal_set_spaceid(const std::string& value) {
  
  _impl_.spaceid_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteSpaceReq::_internal_mutable_spaceid() {
  
  return _impl_.spaceid_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteSpaceReq::release_spaceid() {
  // @@protoc_insertion_point(field_release:ServerData.DeleteSpaceReq.spaceId)
  return _impl_.spaceid_.Release();
}
inline void DeleteSpaceReq::set_allocated_spaceid(std::string* spaceid) {
  if (spaceid != nullptr) {
    
  } else {
    
  }
  _impl_.spaceid_.SetAllocated(spaceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spaceid_.IsDefault()) {
    _impl_.spaceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.DeleteSpaceReq.spaceId)
}

// -------------------------------------------------------------------

// GenericResp

// int32 reqId = 1;
inline void GenericResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t GenericResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t GenericResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.GenericResp.reqId)
  return _internal_reqid();
}
inline void GenericResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void GenericResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.GenericResp.reqId)
}

// bool success = 10;
inline void GenericResp::clear_success() {
  _impl_.success_ = false;
}
inline bool GenericResp::_internal_success() const {
  return _impl_.success_;
}
inline bool GenericResp::success() const {
  // @@protoc_insertion_point(field_get:ServerData.GenericResp.success)
  return _internal_success();
}
inline void GenericResp::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void GenericResp::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ServerData.GenericResp.success)
}

// string error = 11;
inline void GenericResp::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& GenericResp::error() const {
  // @@protoc_insertion_point(field_get:ServerData.GenericResp.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenericResp::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.GenericResp.error)
}
inline std::string* GenericResp::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ServerData.GenericResp.error)
  return _s;
}
inline const std::string& GenericResp::_internal_error() const {
  return _impl_.error_.Get();
}
inline void GenericResp::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* GenericResp::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* GenericResp::release_error() {
  // @@protoc_insertion_point(field_release:ServerData.GenericResp.error)
  return _impl_.error_.Release();
}
inline void GenericResp::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.GenericResp.error)
}

// -------------------------------------------------------------------

// RenameSpaceReq

// int32 reqId = 1;
inline void RenameSpaceReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t RenameSpaceReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t RenameSpaceReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.RenameSpaceReq.reqId)
  return _internal_reqid();
}
inline void RenameSpaceReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void RenameSpaceReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.RenameSpaceReq.reqId)
}

// string spaceId = 10;
inline void RenameSpaceReq::clear_spaceid() {
  _impl_.spaceid_.ClearToEmpty();
}
inline const std::string& RenameSpaceReq::spaceid() const {
  // @@protoc_insertion_point(field_get:ServerData.RenameSpaceReq.spaceId)
  return _internal_spaceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameSpaceReq::set_spaceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spaceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RenameSpaceReq.spaceId)
}
inline std::string* RenameSpaceReq::mutable_spaceid() {
  std::string* _s = _internal_mutable_spaceid();
  // @@protoc_insertion_point(field_mutable:ServerData.RenameSpaceReq.spaceId)
  return _s;
}
inline const std::string& RenameSpaceReq::_internal_spaceid() const {
  return _impl_.spaceid_.Get();
}
inline void RenameSpaceReq::_internal_set_spaceid(const std::string& value) {
  
  _impl_.spaceid_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameSpaceReq::_internal_mutable_spaceid() {
  
  return _impl_.spaceid_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameSpaceReq::release_spaceid() {
  // @@protoc_insertion_point(field_release:ServerData.RenameSpaceReq.spaceId)
  return _impl_.spaceid_.Release();
}
inline void RenameSpaceReq::set_allocated_spaceid(std::string* spaceid) {
  if (spaceid != nullptr) {
    
  } else {
    
  }
  _impl_.spaceid_.SetAllocated(spaceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spaceid_.IsDefault()) {
    _impl_.spaceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RenameSpaceReq.spaceId)
}

// string newName = 11;
inline void RenameSpaceReq::clear_newname() {
  _impl_.newname_.ClearToEmpty();
}
inline const std::string& RenameSpaceReq::newname() const {
  // @@protoc_insertion_point(field_get:ServerData.RenameSpaceReq.newName)
  return _internal_newname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameSpaceReq::set_newname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RenameSpaceReq.newName)
}
inline std::string* RenameSpaceReq::mutable_newname() {
  std::string* _s = _internal_mutable_newname();
  // @@protoc_insertion_point(field_mutable:ServerData.RenameSpaceReq.newName)
  return _s;
}
inline const std::string& RenameSpaceReq::_internal_newname() const {
  return _impl_.newname_.Get();
}
inline void RenameSpaceReq::_internal_set_newname(const std::string& value) {
  
  _impl_.newname_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameSpaceReq::_internal_mutable_newname() {
  
  return _impl_.newname_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameSpaceReq::release_newname() {
  // @@protoc_insertion_point(field_release:ServerData.RenameSpaceReq.newName)
  return _impl_.newname_.Release();
}
inline void RenameSpaceReq::set_allocated_newname(std::string* newname) {
  if (newname != nullptr) {
    
  } else {
    
  }
  _impl_.newname_.SetAllocated(newname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newname_.IsDefault()) {
    _impl_.newname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RenameSpaceReq.newName)
}

// -------------------------------------------------------------------

// UpdateThumbnailForSpaceReq

// int32 reqId = 1;
inline void UpdateThumbnailForSpaceReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t UpdateThumbnailForSpaceReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t UpdateThumbnailForSpaceReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateThumbnailForSpaceReq.reqId)
  return _internal_reqid();
}
inline void UpdateThumbnailForSpaceReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void UpdateThumbnailForSpaceReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.UpdateThumbnailForSpaceReq.reqId)
}

// string spaceId = 10;
inline void UpdateThumbnailForSpaceReq::clear_spaceid() {
  _impl_.spaceid_.ClearToEmpty();
}
inline const std::string& UpdateThumbnailForSpaceReq::spaceid() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateThumbnailForSpaceReq.spaceId)
  return _internal_spaceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateThumbnailForSpaceReq::set_spaceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spaceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.UpdateThumbnailForSpaceReq.spaceId)
}
inline std::string* UpdateThumbnailForSpaceReq::mutable_spaceid() {
  std::string* _s = _internal_mutable_spaceid();
  // @@protoc_insertion_point(field_mutable:ServerData.UpdateThumbnailForSpaceReq.spaceId)
  return _s;
}
inline const std::string& UpdateThumbnailForSpaceReq::_internal_spaceid() const {
  return _impl_.spaceid_.Get();
}
inline void UpdateThumbnailForSpaceReq::_internal_set_spaceid(const std::string& value) {
  
  _impl_.spaceid_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateThumbnailForSpaceReq::_internal_mutable_spaceid() {
  
  return _impl_.spaceid_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateThumbnailForSpaceReq::release_spaceid() {
  // @@protoc_insertion_point(field_release:ServerData.UpdateThumbnailForSpaceReq.spaceId)
  return _impl_.spaceid_.Release();
}
inline void UpdateThumbnailForSpaceReq::set_allocated_spaceid(std::string* spaceid) {
  if (spaceid != nullptr) {
    
  } else {
    
  }
  _impl_.spaceid_.SetAllocated(spaceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spaceid_.IsDefault()) {
    _impl_.spaceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.UpdateThumbnailForSpaceReq.spaceId)
}

// string thumbnailfilename = 11;
inline void UpdateThumbnailForSpaceReq::clear_thumbnailfilename() {
  _impl_.thumbnailfilename_.ClearToEmpty();
}
inline const std::string& UpdateThumbnailForSpaceReq::thumbnailfilename() const {
  // @@protoc_insertion_point(field_get:ServerData.UpdateThumbnailForSpaceReq.thumbnailfilename)
  return _internal_thumbnailfilename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateThumbnailForSpaceReq::set_thumbnailfilename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thumbnailfilename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.UpdateThumbnailForSpaceReq.thumbnailfilename)
}
inline std::string* UpdateThumbnailForSpaceReq::mutable_thumbnailfilename() {
  std::string* _s = _internal_mutable_thumbnailfilename();
  // @@protoc_insertion_point(field_mutable:ServerData.UpdateThumbnailForSpaceReq.thumbnailfilename)
  return _s;
}
inline const std::string& UpdateThumbnailForSpaceReq::_internal_thumbnailfilename() const {
  return _impl_.thumbnailfilename_.Get();
}
inline void UpdateThumbnailForSpaceReq::_internal_set_thumbnailfilename(const std::string& value) {
  
  _impl_.thumbnailfilename_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateThumbnailForSpaceReq::_internal_mutable_thumbnailfilename() {
  
  return _impl_.thumbnailfilename_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateThumbnailForSpaceReq::release_thumbnailfilename() {
  // @@protoc_insertion_point(field_release:ServerData.UpdateThumbnailForSpaceReq.thumbnailfilename)
  return _impl_.thumbnailfilename_.Release();
}
inline void UpdateThumbnailForSpaceReq::set_allocated_thumbnailfilename(std::string* thumbnailfilename) {
  if (thumbnailfilename != nullptr) {
    
  } else {
    
  }
  _impl_.thumbnailfilename_.SetAllocated(thumbnailfilename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailfilename_.IsDefault()) {
    _impl_.thumbnailfilename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.UpdateThumbnailForSpaceReq.thumbnailfilename)
}

// -------------------------------------------------------------------

// ChatAdded

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool ChatAdded::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool ChatAdded::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& ChatAdded::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ChatAdded::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatAdded.spaceConn)
  return _internal_spaceconn();
}
inline void ChatAdded::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ChatAdded.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* ChatAdded::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ChatAdded::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.ChatAdded.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ChatAdded::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* ChatAdded::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatAdded.spaceConn)
  return _msg;
}
inline void ChatAdded::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatAdded.spaceConn)
}

// string ChatPropertyId = 2;
inline void ChatAdded::clear_chatpropertyid() {
  _impl_.chatpropertyid_.ClearToEmpty();
}
inline const std::string& ChatAdded::chatpropertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatAdded.ChatPropertyId)
  return _internal_chatpropertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatAdded::set_chatpropertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chatpropertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ChatAdded.ChatPropertyId)
}
inline std::string* ChatAdded::mutable_chatpropertyid() {
  std::string* _s = _internal_mutable_chatpropertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatAdded.ChatPropertyId)
  return _s;
}
inline const std::string& ChatAdded::_internal_chatpropertyid() const {
  return _impl_.chatpropertyid_.Get();
}
inline void ChatAdded::_internal_set_chatpropertyid(const std::string& value) {
  
  _impl_.chatpropertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatAdded::_internal_mutable_chatpropertyid() {
  
  return _impl_.chatpropertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatAdded::release_chatpropertyid() {
  // @@protoc_insertion_point(field_release:ServerData.ChatAdded.ChatPropertyId)
  return _impl_.chatpropertyid_.Release();
}
inline void ChatAdded::set_allocated_chatpropertyid(std::string* chatpropertyid) {
  if (chatpropertyid != nullptr) {
    
  } else {
    
  }
  _impl_.chatpropertyid_.SetAllocated(chatpropertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chatpropertyid_.IsDefault()) {
    _impl_.chatpropertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatAdded.ChatPropertyId)
}

// .ServerData.ChatBase ChatData = 10;
inline bool ChatAdded::_internal_has_chatdata() const {
  return this != internal_default_instance() && _impl_.chatdata_ != nullptr;
}
inline bool ChatAdded::has_chatdata() const {
  return _internal_has_chatdata();
}
inline void ChatAdded::clear_chatdata() {
  if (GetArenaForAllocation() == nullptr && _impl_.chatdata_ != nullptr) {
    delete _impl_.chatdata_;
  }
  _impl_.chatdata_ = nullptr;
}
inline const ::ServerData::ChatBase& ChatAdded::_internal_chatdata() const {
  const ::ServerData::ChatBase* p = _impl_.chatdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::ChatBase&>(
      ::ServerData::_ChatBase_default_instance_);
}
inline const ::ServerData::ChatBase& ChatAdded::chatdata() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatAdded.ChatData)
  return _internal_chatdata();
}
inline void ChatAdded::unsafe_arena_set_allocated_chatdata(
    ::ServerData::ChatBase* chatdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chatdata_);
  }
  _impl_.chatdata_ = chatdata;
  if (chatdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ChatAdded.ChatData)
}
inline ::ServerData::ChatBase* ChatAdded::release_chatdata() {
  
  ::ServerData::ChatBase* temp = _impl_.chatdata_;
  _impl_.chatdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::ChatBase* ChatAdded::unsafe_arena_release_chatdata() {
  // @@protoc_insertion_point(field_release:ServerData.ChatAdded.ChatData)
  
  ::ServerData::ChatBase* temp = _impl_.chatdata_;
  _impl_.chatdata_ = nullptr;
  return temp;
}
inline ::ServerData::ChatBase* ChatAdded::_internal_mutable_chatdata() {
  
  if (_impl_.chatdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::ChatBase>(GetArenaForAllocation());
    _impl_.chatdata_ = p;
  }
  return _impl_.chatdata_;
}
inline ::ServerData::ChatBase* ChatAdded::mutable_chatdata() {
  ::ServerData::ChatBase* _msg = _internal_mutable_chatdata();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatAdded.ChatData)
  return _msg;
}
inline void ChatAdded::set_allocated_chatdata(::ServerData::ChatBase* chatdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chatdata_;
  }
  if (chatdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chatdata);
    if (message_arena != submessage_arena) {
      chatdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chatdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chatdata_ = chatdata;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatAdded.ChatData)
}

// -------------------------------------------------------------------

// ChatUpdated

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool ChatUpdated::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool ChatUpdated::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& ChatUpdated::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ChatUpdated::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatUpdated.spaceConn)
  return _internal_spaceconn();
}
inline void ChatUpdated::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ChatUpdated.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* ChatUpdated::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ChatUpdated::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.ChatUpdated.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ChatUpdated::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* ChatUpdated::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatUpdated.spaceConn)
  return _msg;
}
inline void ChatUpdated::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatUpdated.spaceConn)
}

// string ChatPropertyId = 2;
inline void ChatUpdated::clear_chatpropertyid() {
  _impl_.chatpropertyid_.ClearToEmpty();
}
inline const std::string& ChatUpdated::chatpropertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatUpdated.ChatPropertyId)
  return _internal_chatpropertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatUpdated::set_chatpropertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chatpropertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ChatUpdated.ChatPropertyId)
}
inline std::string* ChatUpdated::mutable_chatpropertyid() {
  std::string* _s = _internal_mutable_chatpropertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatUpdated.ChatPropertyId)
  return _s;
}
inline const std::string& ChatUpdated::_internal_chatpropertyid() const {
  return _impl_.chatpropertyid_.Get();
}
inline void ChatUpdated::_internal_set_chatpropertyid(const std::string& value) {
  
  _impl_.chatpropertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatUpdated::_internal_mutable_chatpropertyid() {
  
  return _impl_.chatpropertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatUpdated::release_chatpropertyid() {
  // @@protoc_insertion_point(field_release:ServerData.ChatUpdated.ChatPropertyId)
  return _impl_.chatpropertyid_.Release();
}
inline void ChatUpdated::set_allocated_chatpropertyid(std::string* chatpropertyid) {
  if (chatpropertyid != nullptr) {
    
  } else {
    
  }
  _impl_.chatpropertyid_.SetAllocated(chatpropertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chatpropertyid_.IsDefault()) {
    _impl_.chatpropertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatUpdated.ChatPropertyId)
}

// .ServerData.ChatBase ChatData = 10;
inline bool ChatUpdated::_internal_has_chatdata() const {
  return this != internal_default_instance() && _impl_.chatdata_ != nullptr;
}
inline bool ChatUpdated::has_chatdata() const {
  return _internal_has_chatdata();
}
inline void ChatUpdated::clear_chatdata() {
  if (GetArenaForAllocation() == nullptr && _impl_.chatdata_ != nullptr) {
    delete _impl_.chatdata_;
  }
  _impl_.chatdata_ = nullptr;
}
inline const ::ServerData::ChatBase& ChatUpdated::_internal_chatdata() const {
  const ::ServerData::ChatBase* p = _impl_.chatdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::ChatBase&>(
      ::ServerData::_ChatBase_default_instance_);
}
inline const ::ServerData::ChatBase& ChatUpdated::chatdata() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatUpdated.ChatData)
  return _internal_chatdata();
}
inline void ChatUpdated::unsafe_arena_set_allocated_chatdata(
    ::ServerData::ChatBase* chatdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chatdata_);
  }
  _impl_.chatdata_ = chatdata;
  if (chatdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ChatUpdated.ChatData)
}
inline ::ServerData::ChatBase* ChatUpdated::release_chatdata() {
  
  ::ServerData::ChatBase* temp = _impl_.chatdata_;
  _impl_.chatdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::ChatBase* ChatUpdated::unsafe_arena_release_chatdata() {
  // @@protoc_insertion_point(field_release:ServerData.ChatUpdated.ChatData)
  
  ::ServerData::ChatBase* temp = _impl_.chatdata_;
  _impl_.chatdata_ = nullptr;
  return temp;
}
inline ::ServerData::ChatBase* ChatUpdated::_internal_mutable_chatdata() {
  
  if (_impl_.chatdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::ChatBase>(GetArenaForAllocation());
    _impl_.chatdata_ = p;
  }
  return _impl_.chatdata_;
}
inline ::ServerData::ChatBase* ChatUpdated::mutable_chatdata() {
  ::ServerData::ChatBase* _msg = _internal_mutable_chatdata();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatUpdated.ChatData)
  return _msg;
}
inline void ChatUpdated::set_allocated_chatdata(::ServerData::ChatBase* chatdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chatdata_;
  }
  if (chatdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chatdata);
    if (message_arena != submessage_arena) {
      chatdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chatdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chatdata_ = chatdata;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatUpdated.ChatData)
}

// -------------------------------------------------------------------

// ChatRemoved

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool ChatRemoved::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool ChatRemoved::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& ChatRemoved::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& ChatRemoved::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatRemoved.spaceConn)
  return _internal_spaceconn();
}
inline void ChatRemoved::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ChatRemoved.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* ChatRemoved::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ChatRemoved::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.ChatRemoved.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* ChatRemoved::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* ChatRemoved::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatRemoved.spaceConn)
  return _msg;
}
inline void ChatRemoved::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatRemoved.spaceConn)
}

// string ChatPropertyId = 2;
inline void ChatRemoved::clear_chatpropertyid() {
  _impl_.chatpropertyid_.ClearToEmpty();
}
inline const std::string& ChatRemoved::chatpropertyid() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatRemoved.ChatPropertyId)
  return _internal_chatpropertyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatRemoved::set_chatpropertyid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chatpropertyid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ChatRemoved.ChatPropertyId)
}
inline std::string* ChatRemoved::mutable_chatpropertyid() {
  std::string* _s = _internal_mutable_chatpropertyid();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatRemoved.ChatPropertyId)
  return _s;
}
inline const std::string& ChatRemoved::_internal_chatpropertyid() const {
  return _impl_.chatpropertyid_.Get();
}
inline void ChatRemoved::_internal_set_chatpropertyid(const std::string& value) {
  
  _impl_.chatpropertyid_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatRemoved::_internal_mutable_chatpropertyid() {
  
  return _impl_.chatpropertyid_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatRemoved::release_chatpropertyid() {
  // @@protoc_insertion_point(field_release:ServerData.ChatRemoved.ChatPropertyId)
  return _impl_.chatpropertyid_.Release();
}
inline void ChatRemoved::set_allocated_chatpropertyid(std::string* chatpropertyid) {
  if (chatpropertyid != nullptr) {
    
  } else {
    
  }
  _impl_.chatpropertyid_.SetAllocated(chatpropertyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chatpropertyid_.IsDefault()) {
    _impl_.chatpropertyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatRemoved.ChatPropertyId)
}

// -------------------------------------------------------------------

// PostChat

// .ServerData.CavrnusSpaceConnection spaceConn = 1;
inline bool PostChat::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool PostChat::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& PostChat::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& PostChat::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.PostChat.spaceConn)
  return _internal_spaceconn();
}
inline void PostChat::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.PostChat.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* PostChat::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostChat::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.PostChat.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* PostChat::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* PostChat::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.PostChat.spaceConn)
  return _msg;
}
inline void PostChat::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostChat.spaceConn)
}

// string ChatText = 10;
inline void PostChat::clear_chattext() {
  _impl_.chattext_.ClearToEmpty();
}
inline const std::string& PostChat::chattext() const {
  // @@protoc_insertion_point(field_get:ServerData.PostChat.ChatText)
  return _internal_chattext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostChat::set_chattext(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chattext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.PostChat.ChatText)
}
inline std::string* PostChat::mutable_chattext() {
  std::string* _s = _internal_mutable_chattext();
  // @@protoc_insertion_point(field_mutable:ServerData.PostChat.ChatText)
  return _s;
}
inline const std::string& PostChat::_internal_chattext() const {
  return _impl_.chattext_.Get();
}
inline void PostChat::_internal_set_chattext(const std::string& value) {
  
  _impl_.chattext_.Set(value, GetArenaForAllocation());
}
inline std::string* PostChat::_internal_mutable_chattext() {
  
  return _impl_.chattext_.Mutable(GetArenaForAllocation());
}
inline std::string* PostChat::release_chattext() {
  // @@protoc_insertion_point(field_release:ServerData.PostChat.ChatText)
  return _impl_.chattext_.Release();
}
inline void PostChat::set_allocated_chattext(std::string* chattext) {
  if (chattext != nullptr) {
    
  } else {
    
  }
  _impl_.chattext_.SetAllocated(chattext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chattext_.IsDefault()) {
    _impl_.chattext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.PostChat.ChatText)
}

// -------------------------------------------------------------------

// ChatBase

// .ServerData.ChatBase.ChatMessageSourceTypeEnum ChatType = 1;
inline void ChatBase::clear_chattype() {
  _impl_.chattype_ = 0;
}
inline ::ServerData::ChatBase_ChatMessageSourceTypeEnum ChatBase::_internal_chattype() const {
  return static_cast< ::ServerData::ChatBase_ChatMessageSourceTypeEnum >(_impl_.chattype_);
}
inline ::ServerData::ChatBase_ChatMessageSourceTypeEnum ChatBase::chattype() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.ChatType)
  return _internal_chattype();
}
inline void ChatBase::_internal_set_chattype(::ServerData::ChatBase_ChatMessageSourceTypeEnum value) {
  
  _impl_.chattype_ = value;
}
inline void ChatBase::set_chattype(::ServerData::ChatBase_ChatMessageSourceTypeEnum value) {
  _internal_set_chattype(value);
  // @@protoc_insertion_point(field_set:ServerData.ChatBase.ChatType)
}

// string Text = 2;
inline void ChatBase::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& ChatBase::text() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.Text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatBase::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ChatBase.Text)
}
inline std::string* ChatBase::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatBase.Text)
  return _s;
}
inline const std::string& ChatBase::_internal_text() const {
  return _impl_.text_.Get();
}
inline void ChatBase::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatBase::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatBase::release_text() {
  // @@protoc_insertion_point(field_release:ServerData.ChatBase.Text)
  return _impl_.text_.Release();
}
inline void ChatBase::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatBase.Text)
}

// .google.protobuf.Timestamp CreatedTime = 3;
inline bool ChatBase::_internal_has_createdtime() const {
  return this != internal_default_instance() && _impl_.createdtime_ != nullptr;
}
inline bool ChatBase::has_createdtime() const {
  return _internal_has_createdtime();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ChatBase::_internal_createdtime() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.createdtime_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ChatBase::createdtime() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.CreatedTime)
  return _internal_createdtime();
}
inline void ChatBase::unsafe_arena_set_allocated_createdtime(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.createdtime_);
  }
  _impl_.createdtime_ = createdtime;
  if (createdtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.ChatBase.CreatedTime)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChatBase::release_createdtime() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.createdtime_;
  _impl_.createdtime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChatBase::unsafe_arena_release_createdtime() {
  // @@protoc_insertion_point(field_release:ServerData.ChatBase.CreatedTime)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.createdtime_;
  _impl_.createdtime_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChatBase::_internal_mutable_createdtime() {
  
  if (_impl_.createdtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.createdtime_ = p;
  }
  return _impl_.createdtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChatBase::mutable_createdtime() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_createdtime();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatBase.CreatedTime)
  return _msg;
}
inline void ChatBase::set_allocated_createdtime(::PROTOBUF_NAMESPACE_ID::Timestamp* createdtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.createdtime_);
  }
  if (createdtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(createdtime));
    if (message_arena != submessage_arena) {
      createdtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, createdtime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.createdtime_ = createdtime;
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatBase.CreatedTime)
}

// bool Complete = 4;
inline void ChatBase::clear_complete() {
  _impl_.complete_ = false;
}
inline bool ChatBase::_internal_complete() const {
  return _impl_.complete_;
}
inline bool ChatBase::complete() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.Complete)
  return _internal_complete();
}
inline void ChatBase::_internal_set_complete(bool value) {
  
  _impl_.complete_ = value;
}
inline void ChatBase::set_complete(bool value) {
  _internal_set_complete(value);
  // @@protoc_insertion_point(field_set:ServerData.ChatBase.Complete)
}

// bool WasTranslated = 5;
inline void ChatBase::clear_wastranslated() {
  _impl_.wastranslated_ = false;
}
inline bool ChatBase::_internal_wastranslated() const {
  return _impl_.wastranslated_;
}
inline bool ChatBase::wastranslated() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.WasTranslated)
  return _internal_wastranslated();
}
inline void ChatBase::_internal_set_wastranslated(bool value) {
  
  _impl_.wastranslated_ = value;
}
inline void ChatBase::set_wastranslated(bool value) {
  _internal_set_wastranslated(value);
  // @@protoc_insertion_point(field_set:ServerData.ChatBase.WasTranslated)
}

// bool CreatorIsLocal = 10;
inline void ChatBase::clear_creatorislocal() {
  _impl_.creatorislocal_ = false;
}
inline bool ChatBase::_internal_creatorislocal() const {
  return _impl_.creatorislocal_;
}
inline bool ChatBase::creatorislocal() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.CreatorIsLocal)
  return _internal_creatorislocal();
}
inline void ChatBase::_internal_set_creatorislocal(bool value) {
  
  _impl_.creatorislocal_ = value;
}
inline void ChatBase::set_creatorislocal(bool value) {
  _internal_set_creatorislocal(value);
  // @@protoc_insertion_point(field_set:ServerData.ChatBase.CreatorIsLocal)
}

// string CreatorName = 11;
inline void ChatBase::clear_creatorname() {
  _impl_.creatorname_.ClearToEmpty();
}
inline const std::string& ChatBase::creatorname() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.CreatorName)
  return _internal_creatorname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatBase::set_creatorname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.creatorname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ChatBase.CreatorName)
}
inline std::string* ChatBase::mutable_creatorname() {
  std::string* _s = _internal_mutable_creatorname();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatBase.CreatorName)
  return _s;
}
inline const std::string& ChatBase::_internal_creatorname() const {
  return _impl_.creatorname_.Get();
}
inline void ChatBase::_internal_set_creatorname(const std::string& value) {
  
  _impl_.creatorname_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatBase::_internal_mutable_creatorname() {
  
  return _impl_.creatorname_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatBase::release_creatorname() {
  // @@protoc_insertion_point(field_release:ServerData.ChatBase.CreatorName)
  return _impl_.creatorname_.Release();
}
inline void ChatBase::set_allocated_creatorname(std::string* creatorname) {
  if (creatorname != nullptr) {
    
  } else {
    
  }
  _impl_.creatorname_.SetAllocated(creatorname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creatorname_.IsDefault()) {
    _impl_.creatorname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatBase.CreatorName)
}

// string CreatorPicUrl = 12;
inline void ChatBase::clear_creatorpicurl() {
  _impl_.creatorpicurl_.ClearToEmpty();
}
inline const std::string& ChatBase::creatorpicurl() const {
  // @@protoc_insertion_point(field_get:ServerData.ChatBase.CreatorPicUrl)
  return _internal_creatorpicurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatBase::set_creatorpicurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.creatorpicurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.ChatBase.CreatorPicUrl)
}
inline std::string* ChatBase::mutable_creatorpicurl() {
  std::string* _s = _internal_mutable_creatorpicurl();
  // @@protoc_insertion_point(field_mutable:ServerData.ChatBase.CreatorPicUrl)
  return _s;
}
inline const std::string& ChatBase::_internal_creatorpicurl() const {
  return _impl_.creatorpicurl_.Get();
}
inline void ChatBase::_internal_set_creatorpicurl(const std::string& value) {
  
  _impl_.creatorpicurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatBase::_internal_mutable_creatorpicurl() {
  
  return _impl_.creatorpicurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatBase::release_creatorpicurl() {
  // @@protoc_insertion_point(field_release:ServerData.ChatBase.CreatorPicUrl)
  return _impl_.creatorpicurl_.Release();
}
inline void ChatBase::set_allocated_creatorpicurl(std::string* creatorpicurl) {
  if (creatorpicurl != nullptr) {
    
  } else {
    
  }
  _impl_.creatorpicurl_.SetAllocated(creatorpicurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creatorpicurl_.IsDefault()) {
    _impl_.creatorpicurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.ChatBase.CreatorPicUrl)
}

// -------------------------------------------------------------------

// QueryAiReq

// int32 reqId = 1;
inline void QueryAiReq::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t QueryAiReq::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t QueryAiReq::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.QueryAiReq.reqId)
  return _internal_reqid();
}
inline void QueryAiReq::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void QueryAiReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.QueryAiReq.reqId)
}

// .ServerData.CavrnusSpaceConnection spaceConn = 10;
inline bool QueryAiReq::_internal_has_spaceconn() const {
  return this != internal_default_instance() && _impl_.spaceconn_ != nullptr;
}
inline bool QueryAiReq::has_spaceconn() const {
  return _internal_has_spaceconn();
}
inline const ::ServerData::CavrnusSpaceConnection& QueryAiReq::_internal_spaceconn() const {
  const ::ServerData::CavrnusSpaceConnection* p = _impl_.spaceconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusSpaceConnection&>(
      ::ServerData::_CavrnusSpaceConnection_default_instance_);
}
inline const ::ServerData::CavrnusSpaceConnection& QueryAiReq::spaceconn() const {
  // @@protoc_insertion_point(field_get:ServerData.QueryAiReq.spaceConn)
  return _internal_spaceconn();
}
inline void QueryAiReq::unsafe_arena_set_allocated_spaceconn(
    ::ServerData::CavrnusSpaceConnection* spaceconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  _impl_.spaceconn_ = spaceconn;
  if (spaceconn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.QueryAiReq.spaceConn)
}
inline ::ServerData::CavrnusSpaceConnection* QueryAiReq::release_spaceconn() {
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* QueryAiReq::unsafe_arena_release_spaceconn() {
  // @@protoc_insertion_point(field_release:ServerData.QueryAiReq.spaceConn)
  
  ::ServerData::CavrnusSpaceConnection* temp = _impl_.spaceconn_;
  _impl_.spaceconn_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusSpaceConnection* QueryAiReq::_internal_mutable_spaceconn() {
  
  if (_impl_.spaceconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(GetArenaForAllocation());
    _impl_.spaceconn_ = p;
  }
  return _impl_.spaceconn_;
}
inline ::ServerData::CavrnusSpaceConnection* QueryAiReq::mutable_spaceconn() {
  ::ServerData::CavrnusSpaceConnection* _msg = _internal_mutable_spaceconn();
  // @@protoc_insertion_point(field_mutable:ServerData.QueryAiReq.spaceConn)
  return _msg;
}
inline void QueryAiReq::set_allocated_spaceconn(::ServerData::CavrnusSpaceConnection* spaceconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceconn_);
  }
  if (spaceconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spaceconn));
    if (message_arena != submessage_arena) {
      spaceconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceconn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceconn_ = spaceconn;
  // @@protoc_insertion_point(field_set_allocated:ServerData.QueryAiReq.spaceConn)
}

// string reqText = 11;
inline void QueryAiReq::clear_reqtext() {
  _impl_.reqtext_.ClearToEmpty();
}
inline const std::string& QueryAiReq::reqtext() const {
  // @@protoc_insertion_point(field_get:ServerData.QueryAiReq.reqText)
  return _internal_reqtext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryAiReq::set_reqtext(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reqtext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.QueryAiReq.reqText)
}
inline std::string* QueryAiReq::mutable_reqtext() {
  std::string* _s = _internal_mutable_reqtext();
  // @@protoc_insertion_point(field_mutable:ServerData.QueryAiReq.reqText)
  return _s;
}
inline const std::string& QueryAiReq::_internal_reqtext() const {
  return _impl_.reqtext_.Get();
}
inline void QueryAiReq::_internal_set_reqtext(const std::string& value) {
  
  _impl_.reqtext_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryAiReq::_internal_mutable_reqtext() {
  
  return _impl_.reqtext_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryAiReq::release_reqtext() {
  // @@protoc_insertion_point(field_release:ServerData.QueryAiReq.reqText)
  return _impl_.reqtext_.Release();
}
inline void QueryAiReq::set_allocated_reqtext(std::string* reqtext) {
  if (reqtext != nullptr) {
    
  } else {
    
  }
  _impl_.reqtext_.SetAllocated(reqtext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reqtext_.IsDefault()) {
    _impl_.reqtext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.QueryAiReq.reqText)
}

// string apiKey = 12;
inline void QueryAiReq::clear_apikey() {
  _impl_.apikey_.ClearToEmpty();
}
inline const std::string& QueryAiReq::apikey() const {
  // @@protoc_insertion_point(field_get:ServerData.QueryAiReq.apiKey)
  return _internal_apikey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryAiReq::set_apikey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.apikey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.QueryAiReq.apiKey)
}
inline std::string* QueryAiReq::mutable_apikey() {
  std::string* _s = _internal_mutable_apikey();
  // @@protoc_insertion_point(field_mutable:ServerData.QueryAiReq.apiKey)
  return _s;
}
inline const std::string& QueryAiReq::_internal_apikey() const {
  return _impl_.apikey_.Get();
}
inline void QueryAiReq::_internal_set_apikey(const std::string& value) {
  
  _impl_.apikey_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryAiReq::_internal_mutable_apikey() {
  
  return _impl_.apikey_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryAiReq::release_apikey() {
  // @@protoc_insertion_point(field_release:ServerData.QueryAiReq.apiKey)
  return _impl_.apikey_.Release();
}
inline void QueryAiReq::set_allocated_apikey(std::string* apikey) {
  if (apikey != nullptr) {
    
  } else {
    
  }
  _impl_.apikey_.SetAllocated(apikey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.apikey_.IsDefault()) {
    _impl_.apikey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.QueryAiReq.apiKey)
}

// -------------------------------------------------------------------

// QueryAiResp

// int32 reqId = 1;
inline void QueryAiResp::clear_reqid() {
  _impl_.reqid_ = 0;
}
inline int32_t QueryAiResp::_internal_reqid() const {
  return _impl_.reqid_;
}
inline int32_t QueryAiResp::reqid() const {
  // @@protoc_insertion_point(field_get:ServerData.QueryAiResp.reqId)
  return _internal_reqid();
}
inline void QueryAiResp::_internal_set_reqid(int32_t value) {
  
  _impl_.reqid_ = value;
}
inline void QueryAiResp::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:ServerData.QueryAiResp.reqId)
}

// string respText = 10;
inline void QueryAiResp::clear_resptext() {
  _impl_.resptext_.ClearToEmpty();
}
inline const std::string& QueryAiResp::resptext() const {
  // @@protoc_insertion_point(field_get:ServerData.QueryAiResp.respText)
  return _internal_resptext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryAiResp::set_resptext(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resptext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.QueryAiResp.respText)
}
inline std::string* QueryAiResp::mutable_resptext() {
  std::string* _s = _internal_mutable_resptext();
  // @@protoc_insertion_point(field_mutable:ServerData.QueryAiResp.respText)
  return _s;
}
inline const std::string& QueryAiResp::_internal_resptext() const {
  return _impl_.resptext_.Get();
}
inline void QueryAiResp::_internal_set_resptext(const std::string& value) {
  
  _impl_.resptext_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryAiResp::_internal_mutable_resptext() {
  
  return _impl_.resptext_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryAiResp::release_resptext() {
  // @@protoc_insertion_point(field_release:ServerData.QueryAiResp.respText)
  return _impl_.resptext_.Release();
}
inline void QueryAiResp::set_allocated_resptext(std::string* resptext) {
  if (resptext != nullptr) {
    
  } else {
    
  }
  _impl_.resptext_.SetAllocated(resptext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resptext_.IsDefault()) {
    _impl_.resptext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.QueryAiResp.respText)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ServerData

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ServerData::ServerMessage_Category> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServerData::ServerMessage_Category>() {
  return ::ServerData::ServerMessage_Category_descriptor();
}
template <> struct is_proto_enum< ::ServerData::SpaceConnectionStatus_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServerData::SpaceConnectionStatus_Status>() {
  return ::ServerData::SpaceConnectionStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::ServerData::ChatBase_ChatMessageSourceTypeEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServerData::ChatBase_ChatMessageSourceTypeEnum>() {
  return ::ServerData::ChatBase_ChatMessageSourceTypeEnum_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_relay_2eproto
