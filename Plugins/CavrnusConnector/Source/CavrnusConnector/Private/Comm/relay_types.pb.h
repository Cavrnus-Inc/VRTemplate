// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: relay_types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_relay_5ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_relay_5ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_relay_5ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_relay_5ftypes_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_relay_5ftypes_2eproto;
namespace ServerData {
class CavrnusAuth;
struct CavrnusAuthDefaultTypeInternal;
extern CavrnusAuthDefaultTypeInternal _CavrnusAuth_default_instance_;
class CavrnusAuthLinkResponse;
struct CavrnusAuthLinkResponseDefaultTypeInternal;
extern CavrnusAuthLinkResponseDefaultTypeInternal _CavrnusAuthLinkResponse_default_instance_;
class CavrnusRemoteContent;
struct CavrnusRemoteContentDefaultTypeInternal;
extern CavrnusRemoteContentDefaultTypeInternal _CavrnusRemoteContent_default_instance_;
class CavrnusRole;
struct CavrnusRoleDefaultTypeInternal;
extern CavrnusRoleDefaultTypeInternal _CavrnusRole_default_instance_;
class CavrnusRoomMember;
struct CavrnusRoomMemberDefaultTypeInternal;
extern CavrnusRoomMemberDefaultTypeInternal _CavrnusRoomMember_default_instance_;
class CavrnusSpaceConnection;
struct CavrnusSpaceConnectionDefaultTypeInternal;
extern CavrnusSpaceConnectionDefaultTypeInternal _CavrnusSpaceConnection_default_instance_;
class CavrnusSpaceConnectionInfo;
struct CavrnusSpaceConnectionInfoDefaultTypeInternal;
extern CavrnusSpaceConnectionInfoDefaultTypeInternal _CavrnusSpaceConnectionInfo_default_instance_;
class CavrnusUser;
struct CavrnusUserDefaultTypeInternal;
extern CavrnusUserDefaultTypeInternal _CavrnusUser_default_instance_;
class CavrnusUserAccount;
struct CavrnusUserAccountDefaultTypeInternal;
extern CavrnusUserAccountDefaultTypeInternal _CavrnusUserAccount_default_instance_;
class OrganizationInformation;
struct OrganizationInformationDefaultTypeInternal;
extern OrganizationInformationDefaultTypeInternal _OrganizationInformation_default_instance_;
class RelayDataCache;
struct RelayDataCacheDefaultTypeInternal;
extern RelayDataCacheDefaultTypeInternal _RelayDataCache_default_instance_;
class RtcAudioInputDevice;
struct RtcAudioInputDeviceDefaultTypeInternal;
extern RtcAudioInputDeviceDefaultTypeInternal _RtcAudioInputDevice_default_instance_;
class RtcAudioInputDeviceList;
struct RtcAudioInputDeviceListDefaultTypeInternal;
extern RtcAudioInputDeviceListDefaultTypeInternal _RtcAudioInputDeviceList_default_instance_;
class RtcAudioOutputDevice;
struct RtcAudioOutputDeviceDefaultTypeInternal;
extern RtcAudioOutputDeviceDefaultTypeInternal _RtcAudioOutputDevice_default_instance_;
class RtcAudioOutputDeviceList;
struct RtcAudioOutputDeviceListDefaultTypeInternal;
extern RtcAudioOutputDeviceListDefaultTypeInternal _RtcAudioOutputDeviceList_default_instance_;
class RtcVideoInputDevice;
struct RtcVideoInputDeviceDefaultTypeInternal;
extern RtcVideoInputDeviceDefaultTypeInternal _RtcVideoInputDevice_default_instance_;
class RtcVideoInputDeviceList;
struct RtcVideoInputDeviceListDefaultTypeInternal;
extern RtcVideoInputDeviceListDefaultTypeInternal _RtcVideoInputDeviceList_default_instance_;
class SpaceInfo;
struct SpaceInfoDefaultTypeInternal;
extern SpaceInfoDefaultTypeInternal _SpaceInfo_default_instance_;
class Tag;
struct TagDefaultTypeInternal;
extern TagDefaultTypeInternal _Tag_default_instance_;
}  // namespace ServerData
PROTOBUF_NAMESPACE_OPEN
template<> ::ServerData::CavrnusAuth* Arena::CreateMaybeMessage<::ServerData::CavrnusAuth>(Arena*);
template<> ::ServerData::CavrnusAuthLinkResponse* Arena::CreateMaybeMessage<::ServerData::CavrnusAuthLinkResponse>(Arena*);
template<> ::ServerData::CavrnusRemoteContent* Arena::CreateMaybeMessage<::ServerData::CavrnusRemoteContent>(Arena*);
template<> ::ServerData::CavrnusRole* Arena::CreateMaybeMessage<::ServerData::CavrnusRole>(Arena*);
template<> ::ServerData::CavrnusRoomMember* Arena::CreateMaybeMessage<::ServerData::CavrnusRoomMember>(Arena*);
template<> ::ServerData::CavrnusSpaceConnection* Arena::CreateMaybeMessage<::ServerData::CavrnusSpaceConnection>(Arena*);
template<> ::ServerData::CavrnusSpaceConnectionInfo* Arena::CreateMaybeMessage<::ServerData::CavrnusSpaceConnectionInfo>(Arena*);
template<> ::ServerData::CavrnusUser* Arena::CreateMaybeMessage<::ServerData::CavrnusUser>(Arena*);
template<> ::ServerData::CavrnusUserAccount* Arena::CreateMaybeMessage<::ServerData::CavrnusUserAccount>(Arena*);
template<> ::ServerData::OrganizationInformation* Arena::CreateMaybeMessage<::ServerData::OrganizationInformation>(Arena*);
template<> ::ServerData::RelayDataCache* Arena::CreateMaybeMessage<::ServerData::RelayDataCache>(Arena*);
template<> ::ServerData::RtcAudioInputDevice* Arena::CreateMaybeMessage<::ServerData::RtcAudioInputDevice>(Arena*);
template<> ::ServerData::RtcAudioInputDeviceList* Arena::CreateMaybeMessage<::ServerData::RtcAudioInputDeviceList>(Arena*);
template<> ::ServerData::RtcAudioOutputDevice* Arena::CreateMaybeMessage<::ServerData::RtcAudioOutputDevice>(Arena*);
template<> ::ServerData::RtcAudioOutputDeviceList* Arena::CreateMaybeMessage<::ServerData::RtcAudioOutputDeviceList>(Arena*);
template<> ::ServerData::RtcVideoInputDevice* Arena::CreateMaybeMessage<::ServerData::RtcVideoInputDevice>(Arena*);
template<> ::ServerData::RtcVideoInputDeviceList* Arena::CreateMaybeMessage<::ServerData::RtcVideoInputDeviceList>(Arena*);
template<> ::ServerData::SpaceInfo* Arena::CreateMaybeMessage<::ServerData::SpaceInfo>(Arena*);
template<> ::ServerData::Tag* Arena::CreateMaybeMessage<::ServerData::Tag>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ServerData {

// ===================================================================

class CavrnusAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CavrnusAuth) */ {
 public:
  inline CavrnusAuth() : CavrnusAuth(nullptr) {}
  ~CavrnusAuth() override;
  explicit PROTOBUF_CONSTEXPR CavrnusAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CavrnusAuth(const CavrnusAuth& from);
  CavrnusAuth(CavrnusAuth&& from) noexcept
    : CavrnusAuth() {
    *this = ::std::move(from);
  }

  inline CavrnusAuth& operator=(const CavrnusAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline CavrnusAuth& operator=(CavrnusAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CavrnusAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const CavrnusAuth* internal_default_instance() {
    return reinterpret_cast<const CavrnusAuth*>(
               &_CavrnusAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CavrnusAuth& a, CavrnusAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(CavrnusAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CavrnusAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CavrnusAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CavrnusAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CavrnusAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CavrnusAuth& from) {
    CavrnusAuth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CavrnusAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CavrnusAuth";
  }
  protected:
  explicit CavrnusAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kServerFieldNumber = 2,
    kDisplaynameFieldNumber = 3,
    kOrgnameFieldNumber = 4,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string server = 2;
  void clear_server();
  const std::string& server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server();
  PROTOBUF_NODISCARD std::string* release_server();
  void set_allocated_server(std::string* server);
  private:
  const std::string& _internal_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server(const std::string& value);
  std::string* _internal_mutable_server();
  public:

  // string displayname = 3;
  void clear_displayname();
  const std::string& displayname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_displayname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_displayname();
  PROTOBUF_NODISCARD std::string* release_displayname();
  void set_allocated_displayname(std::string* displayname);
  private:
  const std::string& _internal_displayname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_displayname(const std::string& value);
  std::string* _internal_mutable_displayname();
  public:

  // string orgname = 4;
  void clear_orgname();
  const std::string& orgname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_orgname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_orgname();
  PROTOBUF_NODISCARD std::string* release_orgname();
  void set_allocated_orgname(std::string* orgname);
  private:
  const std::string& _internal_orgname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orgname(const std::string& value);
  std::string* _internal_mutable_orgname();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CavrnusAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displayname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orgname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class CavrnusAuthLinkResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CavrnusAuthLinkResponse) */ {
 public:
  inline CavrnusAuthLinkResponse() : CavrnusAuthLinkResponse(nullptr) {}
  ~CavrnusAuthLinkResponse() override;
  explicit PROTOBUF_CONSTEXPR CavrnusAuthLinkResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CavrnusAuthLinkResponse(const CavrnusAuthLinkResponse& from);
  CavrnusAuthLinkResponse(CavrnusAuthLinkResponse&& from) noexcept
    : CavrnusAuthLinkResponse() {
    *this = ::std::move(from);
  }

  inline CavrnusAuthLinkResponse& operator=(const CavrnusAuthLinkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CavrnusAuthLinkResponse& operator=(CavrnusAuthLinkResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CavrnusAuthLinkResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CavrnusAuthLinkResponse* internal_default_instance() {
    return reinterpret_cast<const CavrnusAuthLinkResponse*>(
               &_CavrnusAuthLinkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CavrnusAuthLinkResponse& a, CavrnusAuthLinkResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CavrnusAuthLinkResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CavrnusAuthLinkResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CavrnusAuthLinkResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CavrnusAuthLinkResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CavrnusAuthLinkResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CavrnusAuthLinkResponse& from) {
    CavrnusAuthLinkResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CavrnusAuthLinkResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CavrnusAuthLinkResponse";
  }
  protected:
  explicit CavrnusAuthLinkResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceIdToJoinFieldNumber = 1,
    kAuthFieldNumber = 2,
  };
  // string spaceIdToJoin = 1;
  void clear_spaceidtojoin();
  const std::string& spaceidtojoin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spaceidtojoin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spaceidtojoin();
  PROTOBUF_NODISCARD std::string* release_spaceidtojoin();
  void set_allocated_spaceidtojoin(std::string* spaceidtojoin);
  private:
  const std::string& _internal_spaceidtojoin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spaceidtojoin(const std::string& value);
  std::string* _internal_mutable_spaceidtojoin();
  public:

  // .ServerData.CavrnusAuth auth = 2;
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::ServerData::CavrnusAuth& auth() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusAuth* release_auth();
  ::ServerData::CavrnusAuth* mutable_auth();
  void set_allocated_auth(::ServerData::CavrnusAuth* auth);
  private:
  const ::ServerData::CavrnusAuth& _internal_auth() const;
  ::ServerData::CavrnusAuth* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::ServerData::CavrnusAuth* auth);
  ::ServerData::CavrnusAuth* unsafe_arena_release_auth();

  // @@protoc_insertion_point(class_scope:ServerData.CavrnusAuthLinkResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spaceidtojoin_;
    ::ServerData::CavrnusAuth* auth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class Tag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.Tag) */ {
 public:
  inline Tag() : Tag(nullptr) {}
  ~Tag() override;
  explicit PROTOBUF_CONSTEXPR Tag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tag(const Tag& from);
  Tag(Tag&& from) noexcept
    : Tag() {
    *this = ::std::move(from);
  }

  inline Tag& operator=(const Tag& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tag& operator=(Tag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tag& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tag* internal_default_instance() {
    return reinterpret_cast<const Tag*>(
               &_Tag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Tag& a, Tag& b) {
    a.Swap(&b);
  }
  inline void Swap(Tag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tag& from) {
    Tag::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.Tag";
  }
  protected:
  explicit Tag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.Tag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class OrganizationInformation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.OrganizationInformation) */ {
 public:
  inline OrganizationInformation() : OrganizationInformation(nullptr) {}
  ~OrganizationInformation() override;
  explicit PROTOBUF_CONSTEXPR OrganizationInformation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationInformation(const OrganizationInformation& from);
  OrganizationInformation(OrganizationInformation&& from) noexcept
    : OrganizationInformation() {
    *this = ::std::move(from);
  }

  inline OrganizationInformation& operator=(const OrganizationInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationInformation& operator=(OrganizationInformation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationInformation& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationInformation* internal_default_instance() {
    return reinterpret_cast<const OrganizationInformation*>(
               &_OrganizationInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OrganizationInformation& a, OrganizationInformation& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationInformation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationInformation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationInformation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationInformation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrganizationInformation& from) {
    OrganizationInformation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationInformation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.OrganizationInformation";
  }
  protected:
  explicit OrganizationInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedFeaturesFieldNumber = 5,
    kNameFieldNumber = 1,
    kDomainFieldNumber = 3,
  };
  // repeated string allowedFeatures = 5;
  int allowedfeatures_size() const;
  private:
  int _internal_allowedfeatures_size() const;
  public:
  void clear_allowedfeatures();
  const std::string& allowedfeatures(int index) const;
  std::string* mutable_allowedfeatures(int index);
  void set_allowedfeatures(int index, const std::string& value);
  void set_allowedfeatures(int index, std::string&& value);
  void set_allowedfeatures(int index, const char* value);
  void set_allowedfeatures(int index, const char* value, size_t size);
  std::string* add_allowedfeatures();
  void add_allowedfeatures(const std::string& value);
  void add_allowedfeatures(std::string&& value);
  void add_allowedfeatures(const char* value);
  void add_allowedfeatures(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& allowedfeatures() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_allowedfeatures();
  private:
  const std::string& _internal_allowedfeatures(int index) const;
  std::string* _internal_add_allowedfeatures();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string domain = 3;
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.OrganizationInformation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> allowedfeatures_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SpaceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.SpaceInfo) */ {
 public:
  inline SpaceInfo() : SpaceInfo(nullptr) {}
  ~SpaceInfo() override;
  explicit PROTOBUF_CONSTEXPR SpaceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpaceInfo(const SpaceInfo& from);
  SpaceInfo(SpaceInfo&& from) noexcept
    : SpaceInfo() {
    *this = ::std::move(from);
  }

  inline SpaceInfo& operator=(const SpaceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpaceInfo& operator=(SpaceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpaceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpaceInfo* internal_default_instance() {
    return reinterpret_cast<const SpaceInfo*>(
               &_SpaceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SpaceInfo& a, SpaceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SpaceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpaceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpaceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpaceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpaceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpaceInfo& from) {
    SpaceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpaceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.SpaceInfo";
  }
  protected:
  explicit SpaceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeywordsFieldNumber = 6,
    kTagsFieldNumber = 8,
    kCurrentSpaceMembersFieldNumber = 10,
    kSpaceIdFieldNumber = 1,
    kSpaceNameFieldNumber = 2,
    kSpaceThumbnailUrlFieldNumber = 3,
    kOwnerIdFieldNumber = 9,
    kLastAccessFieldNumber = 5,
    kArchivedFieldNumber = 4,
  };
  // repeated string keywords = 6;
  int keywords_size() const;
  private:
  int _internal_keywords_size() const;
  public:
  void clear_keywords();
  const std::string& keywords(int index) const;
  std::string* mutable_keywords(int index);
  void set_keywords(int index, const std::string& value);
  void set_keywords(int index, std::string&& value);
  void set_keywords(int index, const char* value);
  void set_keywords(int index, const char* value, size_t size);
  std::string* add_keywords();
  void add_keywords(const std::string& value);
  void add_keywords(std::string&& value);
  void add_keywords(const char* value);
  void add_keywords(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keywords() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keywords();
  private:
  const std::string& _internal_keywords(int index) const;
  std::string* _internal_add_keywords();
  public:

  // repeated .ServerData.Tag tags = 8;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  ::ServerData::Tag* mutable_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::Tag >*
      mutable_tags();
  private:
  const ::ServerData::Tag& _internal_tags(int index) const;
  ::ServerData::Tag* _internal_add_tags();
  public:
  const ::ServerData::Tag& tags(int index) const;
  ::ServerData::Tag* add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::Tag >&
      tags() const;

  // repeated .ServerData.CavrnusRoomMember currentSpaceMembers = 10;
  int currentspacemembers_size() const;
  private:
  int _internal_currentspacemembers_size() const;
  public:
  void clear_currentspacemembers();
  ::ServerData::CavrnusRoomMember* mutable_currentspacemembers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRoomMember >*
      mutable_currentspacemembers();
  private:
  const ::ServerData::CavrnusRoomMember& _internal_currentspacemembers(int index) const;
  ::ServerData::CavrnusRoomMember* _internal_add_currentspacemembers();
  public:
  const ::ServerData::CavrnusRoomMember& currentspacemembers(int index) const;
  ::ServerData::CavrnusRoomMember* add_currentspacemembers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRoomMember >&
      currentspacemembers() const;

  // string spaceId = 1;
  void clear_spaceid();
  const std::string& spaceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spaceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spaceid();
  PROTOBUF_NODISCARD std::string* release_spaceid();
  void set_allocated_spaceid(std::string* spaceid);
  private:
  const std::string& _internal_spaceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spaceid(const std::string& value);
  std::string* _internal_mutable_spaceid();
  public:

  // string spaceName = 2;
  void clear_spacename();
  const std::string& spacename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spacename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spacename();
  PROTOBUF_NODISCARD std::string* release_spacename();
  void set_allocated_spacename(std::string* spacename);
  private:
  const std::string& _internal_spacename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spacename(const std::string& value);
  std::string* _internal_mutable_spacename();
  public:

  // string spaceThumbnailUrl = 3;
  void clear_spacethumbnailurl();
  const std::string& spacethumbnailurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spacethumbnailurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spacethumbnailurl();
  PROTOBUF_NODISCARD std::string* release_spacethumbnailurl();
  void set_allocated_spacethumbnailurl(std::string* spacethumbnailurl);
  private:
  const std::string& _internal_spacethumbnailurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spacethumbnailurl(const std::string& value);
  std::string* _internal_mutable_spacethumbnailurl();
  public:

  // string ownerId = 9;
  void clear_ownerid();
  const std::string& ownerid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ownerid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ownerid();
  PROTOBUF_NODISCARD std::string* release_ownerid();
  void set_allocated_ownerid(std::string* ownerid);
  private:
  const std::string& _internal_ownerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownerid(const std::string& value);
  std::string* _internal_mutable_ownerid();
  public:

  // .google.protobuf.Timestamp lastAccess = 5;
  bool has_lastaccess() const;
  private:
  bool _internal_has_lastaccess() const;
  public:
  void clear_lastaccess();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& lastaccess() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_lastaccess();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_lastaccess();
  void set_allocated_lastaccess(::PROTOBUF_NAMESPACE_ID::Timestamp* lastaccess);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_lastaccess() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_lastaccess();
  public:
  void unsafe_arena_set_allocated_lastaccess(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* lastaccess);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_lastaccess();

  // bool archived = 4;
  void clear_archived();
  bool archived() const;
  void set_archived(bool value);
  private:
  bool _internal_archived() const;
  void _internal_set_archived(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.SpaceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keywords_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::Tag > tags_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRoomMember > currentspacemembers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spaceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spacename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spacethumbnailurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ownerid_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* lastaccess_;
    bool archived_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RelayDataCache final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RelayDataCache) */ {
 public:
  inline RelayDataCache() : RelayDataCache(nullptr) {}
  ~RelayDataCache() override;
  explicit PROTOBUF_CONSTEXPR RelayDataCache(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayDataCache(const RelayDataCache& from);
  RelayDataCache(RelayDataCache&& from) noexcept
    : RelayDataCache() {
    *this = ::std::move(from);
  }

  inline RelayDataCache& operator=(const RelayDataCache& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayDataCache& operator=(RelayDataCache&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelayDataCache& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelayDataCache* internal_default_instance() {
    return reinterpret_cast<const RelayDataCache*>(
               &_RelayDataCache_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RelayDataCache& a, RelayDataCache& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayDataCache* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayDataCache* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayDataCache* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayDataCache>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelayDataCache& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelayDataCache& from) {
    RelayDataCache::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelayDataCache* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RelayDataCache";
  }
  protected:
  explicit RelayDataCache(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringKeysFieldNumber = 1,
    kStringValuesFieldNumber = 2,
  };
  // repeated string stringKeys = 1;
  int stringkeys_size() const;
  private:
  int _internal_stringkeys_size() const;
  public:
  void clear_stringkeys();
  const std::string& stringkeys(int index) const;
  std::string* mutable_stringkeys(int index);
  void set_stringkeys(int index, const std::string& value);
  void set_stringkeys(int index, std::string&& value);
  void set_stringkeys(int index, const char* value);
  void set_stringkeys(int index, const char* value, size_t size);
  std::string* add_stringkeys();
  void add_stringkeys(const std::string& value);
  void add_stringkeys(std::string&& value);
  void add_stringkeys(const char* value);
  void add_stringkeys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& stringkeys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_stringkeys();
  private:
  const std::string& _internal_stringkeys(int index) const;
  std::string* _internal_add_stringkeys();
  public:

  // repeated string stringValues = 2;
  int stringvalues_size() const;
  private:
  int _internal_stringvalues_size() const;
  public:
  void clear_stringvalues();
  const std::string& stringvalues(int index) const;
  std::string* mutable_stringvalues(int index);
  void set_stringvalues(int index, const std::string& value);
  void set_stringvalues(int index, std::string&& value);
  void set_stringvalues(int index, const char* value);
  void set_stringvalues(int index, const char* value, size_t size);
  std::string* add_stringvalues();
  void add_stringvalues(const std::string& value);
  void add_stringvalues(std::string&& value);
  void add_stringvalues(const char* value);
  void add_stringvalues(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& stringvalues() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_stringvalues();
  private:
  const std::string& _internal_stringvalues(int index) const;
  std::string* _internal_add_stringvalues();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.RelayDataCache)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> stringkeys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> stringvalues_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class CavrnusSpaceConnection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CavrnusSpaceConnection) */ {
 public:
  inline CavrnusSpaceConnection() : CavrnusSpaceConnection(nullptr) {}
  ~CavrnusSpaceConnection() override;
  explicit PROTOBUF_CONSTEXPR CavrnusSpaceConnection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CavrnusSpaceConnection(const CavrnusSpaceConnection& from);
  CavrnusSpaceConnection(CavrnusSpaceConnection&& from) noexcept
    : CavrnusSpaceConnection() {
    *this = ::std::move(from);
  }

  inline CavrnusSpaceConnection& operator=(const CavrnusSpaceConnection& from) {
    CopyFrom(from);
    return *this;
  }
  inline CavrnusSpaceConnection& operator=(CavrnusSpaceConnection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CavrnusSpaceConnection& default_instance() {
    return *internal_default_instance();
  }
  static inline const CavrnusSpaceConnection* internal_default_instance() {
    return reinterpret_cast<const CavrnusSpaceConnection*>(
               &_CavrnusSpaceConnection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CavrnusSpaceConnection& a, CavrnusSpaceConnection& b) {
    a.Swap(&b);
  }
  inline void Swap(CavrnusSpaceConnection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CavrnusSpaceConnection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CavrnusSpaceConnection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CavrnusSpaceConnection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CavrnusSpaceConnection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CavrnusSpaceConnection& from) {
    CavrnusSpaceConnection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CavrnusSpaceConnection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CavrnusSpaceConnection";
  }
  protected:
  explicit CavrnusSpaceConnection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceConnectionIdFieldNumber = 1,
  };
  // int32 SpaceConnectionId = 1;
  void clear_spaceconnectionid();
  int32_t spaceconnectionid() const;
  void set_spaceconnectionid(int32_t value);
  private:
  int32_t _internal_spaceconnectionid() const;
  void _internal_set_spaceconnectionid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CavrnusSpaceConnection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t spaceconnectionid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class CavrnusSpaceConnectionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CavrnusSpaceConnectionInfo) */ {
 public:
  inline CavrnusSpaceConnectionInfo() : CavrnusSpaceConnectionInfo(nullptr) {}
  ~CavrnusSpaceConnectionInfo() override;
  explicit PROTOBUF_CONSTEXPR CavrnusSpaceConnectionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CavrnusSpaceConnectionInfo(const CavrnusSpaceConnectionInfo& from);
  CavrnusSpaceConnectionInfo(CavrnusSpaceConnectionInfo&& from) noexcept
    : CavrnusSpaceConnectionInfo() {
    *this = ::std::move(from);
  }

  inline CavrnusSpaceConnectionInfo& operator=(const CavrnusSpaceConnectionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CavrnusSpaceConnectionInfo& operator=(CavrnusSpaceConnectionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CavrnusSpaceConnectionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CavrnusSpaceConnectionInfo* internal_default_instance() {
    return reinterpret_cast<const CavrnusSpaceConnectionInfo*>(
               &_CavrnusSpaceConnectionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CavrnusSpaceConnectionInfo& a, CavrnusSpaceConnectionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CavrnusSpaceConnectionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CavrnusSpaceConnectionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CavrnusSpaceConnectionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CavrnusSpaceConnectionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CavrnusSpaceConnectionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CavrnusSpaceConnectionInfo& from) {
    CavrnusSpaceConnectionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CavrnusSpaceConnectionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CavrnusSpaceConnectionInfo";
  }
  protected:
  explicit CavrnusSpaceConnectionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalUserConnectionIdFieldNumber = 10,
    kSpaceInfoFieldNumber = 12,
    kSpaceConnectionIdFieldNumber = 1,
    kSpaceOwnedByLocalUserFieldNumber = 11,
  };
  // string localUserConnectionId = 10;
  void clear_localuserconnectionid();
  const std::string& localuserconnectionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_localuserconnectionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_localuserconnectionid();
  PROTOBUF_NODISCARD std::string* release_localuserconnectionid();
  void set_allocated_localuserconnectionid(std::string* localuserconnectionid);
  private:
  const std::string& _internal_localuserconnectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_localuserconnectionid(const std::string& value);
  std::string* _internal_mutable_localuserconnectionid();
  public:

  // .ServerData.SpaceInfo spaceInfo = 12;
  bool has_spaceinfo() const;
  private:
  bool _internal_has_spaceinfo() const;
  public:
  void clear_spaceinfo();
  const ::ServerData::SpaceInfo& spaceinfo() const;
  PROTOBUF_NODISCARD ::ServerData::SpaceInfo* release_spaceinfo();
  ::ServerData::SpaceInfo* mutable_spaceinfo();
  void set_allocated_spaceinfo(::ServerData::SpaceInfo* spaceinfo);
  private:
  const ::ServerData::SpaceInfo& _internal_spaceinfo() const;
  ::ServerData::SpaceInfo* _internal_mutable_spaceinfo();
  public:
  void unsafe_arena_set_allocated_spaceinfo(
      ::ServerData::SpaceInfo* spaceinfo);
  ::ServerData::SpaceInfo* unsafe_arena_release_spaceinfo();

  // int32 SpaceConnectionId = 1;
  void clear_spaceconnectionid();
  int32_t spaceconnectionid() const;
  void set_spaceconnectionid(int32_t value);
  private:
  int32_t _internal_spaceconnectionid() const;
  void _internal_set_spaceconnectionid(int32_t value);
  public:

  // bool spaceOwnedByLocalUser = 11;
  void clear_spaceownedbylocaluser();
  bool spaceownedbylocaluser() const;
  void set_spaceownedbylocaluser(bool value);
  private:
  bool _internal_spaceownedbylocaluser() const;
  void _internal_set_spaceownedbylocaluser(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CavrnusSpaceConnectionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr localuserconnectionid_;
    ::ServerData::SpaceInfo* spaceinfo_;
    int32_t spaceconnectionid_;
    bool spaceownedbylocaluser_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class CavrnusUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CavrnusUser) */ {
 public:
  inline CavrnusUser() : CavrnusUser(nullptr) {}
  ~CavrnusUser() override;
  explicit PROTOBUF_CONSTEXPR CavrnusUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CavrnusUser(const CavrnusUser& from);
  CavrnusUser(CavrnusUser&& from) noexcept
    : CavrnusUser() {
    *this = ::std::move(from);
  }

  inline CavrnusUser& operator=(const CavrnusUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline CavrnusUser& operator=(CavrnusUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CavrnusUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const CavrnusUser* internal_default_instance() {
    return reinterpret_cast<const CavrnusUser*>(
               &_CavrnusUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CavrnusUser& a, CavrnusUser& b) {
    a.Swap(&b);
  }
  inline void Swap(CavrnusUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CavrnusUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CavrnusUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CavrnusUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CavrnusUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CavrnusUser& from) {
    CavrnusUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CavrnusUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CavrnusUser";
  }
  protected:
  explicit CavrnusUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserConnectionIdFieldNumber = 1,
    kIsLocalUserFieldNumber = 2,
  };
  // string userConnectionId = 1;
  void clear_userconnectionid();
  const std::string& userconnectionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userconnectionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userconnectionid();
  PROTOBUF_NODISCARD std::string* release_userconnectionid();
  void set_allocated_userconnectionid(std::string* userconnectionid);
  private:
  const std::string& _internal_userconnectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userconnectionid(const std::string& value);
  std::string* _internal_mutable_userconnectionid();
  public:

  // bool IsLocalUser = 2;
  void clear_islocaluser();
  bool islocaluser() const;
  void set_islocaluser(bool value);
  private:
  bool _internal_islocaluser() const;
  void _internal_set_islocaluser(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CavrnusUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userconnectionid_;
    bool islocaluser_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class CavrnusRoomMember final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CavrnusRoomMember) */ {
 public:
  inline CavrnusRoomMember() : CavrnusRoomMember(nullptr) {}
  ~CavrnusRoomMember() override;
  explicit PROTOBUF_CONSTEXPR CavrnusRoomMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CavrnusRoomMember(const CavrnusRoomMember& from);
  CavrnusRoomMember(CavrnusRoomMember&& from) noexcept
    : CavrnusRoomMember() {
    *this = ::std::move(from);
  }

  inline CavrnusRoomMember& operator=(const CavrnusRoomMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline CavrnusRoomMember& operator=(CavrnusRoomMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CavrnusRoomMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const CavrnusRoomMember* internal_default_instance() {
    return reinterpret_cast<const CavrnusRoomMember*>(
               &_CavrnusRoomMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CavrnusRoomMember& a, CavrnusRoomMember& b) {
    a.Swap(&b);
  }
  inline void Swap(CavrnusRoomMember* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CavrnusRoomMember* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CavrnusRoomMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CavrnusRoomMember>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CavrnusRoomMember& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CavrnusRoomMember& from) {
    CavrnusRoomMember::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CavrnusRoomMember* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CavrnusRoomMember";
  }
  protected:
  explicit CavrnusRoomMember(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 30,
    kUserFieldNumber = 1,
    kIsOwnerFieldNumber = 2,
    kHasJoinedFieldNumber = 3,
  };
  // repeated string roles = 30;
  int roles_size() const;
  private:
  int _internal_roles_size() const;
  public:
  void clear_roles();
  const std::string& roles(int index) const;
  std::string* mutable_roles(int index);
  void set_roles(int index, const std::string& value);
  void set_roles(int index, std::string&& value);
  void set_roles(int index, const char* value);
  void set_roles(int index, const char* value, size_t size);
  std::string* add_roles();
  void add_roles(const std::string& value);
  void add_roles(std::string&& value);
  void add_roles(const char* value);
  void add_roles(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& roles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_roles();
  private:
  const std::string& _internal_roles(int index) const;
  std::string* _internal_add_roles();
  public:

  // .ServerData.CavrnusUserAccount user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::ServerData::CavrnusUserAccount& user() const;
  PROTOBUF_NODISCARD ::ServerData::CavrnusUserAccount* release_user();
  ::ServerData::CavrnusUserAccount* mutable_user();
  void set_allocated_user(::ServerData::CavrnusUserAccount* user);
  private:
  const ::ServerData::CavrnusUserAccount& _internal_user() const;
  ::ServerData::CavrnusUserAccount* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::ServerData::CavrnusUserAccount* user);
  ::ServerData::CavrnusUserAccount* unsafe_arena_release_user();

  // bool isOwner = 2;
  void clear_isowner();
  bool isowner() const;
  void set_isowner(bool value);
  private:
  bool _internal_isowner() const;
  void _internal_set_isowner(bool value);
  public:

  // bool hasJoined = 3;
  void clear_hasjoined();
  bool hasjoined() const;
  void set_hasjoined(bool value);
  private:
  bool _internal_hasjoined() const;
  void _internal_set_hasjoined(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CavrnusRoomMember)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> roles_;
    ::ServerData::CavrnusUserAccount* user_;
    bool isowner_;
    bool hasjoined_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class CavrnusUserAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CavrnusUserAccount) */ {
 public:
  inline CavrnusUserAccount() : CavrnusUserAccount(nullptr) {}
  ~CavrnusUserAccount() override;
  explicit PROTOBUF_CONSTEXPR CavrnusUserAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CavrnusUserAccount(const CavrnusUserAccount& from);
  CavrnusUserAccount(CavrnusUserAccount&& from) noexcept
    : CavrnusUserAccount() {
    *this = ::std::move(from);
  }

  inline CavrnusUserAccount& operator=(const CavrnusUserAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline CavrnusUserAccount& operator=(CavrnusUserAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CavrnusUserAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const CavrnusUserAccount* internal_default_instance() {
    return reinterpret_cast<const CavrnusUserAccount*>(
               &_CavrnusUserAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CavrnusUserAccount& a, CavrnusUserAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(CavrnusUserAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CavrnusUserAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CavrnusUserAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CavrnusUserAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CavrnusUserAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CavrnusUserAccount& from) {
    CavrnusUserAccount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CavrnusUserAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CavrnusUserAccount";
  }
  protected:
  explicit CavrnusUserAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 30,
    kUserAccountIdFieldNumber = 1,
    kUserEmailFieldNumber = 10,
    kUserProfilePicFieldNumber = 11,
    kUserFirstNameFieldNumber = 12,
    kUserLastNameFieldNumber = 13,
    kUserDisplayNameFieldNumber = 14,
    kIsLocalUserAccountFieldNumber = 2,
  };
  // repeated string roles = 30;
  int roles_size() const;
  private:
  int _internal_roles_size() const;
  public:
  void clear_roles();
  const std::string& roles(int index) const;
  std::string* mutable_roles(int index);
  void set_roles(int index, const std::string& value);
  void set_roles(int index, std::string&& value);
  void set_roles(int index, const char* value);
  void set_roles(int index, const char* value, size_t size);
  std::string* add_roles();
  void add_roles(const std::string& value);
  void add_roles(std::string&& value);
  void add_roles(const char* value);
  void add_roles(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& roles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_roles();
  private:
  const std::string& _internal_roles(int index) const;
  std::string* _internal_add_roles();
  public:

  // string userAccountId = 1;
  void clear_useraccountid();
  const std::string& useraccountid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_useraccountid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_useraccountid();
  PROTOBUF_NODISCARD std::string* release_useraccountid();
  void set_allocated_useraccountid(std::string* useraccountid);
  private:
  const std::string& _internal_useraccountid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_useraccountid(const std::string& value);
  std::string* _internal_mutable_useraccountid();
  public:

  // string userEmail = 10;
  void clear_useremail();
  const std::string& useremail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_useremail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_useremail();
  PROTOBUF_NODISCARD std::string* release_useremail();
  void set_allocated_useremail(std::string* useremail);
  private:
  const std::string& _internal_useremail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_useremail(const std::string& value);
  std::string* _internal_mutable_useremail();
  public:

  // string userProfilePic = 11;
  void clear_userprofilepic();
  const std::string& userprofilepic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userprofilepic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userprofilepic();
  PROTOBUF_NODISCARD std::string* release_userprofilepic();
  void set_allocated_userprofilepic(std::string* userprofilepic);
  private:
  const std::string& _internal_userprofilepic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userprofilepic(const std::string& value);
  std::string* _internal_mutable_userprofilepic();
  public:

  // string userFirstName = 12;
  void clear_userfirstname();
  const std::string& userfirstname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userfirstname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userfirstname();
  PROTOBUF_NODISCARD std::string* release_userfirstname();
  void set_allocated_userfirstname(std::string* userfirstname);
  private:
  const std::string& _internal_userfirstname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userfirstname(const std::string& value);
  std::string* _internal_mutable_userfirstname();
  public:

  // string userLastName = 13;
  void clear_userlastname();
  const std::string& userlastname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userlastname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userlastname();
  PROTOBUF_NODISCARD std::string* release_userlastname();
  void set_allocated_userlastname(std::string* userlastname);
  private:
  const std::string& _internal_userlastname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userlastname(const std::string& value);
  std::string* _internal_mutable_userlastname();
  public:

  // string userDisplayName = 14;
  void clear_userdisplayname();
  const std::string& userdisplayname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userdisplayname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userdisplayname();
  PROTOBUF_NODISCARD std::string* release_userdisplayname();
  void set_allocated_userdisplayname(std::string* userdisplayname);
  private:
  const std::string& _internal_userdisplayname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userdisplayname(const std::string& value);
  std::string* _internal_mutable_userdisplayname();
  public:

  // bool IsLocalUserAccount = 2;
  void clear_islocaluseraccount();
  bool islocaluseraccount() const;
  void set_islocaluseraccount(bool value);
  private:
  bool _internal_islocaluseraccount() const;
  void _internal_set_islocaluseraccount(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CavrnusUserAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> roles_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr useraccountid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr useremail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userprofilepic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userfirstname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userlastname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userdisplayname_;
    bool islocaluseraccount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class CavrnusRole final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CavrnusRole) */ {
 public:
  inline CavrnusRole() : CavrnusRole(nullptr) {}
  ~CavrnusRole() override;
  explicit PROTOBUF_CONSTEXPR CavrnusRole(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CavrnusRole(const CavrnusRole& from);
  CavrnusRole(CavrnusRole&& from) noexcept
    : CavrnusRole() {
    *this = ::std::move(from);
  }

  inline CavrnusRole& operator=(const CavrnusRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline CavrnusRole& operator=(CavrnusRole&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CavrnusRole& default_instance() {
    return *internal_default_instance();
  }
  static inline const CavrnusRole* internal_default_instance() {
    return reinterpret_cast<const CavrnusRole*>(
               &_CavrnusRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CavrnusRole& a, CavrnusRole& b) {
    a.Swap(&b);
  }
  inline void Swap(CavrnusRole* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CavrnusRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CavrnusRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CavrnusRole>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CavrnusRole& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CavrnusRole& from) {
    CavrnusRole::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CavrnusRole* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CavrnusRole";
  }
  protected:
  explicit CavrnusRole(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
    kRoleNameFieldNumber = 2,
  };
  // string roleId = 1;
  void clear_roleid();
  const std::string& roleid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roleid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roleid();
  PROTOBUF_NODISCARD std::string* release_roleid();
  void set_allocated_roleid(std::string* roleid);
  private:
  const std::string& _internal_roleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roleid(const std::string& value);
  std::string* _internal_mutable_roleid();
  public:

  // string roleName = 2;
  void clear_rolename();
  const std::string& rolename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rolename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rolename();
  PROTOBUF_NODISCARD std::string* release_rolename();
  void set_allocated_rolename(std::string* rolename);
  private:
  const std::string& _internal_rolename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rolename(const std::string& value);
  std::string* _internal_mutable_rolename();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CavrnusRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roleid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rolename_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RtcAudioInputDevice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RtcAudioInputDevice) */ {
 public:
  inline RtcAudioInputDevice() : RtcAudioInputDevice(nullptr) {}
  ~RtcAudioInputDevice() override;
  explicit PROTOBUF_CONSTEXPR RtcAudioInputDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtcAudioInputDevice(const RtcAudioInputDevice& from);
  RtcAudioInputDevice(RtcAudioInputDevice&& from) noexcept
    : RtcAudioInputDevice() {
    *this = ::std::move(from);
  }

  inline RtcAudioInputDevice& operator=(const RtcAudioInputDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcAudioInputDevice& operator=(RtcAudioInputDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcAudioInputDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcAudioInputDevice* internal_default_instance() {
    return reinterpret_cast<const RtcAudioInputDevice*>(
               &_RtcAudioInputDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RtcAudioInputDevice& a, RtcAudioInputDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcAudioInputDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcAudioInputDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcAudioInputDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcAudioInputDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtcAudioInputDevice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RtcAudioInputDevice& from) {
    RtcAudioInputDevice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtcAudioInputDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RtcAudioInputDevice";
  }
  protected:
  explicit RtcAudioInputDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.RtcAudioInputDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RtcAudioInputDeviceList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RtcAudioInputDeviceList) */ {
 public:
  inline RtcAudioInputDeviceList() : RtcAudioInputDeviceList(nullptr) {}
  ~RtcAudioInputDeviceList() override;
  explicit PROTOBUF_CONSTEXPR RtcAudioInputDeviceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtcAudioInputDeviceList(const RtcAudioInputDeviceList& from);
  RtcAudioInputDeviceList(RtcAudioInputDeviceList&& from) noexcept
    : RtcAudioInputDeviceList() {
    *this = ::std::move(from);
  }

  inline RtcAudioInputDeviceList& operator=(const RtcAudioInputDeviceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcAudioInputDeviceList& operator=(RtcAudioInputDeviceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcAudioInputDeviceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcAudioInputDeviceList* internal_default_instance() {
    return reinterpret_cast<const RtcAudioInputDeviceList*>(
               &_RtcAudioInputDeviceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RtcAudioInputDeviceList& a, RtcAudioInputDeviceList& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcAudioInputDeviceList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcAudioInputDeviceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcAudioInputDeviceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcAudioInputDeviceList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtcAudioInputDeviceList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RtcAudioInputDeviceList& from) {
    RtcAudioInputDeviceList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtcAudioInputDeviceList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RtcAudioInputDeviceList";
  }
  protected:
  explicit RtcAudioInputDeviceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 1,
  };
  // repeated .ServerData.RtcAudioInputDevice devices = 1;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::ServerData::RtcAudioInputDevice* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioInputDevice >*
      mutable_devices();
  private:
  const ::ServerData::RtcAudioInputDevice& _internal_devices(int index) const;
  ::ServerData::RtcAudioInputDevice* _internal_add_devices();
  public:
  const ::ServerData::RtcAudioInputDevice& devices(int index) const;
  ::ServerData::RtcAudioInputDevice* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioInputDevice >&
      devices() const;

  // @@protoc_insertion_point(class_scope:ServerData.RtcAudioInputDeviceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioInputDevice > devices_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RtcAudioOutputDevice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RtcAudioOutputDevice) */ {
 public:
  inline RtcAudioOutputDevice() : RtcAudioOutputDevice(nullptr) {}
  ~RtcAudioOutputDevice() override;
  explicit PROTOBUF_CONSTEXPR RtcAudioOutputDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtcAudioOutputDevice(const RtcAudioOutputDevice& from);
  RtcAudioOutputDevice(RtcAudioOutputDevice&& from) noexcept
    : RtcAudioOutputDevice() {
    *this = ::std::move(from);
  }

  inline RtcAudioOutputDevice& operator=(const RtcAudioOutputDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcAudioOutputDevice& operator=(RtcAudioOutputDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcAudioOutputDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcAudioOutputDevice* internal_default_instance() {
    return reinterpret_cast<const RtcAudioOutputDevice*>(
               &_RtcAudioOutputDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RtcAudioOutputDevice& a, RtcAudioOutputDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcAudioOutputDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcAudioOutputDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcAudioOutputDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcAudioOutputDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtcAudioOutputDevice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RtcAudioOutputDevice& from) {
    RtcAudioOutputDevice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtcAudioOutputDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RtcAudioOutputDevice";
  }
  protected:
  explicit RtcAudioOutputDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.RtcAudioOutputDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RtcAudioOutputDeviceList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RtcAudioOutputDeviceList) */ {
 public:
  inline RtcAudioOutputDeviceList() : RtcAudioOutputDeviceList(nullptr) {}
  ~RtcAudioOutputDeviceList() override;
  explicit PROTOBUF_CONSTEXPR RtcAudioOutputDeviceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtcAudioOutputDeviceList(const RtcAudioOutputDeviceList& from);
  RtcAudioOutputDeviceList(RtcAudioOutputDeviceList&& from) noexcept
    : RtcAudioOutputDeviceList() {
    *this = ::std::move(from);
  }

  inline RtcAudioOutputDeviceList& operator=(const RtcAudioOutputDeviceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcAudioOutputDeviceList& operator=(RtcAudioOutputDeviceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcAudioOutputDeviceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcAudioOutputDeviceList* internal_default_instance() {
    return reinterpret_cast<const RtcAudioOutputDeviceList*>(
               &_RtcAudioOutputDeviceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RtcAudioOutputDeviceList& a, RtcAudioOutputDeviceList& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcAudioOutputDeviceList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcAudioOutputDeviceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcAudioOutputDeviceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcAudioOutputDeviceList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtcAudioOutputDeviceList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RtcAudioOutputDeviceList& from) {
    RtcAudioOutputDeviceList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtcAudioOutputDeviceList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RtcAudioOutputDeviceList";
  }
  protected:
  explicit RtcAudioOutputDeviceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 1,
  };
  // repeated .ServerData.RtcAudioOutputDevice devices = 1;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::ServerData::RtcAudioOutputDevice* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioOutputDevice >*
      mutable_devices();
  private:
  const ::ServerData::RtcAudioOutputDevice& _internal_devices(int index) const;
  ::ServerData::RtcAudioOutputDevice* _internal_add_devices();
  public:
  const ::ServerData::RtcAudioOutputDevice& devices(int index) const;
  ::ServerData::RtcAudioOutputDevice* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioOutputDevice >&
      devices() const;

  // @@protoc_insertion_point(class_scope:ServerData.RtcAudioOutputDeviceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioOutputDevice > devices_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RtcVideoInputDevice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RtcVideoInputDevice) */ {
 public:
  inline RtcVideoInputDevice() : RtcVideoInputDevice(nullptr) {}
  ~RtcVideoInputDevice() override;
  explicit PROTOBUF_CONSTEXPR RtcVideoInputDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtcVideoInputDevice(const RtcVideoInputDevice& from);
  RtcVideoInputDevice(RtcVideoInputDevice&& from) noexcept
    : RtcVideoInputDevice() {
    *this = ::std::move(from);
  }

  inline RtcVideoInputDevice& operator=(const RtcVideoInputDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcVideoInputDevice& operator=(RtcVideoInputDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcVideoInputDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcVideoInputDevice* internal_default_instance() {
    return reinterpret_cast<const RtcVideoInputDevice*>(
               &_RtcVideoInputDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RtcVideoInputDevice& a, RtcVideoInputDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcVideoInputDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcVideoInputDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcVideoInputDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcVideoInputDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtcVideoInputDevice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RtcVideoInputDevice& from) {
    RtcVideoInputDevice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtcVideoInputDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RtcVideoInputDevice";
  }
  protected:
  explicit RtcVideoInputDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ServerData.RtcVideoInputDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RtcVideoInputDeviceList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.RtcVideoInputDeviceList) */ {
 public:
  inline RtcVideoInputDeviceList() : RtcVideoInputDeviceList(nullptr) {}
  ~RtcVideoInputDeviceList() override;
  explicit PROTOBUF_CONSTEXPR RtcVideoInputDeviceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtcVideoInputDeviceList(const RtcVideoInputDeviceList& from);
  RtcVideoInputDeviceList(RtcVideoInputDeviceList&& from) noexcept
    : RtcVideoInputDeviceList() {
    *this = ::std::move(from);
  }

  inline RtcVideoInputDeviceList& operator=(const RtcVideoInputDeviceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcVideoInputDeviceList& operator=(RtcVideoInputDeviceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcVideoInputDeviceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcVideoInputDeviceList* internal_default_instance() {
    return reinterpret_cast<const RtcVideoInputDeviceList*>(
               &_RtcVideoInputDeviceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RtcVideoInputDeviceList& a, RtcVideoInputDeviceList& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcVideoInputDeviceList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcVideoInputDeviceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcVideoInputDeviceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcVideoInputDeviceList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtcVideoInputDeviceList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RtcVideoInputDeviceList& from) {
    RtcVideoInputDeviceList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtcVideoInputDeviceList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.RtcVideoInputDeviceList";
  }
  protected:
  explicit RtcVideoInputDeviceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 1,
  };
  // repeated .ServerData.RtcVideoInputDevice devices = 1;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::ServerData::RtcVideoInputDevice* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcVideoInputDevice >*
      mutable_devices();
  private:
  const ::ServerData::RtcVideoInputDevice& _internal_devices(int index) const;
  ::ServerData::RtcVideoInputDevice* _internal_add_devices();
  public:
  const ::ServerData::RtcVideoInputDevice& devices(int index) const;
  ::ServerData::RtcVideoInputDevice* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcVideoInputDevice >&
      devices() const;

  // @@protoc_insertion_point(class_scope:ServerData.RtcVideoInputDeviceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcVideoInputDevice > devices_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class CavrnusRemoteContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerData.CavrnusRemoteContent) */ {
 public:
  inline CavrnusRemoteContent() : CavrnusRemoteContent(nullptr) {}
  ~CavrnusRemoteContent() override;
  explicit PROTOBUF_CONSTEXPR CavrnusRemoteContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CavrnusRemoteContent(const CavrnusRemoteContent& from);
  CavrnusRemoteContent(CavrnusRemoteContent&& from) noexcept
    : CavrnusRemoteContent() {
    *this = ::std::move(from);
  }

  inline CavrnusRemoteContent& operator=(const CavrnusRemoteContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CavrnusRemoteContent& operator=(CavrnusRemoteContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CavrnusRemoteContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CavrnusRemoteContent* internal_default_instance() {
    return reinterpret_cast<const CavrnusRemoteContent*>(
               &_CavrnusRemoteContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CavrnusRemoteContent& a, CavrnusRemoteContent& b) {
    a.Swap(&b);
  }
  inline void Swap(CavrnusRemoteContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CavrnusRemoteContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CavrnusRemoteContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CavrnusRemoteContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CavrnusRemoteContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CavrnusRemoteContent& from) {
    CavrnusRemoteContent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CavrnusRemoteContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerData.CavrnusRemoteContent";
  }
  protected:
  explicit CavrnusRemoteContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagKeysFieldNumber = 10,
    kTagValuesFieldNumber = 11,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kFileNameFieldNumber = 3,
    kThumbnailUrlFieldNumber = 4,
    kFileSizeStringFieldNumber = 6,
    kFileSizeFieldNumber = 5,
    kIsCachedOnDiskFieldNumber = 7,
  };
  // repeated string tagKeys = 10;
  int tagkeys_size() const;
  private:
  int _internal_tagkeys_size() const;
  public:
  void clear_tagkeys();
  const std::string& tagkeys(int index) const;
  std::string* mutable_tagkeys(int index);
  void set_tagkeys(int index, const std::string& value);
  void set_tagkeys(int index, std::string&& value);
  void set_tagkeys(int index, const char* value);
  void set_tagkeys(int index, const char* value, size_t size);
  std::string* add_tagkeys();
  void add_tagkeys(const std::string& value);
  void add_tagkeys(std::string&& value);
  void add_tagkeys(const char* value);
  void add_tagkeys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tagkeys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tagkeys();
  private:
  const std::string& _internal_tagkeys(int index) const;
  std::string* _internal_add_tagkeys();
  public:

  // repeated string tagValues = 11;
  int tagvalues_size() const;
  private:
  int _internal_tagvalues_size() const;
  public:
  void clear_tagvalues();
  const std::string& tagvalues(int index) const;
  std::string* mutable_tagvalues(int index);
  void set_tagvalues(int index, const std::string& value);
  void set_tagvalues(int index, std::string&& value);
  void set_tagvalues(int index, const char* value);
  void set_tagvalues(int index, const char* value, size_t size);
  std::string* add_tagvalues();
  void add_tagvalues(const std::string& value);
  void add_tagvalues(std::string&& value);
  void add_tagvalues(const char* value);
  void add_tagvalues(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tagvalues() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tagvalues();
  private:
  const std::string& _internal_tagvalues(int index) const;
  std::string* _internal_add_tagvalues();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string fileName = 3;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // string thumbnailUrl = 4;
  void clear_thumbnailurl();
  const std::string& thumbnailurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnailurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnailurl();
  PROTOBUF_NODISCARD std::string* release_thumbnailurl();
  void set_allocated_thumbnailurl(std::string* thumbnailurl);
  private:
  const std::string& _internal_thumbnailurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnailurl(const std::string& value);
  std::string* _internal_mutable_thumbnailurl();
  public:

  // string fileSizeString = 6;
  void clear_filesizestring();
  const std::string& filesizestring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filesizestring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filesizestring();
  PROTOBUF_NODISCARD std::string* release_filesizestring();
  void set_allocated_filesizestring(std::string* filesizestring);
  private:
  const std::string& _internal_filesizestring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filesizestring(const std::string& value);
  std::string* _internal_mutable_filesizestring();
  public:

  // int64 fileSize = 5;
  void clear_filesize();
  int64_t filesize() const;
  void set_filesize(int64_t value);
  private:
  int64_t _internal_filesize() const;
  void _internal_set_filesize(int64_t value);
  public:

  // bool isCachedOnDisk = 7;
  void clear_iscachedondisk();
  bool iscachedondisk() const;
  void set_iscachedondisk(bool value);
  private:
  bool _internal_iscachedondisk() const;
  void _internal_set_iscachedondisk(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerData.CavrnusRemoteContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tagkeys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tagvalues_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnailurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filesizestring_;
    int64_t filesize_;
    bool iscachedondisk_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_relay_5ftypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CavrnusAuth

// string token = 1;
inline void CavrnusAuth::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& CavrnusAuth::token() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusAuth.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusAuth::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusAuth.token)
}
inline std::string* CavrnusAuth::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusAuth.token)
  return _s;
}
inline const std::string& CavrnusAuth::_internal_token() const {
  return _impl_.token_.Get();
}
inline void CavrnusAuth::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusAuth::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusAuth::release_token() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusAuth.token)
  return _impl_.token_.Release();
}
inline void CavrnusAuth::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusAuth.token)
}

// string server = 2;
inline void CavrnusAuth::clear_server() {
  _impl_.server_.ClearToEmpty();
}
inline const std::string& CavrnusAuth::server() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusAuth.server)
  return _internal_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusAuth::set_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusAuth.server)
}
inline std::string* CavrnusAuth::mutable_server() {
  std::string* _s = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusAuth.server)
  return _s;
}
inline const std::string& CavrnusAuth::_internal_server() const {
  return _impl_.server_.Get();
}
inline void CavrnusAuth::_internal_set_server(const std::string& value) {
  
  _impl_.server_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusAuth::_internal_mutable_server() {
  
  return _impl_.server_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusAuth::release_server() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusAuth.server)
  return _impl_.server_.Release();
}
inline void CavrnusAuth::set_allocated_server(std::string* server) {
  if (server != nullptr) {
    
  } else {
    
  }
  _impl_.server_.SetAllocated(server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_.IsDefault()) {
    _impl_.server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusAuth.server)
}

// string displayname = 3;
inline void CavrnusAuth::clear_displayname() {
  _impl_.displayname_.ClearToEmpty();
}
inline const std::string& CavrnusAuth::displayname() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusAuth.displayname)
  return _internal_displayname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusAuth::set_displayname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.displayname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusAuth.displayname)
}
inline std::string* CavrnusAuth::mutable_displayname() {
  std::string* _s = _internal_mutable_displayname();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusAuth.displayname)
  return _s;
}
inline const std::string& CavrnusAuth::_internal_displayname() const {
  return _impl_.displayname_.Get();
}
inline void CavrnusAuth::_internal_set_displayname(const std::string& value) {
  
  _impl_.displayname_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusAuth::_internal_mutable_displayname() {
  
  return _impl_.displayname_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusAuth::release_displayname() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusAuth.displayname)
  return _impl_.displayname_.Release();
}
inline void CavrnusAuth::set_allocated_displayname(std::string* displayname) {
  if (displayname != nullptr) {
    
  } else {
    
  }
  _impl_.displayname_.SetAllocated(displayname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displayname_.IsDefault()) {
    _impl_.displayname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusAuth.displayname)
}

// string orgname = 4;
inline void CavrnusAuth::clear_orgname() {
  _impl_.orgname_.ClearToEmpty();
}
inline const std::string& CavrnusAuth::orgname() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusAuth.orgname)
  return _internal_orgname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusAuth::set_orgname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.orgname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusAuth.orgname)
}
inline std::string* CavrnusAuth::mutable_orgname() {
  std::string* _s = _internal_mutable_orgname();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusAuth.orgname)
  return _s;
}
inline const std::string& CavrnusAuth::_internal_orgname() const {
  return _impl_.orgname_.Get();
}
inline void CavrnusAuth::_internal_set_orgname(const std::string& value) {
  
  _impl_.orgname_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusAuth::_internal_mutable_orgname() {
  
  return _impl_.orgname_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusAuth::release_orgname() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusAuth.orgname)
  return _impl_.orgname_.Release();
}
inline void CavrnusAuth::set_allocated_orgname(std::string* orgname) {
  if (orgname != nullptr) {
    
  } else {
    
  }
  _impl_.orgname_.SetAllocated(orgname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.orgname_.IsDefault()) {
    _impl_.orgname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusAuth.orgname)
}

// -------------------------------------------------------------------

// CavrnusAuthLinkResponse

// string spaceIdToJoin = 1;
inline void CavrnusAuthLinkResponse::clear_spaceidtojoin() {
  _impl_.spaceidtojoin_.ClearToEmpty();
}
inline const std::string& CavrnusAuthLinkResponse::spaceidtojoin() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusAuthLinkResponse.spaceIdToJoin)
  return _internal_spaceidtojoin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusAuthLinkResponse::set_spaceidtojoin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spaceidtojoin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusAuthLinkResponse.spaceIdToJoin)
}
inline std::string* CavrnusAuthLinkResponse::mutable_spaceidtojoin() {
  std::string* _s = _internal_mutable_spaceidtojoin();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusAuthLinkResponse.spaceIdToJoin)
  return _s;
}
inline const std::string& CavrnusAuthLinkResponse::_internal_spaceidtojoin() const {
  return _impl_.spaceidtojoin_.Get();
}
inline void CavrnusAuthLinkResponse::_internal_set_spaceidtojoin(const std::string& value) {
  
  _impl_.spaceidtojoin_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusAuthLinkResponse::_internal_mutable_spaceidtojoin() {
  
  return _impl_.spaceidtojoin_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusAuthLinkResponse::release_spaceidtojoin() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusAuthLinkResponse.spaceIdToJoin)
  return _impl_.spaceidtojoin_.Release();
}
inline void CavrnusAuthLinkResponse::set_allocated_spaceidtojoin(std::string* spaceidtojoin) {
  if (spaceidtojoin != nullptr) {
    
  } else {
    
  }
  _impl_.spaceidtojoin_.SetAllocated(spaceidtojoin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spaceidtojoin_.IsDefault()) {
    _impl_.spaceidtojoin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusAuthLinkResponse.spaceIdToJoin)
}

// .ServerData.CavrnusAuth auth = 2;
inline bool CavrnusAuthLinkResponse::_internal_has_auth() const {
  return this != internal_default_instance() && _impl_.auth_ != nullptr;
}
inline bool CavrnusAuthLinkResponse::has_auth() const {
  return _internal_has_auth();
}
inline void CavrnusAuthLinkResponse::clear_auth() {
  if (GetArenaForAllocation() == nullptr && _impl_.auth_ != nullptr) {
    delete _impl_.auth_;
  }
  _impl_.auth_ = nullptr;
}
inline const ::ServerData::CavrnusAuth& CavrnusAuthLinkResponse::_internal_auth() const {
  const ::ServerData::CavrnusAuth* p = _impl_.auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusAuth&>(
      ::ServerData::_CavrnusAuth_default_instance_);
}
inline const ::ServerData::CavrnusAuth& CavrnusAuthLinkResponse::auth() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusAuthLinkResponse.auth)
  return _internal_auth();
}
inline void CavrnusAuthLinkResponse::unsafe_arena_set_allocated_auth(
    ::ServerData::CavrnusAuth* auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auth_);
  }
  _impl_.auth_ = auth;
  if (auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.CavrnusAuthLinkResponse.auth)
}
inline ::ServerData::CavrnusAuth* CavrnusAuthLinkResponse::release_auth() {
  
  ::ServerData::CavrnusAuth* temp = _impl_.auth_;
  _impl_.auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusAuth* CavrnusAuthLinkResponse::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusAuthLinkResponse.auth)
  
  ::ServerData::CavrnusAuth* temp = _impl_.auth_;
  _impl_.auth_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusAuth* CavrnusAuthLinkResponse::_internal_mutable_auth() {
  
  if (_impl_.auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusAuth>(GetArenaForAllocation());
    _impl_.auth_ = p;
  }
  return _impl_.auth_;
}
inline ::ServerData::CavrnusAuth* CavrnusAuthLinkResponse::mutable_auth() {
  ::ServerData::CavrnusAuth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusAuthLinkResponse.auth)
  return _msg;
}
inline void CavrnusAuthLinkResponse::set_allocated_auth(::ServerData::CavrnusAuth* auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.auth_;
  }
  if (auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auth);
    if (message_arena != submessage_arena) {
      auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusAuthLinkResponse.auth)
}

// -------------------------------------------------------------------

// Tag

// string key = 1;
inline void Tag::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& Tag::key() const {
  // @@protoc_insertion_point(field_get:ServerData.Tag.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tag::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.Tag.key)
}
inline std::string* Tag::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:ServerData.Tag.key)
  return _s;
}
inline const std::string& Tag::_internal_key() const {
  return _impl_.key_.Get();
}
inline void Tag::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* Tag::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* Tag::release_key() {
  // @@protoc_insertion_point(field_release:ServerData.Tag.key)
  return _impl_.key_.Release();
}
inline void Tag::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.Tag.key)
}

// string value = 2;
inline void Tag::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Tag::value() const {
  // @@protoc_insertion_point(field_get:ServerData.Tag.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tag::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.Tag.value)
}
inline std::string* Tag::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:ServerData.Tag.value)
  return _s;
}
inline const std::string& Tag::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Tag::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Tag::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Tag::release_value() {
  // @@protoc_insertion_point(field_release:ServerData.Tag.value)
  return _impl_.value_.Release();
}
inline void Tag::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.Tag.value)
}

// -------------------------------------------------------------------

// OrganizationInformation

// string name = 1;
inline void OrganizationInformation::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& OrganizationInformation::name() const {
  // @@protoc_insertion_point(field_get:ServerData.OrganizationInformation.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationInformation::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.OrganizationInformation.name)
}
inline std::string* OrganizationInformation::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ServerData.OrganizationInformation.name)
  return _s;
}
inline const std::string& OrganizationInformation::_internal_name() const {
  return _impl_.name_.Get();
}
inline void OrganizationInformation::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationInformation::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationInformation::release_name() {
  // @@protoc_insertion_point(field_release:ServerData.OrganizationInformation.name)
  return _impl_.name_.Release();
}
inline void OrganizationInformation::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.OrganizationInformation.name)
}

// string domain = 3;
inline void OrganizationInformation::clear_domain() {
  _impl_.domain_.ClearToEmpty();
}
inline const std::string& OrganizationInformation::domain() const {
  // @@protoc_insertion_point(field_get:ServerData.OrganizationInformation.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationInformation::set_domain(ArgT0&& arg0, ArgT... args) {
 
 _impl_.domain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.OrganizationInformation.domain)
}
inline std::string* OrganizationInformation::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:ServerData.OrganizationInformation.domain)
  return _s;
}
inline const std::string& OrganizationInformation::_internal_domain() const {
  return _impl_.domain_.Get();
}
inline void OrganizationInformation::_internal_set_domain(const std::string& value) {
  
  _impl_.domain_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationInformation::_internal_mutable_domain() {
  
  return _impl_.domain_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationInformation::release_domain() {
  // @@protoc_insertion_point(field_release:ServerData.OrganizationInformation.domain)
  return _impl_.domain_.Release();
}
inline void OrganizationInformation::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  _impl_.domain_.SetAllocated(domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.domain_.IsDefault()) {
    _impl_.domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.OrganizationInformation.domain)
}

// repeated string allowedFeatures = 5;
inline int OrganizationInformation::_internal_allowedfeatures_size() const {
  return _impl_.allowedfeatures_.size();
}
inline int OrganizationInformation::allowedfeatures_size() const {
  return _internal_allowedfeatures_size();
}
inline void OrganizationInformation::clear_allowedfeatures() {
  _impl_.allowedfeatures_.Clear();
}
inline std::string* OrganizationInformation::add_allowedfeatures() {
  std::string* _s = _internal_add_allowedfeatures();
  // @@protoc_insertion_point(field_add_mutable:ServerData.OrganizationInformation.allowedFeatures)
  return _s;
}
inline const std::string& OrganizationInformation::_internal_allowedfeatures(int index) const {
  return _impl_.allowedfeatures_.Get(index);
}
inline const std::string& OrganizationInformation::allowedfeatures(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.OrganizationInformation.allowedFeatures)
  return _internal_allowedfeatures(index);
}
inline std::string* OrganizationInformation::mutable_allowedfeatures(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.OrganizationInformation.allowedFeatures)
  return _impl_.allowedfeatures_.Mutable(index);
}
inline void OrganizationInformation::set_allowedfeatures(int index, const std::string& value) {
  _impl_.allowedfeatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerData.OrganizationInformation.allowedFeatures)
}
inline void OrganizationInformation::set_allowedfeatures(int index, std::string&& value) {
  _impl_.allowedfeatures_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerData.OrganizationInformation.allowedFeatures)
}
inline void OrganizationInformation::set_allowedfeatures(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowedfeatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerData.OrganizationInformation.allowedFeatures)
}
inline void OrganizationInformation::set_allowedfeatures(int index, const char* value, size_t size) {
  _impl_.allowedfeatures_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerData.OrganizationInformation.allowedFeatures)
}
inline std::string* OrganizationInformation::_internal_add_allowedfeatures() {
  return _impl_.allowedfeatures_.Add();
}
inline void OrganizationInformation::add_allowedfeatures(const std::string& value) {
  _impl_.allowedfeatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerData.OrganizationInformation.allowedFeatures)
}
inline void OrganizationInformation::add_allowedfeatures(std::string&& value) {
  _impl_.allowedfeatures_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerData.OrganizationInformation.allowedFeatures)
}
inline void OrganizationInformation::add_allowedfeatures(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowedfeatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerData.OrganizationInformation.allowedFeatures)
}
inline void OrganizationInformation::add_allowedfeatures(const char* value, size_t size) {
  _impl_.allowedfeatures_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerData.OrganizationInformation.allowedFeatures)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrganizationInformation::allowedfeatures() const {
  // @@protoc_insertion_point(field_list:ServerData.OrganizationInformation.allowedFeatures)
  return _impl_.allowedfeatures_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OrganizationInformation::mutable_allowedfeatures() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.OrganizationInformation.allowedFeatures)
  return &_impl_.allowedfeatures_;
}

// -------------------------------------------------------------------

// SpaceInfo

// string spaceId = 1;
inline void SpaceInfo::clear_spaceid() {
  _impl_.spaceid_.ClearToEmpty();
}
inline const std::string& SpaceInfo::spaceid() const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceInfo.spaceId)
  return _internal_spaceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpaceInfo::set_spaceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spaceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.SpaceInfo.spaceId)
}
inline std::string* SpaceInfo::mutable_spaceid() {
  std::string* _s = _internal_mutable_spaceid();
  // @@protoc_insertion_point(field_mutable:ServerData.SpaceInfo.spaceId)
  return _s;
}
inline const std::string& SpaceInfo::_internal_spaceid() const {
  return _impl_.spaceid_.Get();
}
inline void SpaceInfo::_internal_set_spaceid(const std::string& value) {
  
  _impl_.spaceid_.Set(value, GetArenaForAllocation());
}
inline std::string* SpaceInfo::_internal_mutable_spaceid() {
  
  return _impl_.spaceid_.Mutable(GetArenaForAllocation());
}
inline std::string* SpaceInfo::release_spaceid() {
  // @@protoc_insertion_point(field_release:ServerData.SpaceInfo.spaceId)
  return _impl_.spaceid_.Release();
}
inline void SpaceInfo::set_allocated_spaceid(std::string* spaceid) {
  if (spaceid != nullptr) {
    
  } else {
    
  }
  _impl_.spaceid_.SetAllocated(spaceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spaceid_.IsDefault()) {
    _impl_.spaceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.SpaceInfo.spaceId)
}

// string spaceName = 2;
inline void SpaceInfo::clear_spacename() {
  _impl_.spacename_.ClearToEmpty();
}
inline const std::string& SpaceInfo::spacename() const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceInfo.spaceName)
  return _internal_spacename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpaceInfo::set_spacename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spacename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.SpaceInfo.spaceName)
}
inline std::string* SpaceInfo::mutable_spacename() {
  std::string* _s = _internal_mutable_spacename();
  // @@protoc_insertion_point(field_mutable:ServerData.SpaceInfo.spaceName)
  return _s;
}
inline const std::string& SpaceInfo::_internal_spacename() const {
  return _impl_.spacename_.Get();
}
inline void SpaceInfo::_internal_set_spacename(const std::string& value) {
  
  _impl_.spacename_.Set(value, GetArenaForAllocation());
}
inline std::string* SpaceInfo::_internal_mutable_spacename() {
  
  return _impl_.spacename_.Mutable(GetArenaForAllocation());
}
inline std::string* SpaceInfo::release_spacename() {
  // @@protoc_insertion_point(field_release:ServerData.SpaceInfo.spaceName)
  return _impl_.spacename_.Release();
}
inline void SpaceInfo::set_allocated_spacename(std::string* spacename) {
  if (spacename != nullptr) {
    
  } else {
    
  }
  _impl_.spacename_.SetAllocated(spacename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spacename_.IsDefault()) {
    _impl_.spacename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.SpaceInfo.spaceName)
}

// string spaceThumbnailUrl = 3;
inline void SpaceInfo::clear_spacethumbnailurl() {
  _impl_.spacethumbnailurl_.ClearToEmpty();
}
inline const std::string& SpaceInfo::spacethumbnailurl() const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceInfo.spaceThumbnailUrl)
  return _internal_spacethumbnailurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpaceInfo::set_spacethumbnailurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spacethumbnailurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.SpaceInfo.spaceThumbnailUrl)
}
inline std::string* SpaceInfo::mutable_spacethumbnailurl() {
  std::string* _s = _internal_mutable_spacethumbnailurl();
  // @@protoc_insertion_point(field_mutable:ServerData.SpaceInfo.spaceThumbnailUrl)
  return _s;
}
inline const std::string& SpaceInfo::_internal_spacethumbnailurl() const {
  return _impl_.spacethumbnailurl_.Get();
}
inline void SpaceInfo::_internal_set_spacethumbnailurl(const std::string& value) {
  
  _impl_.spacethumbnailurl_.Set(value, GetArenaForAllocation());
}
inline std::string* SpaceInfo::_internal_mutable_spacethumbnailurl() {
  
  return _impl_.spacethumbnailurl_.Mutable(GetArenaForAllocation());
}
inline std::string* SpaceInfo::release_spacethumbnailurl() {
  // @@protoc_insertion_point(field_release:ServerData.SpaceInfo.spaceThumbnailUrl)
  return _impl_.spacethumbnailurl_.Release();
}
inline void SpaceInfo::set_allocated_spacethumbnailurl(std::string* spacethumbnailurl) {
  if (spacethumbnailurl != nullptr) {
    
  } else {
    
  }
  _impl_.spacethumbnailurl_.SetAllocated(spacethumbnailurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spacethumbnailurl_.IsDefault()) {
    _impl_.spacethumbnailurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.SpaceInfo.spaceThumbnailUrl)
}

// bool archived = 4;
inline void SpaceInfo::clear_archived() {
  _impl_.archived_ = false;
}
inline bool SpaceInfo::_internal_archived() const {
  return _impl_.archived_;
}
inline bool SpaceInfo::archived() const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceInfo.archived)
  return _internal_archived();
}
inline void SpaceInfo::_internal_set_archived(bool value) {
  
  _impl_.archived_ = value;
}
inline void SpaceInfo::set_archived(bool value) {
  _internal_set_archived(value);
  // @@protoc_insertion_point(field_set:ServerData.SpaceInfo.archived)
}

// string ownerId = 9;
inline void SpaceInfo::clear_ownerid() {
  _impl_.ownerid_.ClearToEmpty();
}
inline const std::string& SpaceInfo::ownerid() const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceInfo.ownerId)
  return _internal_ownerid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpaceInfo::set_ownerid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ownerid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.SpaceInfo.ownerId)
}
inline std::string* SpaceInfo::mutable_ownerid() {
  std::string* _s = _internal_mutable_ownerid();
  // @@protoc_insertion_point(field_mutable:ServerData.SpaceInfo.ownerId)
  return _s;
}
inline const std::string& SpaceInfo::_internal_ownerid() const {
  return _impl_.ownerid_.Get();
}
inline void SpaceInfo::_internal_set_ownerid(const std::string& value) {
  
  _impl_.ownerid_.Set(value, GetArenaForAllocation());
}
inline std::string* SpaceInfo::_internal_mutable_ownerid() {
  
  return _impl_.ownerid_.Mutable(GetArenaForAllocation());
}
inline std::string* SpaceInfo::release_ownerid() {
  // @@protoc_insertion_point(field_release:ServerData.SpaceInfo.ownerId)
  return _impl_.ownerid_.Release();
}
inline void SpaceInfo::set_allocated_ownerid(std::string* ownerid) {
  if (ownerid != nullptr) {
    
  } else {
    
  }
  _impl_.ownerid_.SetAllocated(ownerid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ownerid_.IsDefault()) {
    _impl_.ownerid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.SpaceInfo.ownerId)
}

// .google.protobuf.Timestamp lastAccess = 5;
inline bool SpaceInfo::_internal_has_lastaccess() const {
  return this != internal_default_instance() && _impl_.lastaccess_ != nullptr;
}
inline bool SpaceInfo::has_lastaccess() const {
  return _internal_has_lastaccess();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SpaceInfo::_internal_lastaccess() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.lastaccess_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SpaceInfo::lastaccess() const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceInfo.lastAccess)
  return _internal_lastaccess();
}
inline void SpaceInfo::unsafe_arena_set_allocated_lastaccess(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* lastaccess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lastaccess_);
  }
  _impl_.lastaccess_ = lastaccess;
  if (lastaccess) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.SpaceInfo.lastAccess)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpaceInfo::release_lastaccess() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.lastaccess_;
  _impl_.lastaccess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpaceInfo::unsafe_arena_release_lastaccess() {
  // @@protoc_insertion_point(field_release:ServerData.SpaceInfo.lastAccess)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.lastaccess_;
  _impl_.lastaccess_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpaceInfo::_internal_mutable_lastaccess() {
  
  if (_impl_.lastaccess_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.lastaccess_ = p;
  }
  return _impl_.lastaccess_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpaceInfo::mutable_lastaccess() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_lastaccess();
  // @@protoc_insertion_point(field_mutable:ServerData.SpaceInfo.lastAccess)
  return _msg;
}
inline void SpaceInfo::set_allocated_lastaccess(::PROTOBUF_NAMESPACE_ID::Timestamp* lastaccess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lastaccess_);
  }
  if (lastaccess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lastaccess));
    if (message_arena != submessage_arena) {
      lastaccess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lastaccess, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lastaccess_ = lastaccess;
  // @@protoc_insertion_point(field_set_allocated:ServerData.SpaceInfo.lastAccess)
}

// repeated string keywords = 6;
inline int SpaceInfo::_internal_keywords_size() const {
  return _impl_.keywords_.size();
}
inline int SpaceInfo::keywords_size() const {
  return _internal_keywords_size();
}
inline void SpaceInfo::clear_keywords() {
  _impl_.keywords_.Clear();
}
inline std::string* SpaceInfo::add_keywords() {
  std::string* _s = _internal_add_keywords();
  // @@protoc_insertion_point(field_add_mutable:ServerData.SpaceInfo.keywords)
  return _s;
}
inline const std::string& SpaceInfo::_internal_keywords(int index) const {
  return _impl_.keywords_.Get(index);
}
inline const std::string& SpaceInfo::keywords(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceInfo.keywords)
  return _internal_keywords(index);
}
inline std::string* SpaceInfo::mutable_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.SpaceInfo.keywords)
  return _impl_.keywords_.Mutable(index);
}
inline void SpaceInfo::set_keywords(int index, const std::string& value) {
  _impl_.keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerData.SpaceInfo.keywords)
}
inline void SpaceInfo::set_keywords(int index, std::string&& value) {
  _impl_.keywords_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerData.SpaceInfo.keywords)
}
inline void SpaceInfo::set_keywords(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerData.SpaceInfo.keywords)
}
inline void SpaceInfo::set_keywords(int index, const char* value, size_t size) {
  _impl_.keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerData.SpaceInfo.keywords)
}
inline std::string* SpaceInfo::_internal_add_keywords() {
  return _impl_.keywords_.Add();
}
inline void SpaceInfo::add_keywords(const std::string& value) {
  _impl_.keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerData.SpaceInfo.keywords)
}
inline void SpaceInfo::add_keywords(std::string&& value) {
  _impl_.keywords_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerData.SpaceInfo.keywords)
}
inline void SpaceInfo::add_keywords(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerData.SpaceInfo.keywords)
}
inline void SpaceInfo::add_keywords(const char* value, size_t size) {
  _impl_.keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerData.SpaceInfo.keywords)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SpaceInfo::keywords() const {
  // @@protoc_insertion_point(field_list:ServerData.SpaceInfo.keywords)
  return _impl_.keywords_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SpaceInfo::mutable_keywords() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.SpaceInfo.keywords)
  return &_impl_.keywords_;
}

// repeated .ServerData.Tag tags = 8;
inline int SpaceInfo::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int SpaceInfo::tags_size() const {
  return _internal_tags_size();
}
inline void SpaceInfo::clear_tags() {
  _impl_.tags_.Clear();
}
inline ::ServerData::Tag* SpaceInfo::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.SpaceInfo.tags)
  return _impl_.tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::Tag >*
SpaceInfo::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.SpaceInfo.tags)
  return &_impl_.tags_;
}
inline const ::ServerData::Tag& SpaceInfo::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const ::ServerData::Tag& SpaceInfo::tags(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceInfo.tags)
  return _internal_tags(index);
}
inline ::ServerData::Tag* SpaceInfo::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline ::ServerData::Tag* SpaceInfo::add_tags() {
  ::ServerData::Tag* _add = _internal_add_tags();
  // @@protoc_insertion_point(field_add:ServerData.SpaceInfo.tags)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::Tag >&
SpaceInfo::tags() const {
  // @@protoc_insertion_point(field_list:ServerData.SpaceInfo.tags)
  return _impl_.tags_;
}

// repeated .ServerData.CavrnusRoomMember currentSpaceMembers = 10;
inline int SpaceInfo::_internal_currentspacemembers_size() const {
  return _impl_.currentspacemembers_.size();
}
inline int SpaceInfo::currentspacemembers_size() const {
  return _internal_currentspacemembers_size();
}
inline void SpaceInfo::clear_currentspacemembers() {
  _impl_.currentspacemembers_.Clear();
}
inline ::ServerData::CavrnusRoomMember* SpaceInfo::mutable_currentspacemembers(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.SpaceInfo.currentSpaceMembers)
  return _impl_.currentspacemembers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRoomMember >*
SpaceInfo::mutable_currentspacemembers() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.SpaceInfo.currentSpaceMembers)
  return &_impl_.currentspacemembers_;
}
inline const ::ServerData::CavrnusRoomMember& SpaceInfo::_internal_currentspacemembers(int index) const {
  return _impl_.currentspacemembers_.Get(index);
}
inline const ::ServerData::CavrnusRoomMember& SpaceInfo::currentspacemembers(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.SpaceInfo.currentSpaceMembers)
  return _internal_currentspacemembers(index);
}
inline ::ServerData::CavrnusRoomMember* SpaceInfo::_internal_add_currentspacemembers() {
  return _impl_.currentspacemembers_.Add();
}
inline ::ServerData::CavrnusRoomMember* SpaceInfo::add_currentspacemembers() {
  ::ServerData::CavrnusRoomMember* _add = _internal_add_currentspacemembers();
  // @@protoc_insertion_point(field_add:ServerData.SpaceInfo.currentSpaceMembers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::CavrnusRoomMember >&
SpaceInfo::currentspacemembers() const {
  // @@protoc_insertion_point(field_list:ServerData.SpaceInfo.currentSpaceMembers)
  return _impl_.currentspacemembers_;
}

// -------------------------------------------------------------------

// RelayDataCache

// repeated string stringKeys = 1;
inline int RelayDataCache::_internal_stringkeys_size() const {
  return _impl_.stringkeys_.size();
}
inline int RelayDataCache::stringkeys_size() const {
  return _internal_stringkeys_size();
}
inline void RelayDataCache::clear_stringkeys() {
  _impl_.stringkeys_.Clear();
}
inline std::string* RelayDataCache::add_stringkeys() {
  std::string* _s = _internal_add_stringkeys();
  // @@protoc_insertion_point(field_add_mutable:ServerData.RelayDataCache.stringKeys)
  return _s;
}
inline const std::string& RelayDataCache::_internal_stringkeys(int index) const {
  return _impl_.stringkeys_.Get(index);
}
inline const std::string& RelayDataCache::stringkeys(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.RelayDataCache.stringKeys)
  return _internal_stringkeys(index);
}
inline std::string* RelayDataCache::mutable_stringkeys(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.RelayDataCache.stringKeys)
  return _impl_.stringkeys_.Mutable(index);
}
inline void RelayDataCache::set_stringkeys(int index, const std::string& value) {
  _impl_.stringkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerData.RelayDataCache.stringKeys)
}
inline void RelayDataCache::set_stringkeys(int index, std::string&& value) {
  _impl_.stringkeys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerData.RelayDataCache.stringKeys)
}
inline void RelayDataCache::set_stringkeys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stringkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerData.RelayDataCache.stringKeys)
}
inline void RelayDataCache::set_stringkeys(int index, const char* value, size_t size) {
  _impl_.stringkeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerData.RelayDataCache.stringKeys)
}
inline std::string* RelayDataCache::_internal_add_stringkeys() {
  return _impl_.stringkeys_.Add();
}
inline void RelayDataCache::add_stringkeys(const std::string& value) {
  _impl_.stringkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerData.RelayDataCache.stringKeys)
}
inline void RelayDataCache::add_stringkeys(std::string&& value) {
  _impl_.stringkeys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerData.RelayDataCache.stringKeys)
}
inline void RelayDataCache::add_stringkeys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stringkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerData.RelayDataCache.stringKeys)
}
inline void RelayDataCache::add_stringkeys(const char* value, size_t size) {
  _impl_.stringkeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerData.RelayDataCache.stringKeys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RelayDataCache::stringkeys() const {
  // @@protoc_insertion_point(field_list:ServerData.RelayDataCache.stringKeys)
  return _impl_.stringkeys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RelayDataCache::mutable_stringkeys() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.RelayDataCache.stringKeys)
  return &_impl_.stringkeys_;
}

// repeated string stringValues = 2;
inline int RelayDataCache::_internal_stringvalues_size() const {
  return _impl_.stringvalues_.size();
}
inline int RelayDataCache::stringvalues_size() const {
  return _internal_stringvalues_size();
}
inline void RelayDataCache::clear_stringvalues() {
  _impl_.stringvalues_.Clear();
}
inline std::string* RelayDataCache::add_stringvalues() {
  std::string* _s = _internal_add_stringvalues();
  // @@protoc_insertion_point(field_add_mutable:ServerData.RelayDataCache.stringValues)
  return _s;
}
inline const std::string& RelayDataCache::_internal_stringvalues(int index) const {
  return _impl_.stringvalues_.Get(index);
}
inline const std::string& RelayDataCache::stringvalues(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.RelayDataCache.stringValues)
  return _internal_stringvalues(index);
}
inline std::string* RelayDataCache::mutable_stringvalues(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.RelayDataCache.stringValues)
  return _impl_.stringvalues_.Mutable(index);
}
inline void RelayDataCache::set_stringvalues(int index, const std::string& value) {
  _impl_.stringvalues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerData.RelayDataCache.stringValues)
}
inline void RelayDataCache::set_stringvalues(int index, std::string&& value) {
  _impl_.stringvalues_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerData.RelayDataCache.stringValues)
}
inline void RelayDataCache::set_stringvalues(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stringvalues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerData.RelayDataCache.stringValues)
}
inline void RelayDataCache::set_stringvalues(int index, const char* value, size_t size) {
  _impl_.stringvalues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerData.RelayDataCache.stringValues)
}
inline std::string* RelayDataCache::_internal_add_stringvalues() {
  return _impl_.stringvalues_.Add();
}
inline void RelayDataCache::add_stringvalues(const std::string& value) {
  _impl_.stringvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerData.RelayDataCache.stringValues)
}
inline void RelayDataCache::add_stringvalues(std::string&& value) {
  _impl_.stringvalues_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerData.RelayDataCache.stringValues)
}
inline void RelayDataCache::add_stringvalues(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stringvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerData.RelayDataCache.stringValues)
}
inline void RelayDataCache::add_stringvalues(const char* value, size_t size) {
  _impl_.stringvalues_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerData.RelayDataCache.stringValues)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RelayDataCache::stringvalues() const {
  // @@protoc_insertion_point(field_list:ServerData.RelayDataCache.stringValues)
  return _impl_.stringvalues_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RelayDataCache::mutable_stringvalues() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.RelayDataCache.stringValues)
  return &_impl_.stringvalues_;
}

// -------------------------------------------------------------------

// CavrnusSpaceConnection

// int32 SpaceConnectionId = 1;
inline void CavrnusSpaceConnection::clear_spaceconnectionid() {
  _impl_.spaceconnectionid_ = 0;
}
inline int32_t CavrnusSpaceConnection::_internal_spaceconnectionid() const {
  return _impl_.spaceconnectionid_;
}
inline int32_t CavrnusSpaceConnection::spaceconnectionid() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusSpaceConnection.SpaceConnectionId)
  return _internal_spaceconnectionid();
}
inline void CavrnusSpaceConnection::_internal_set_spaceconnectionid(int32_t value) {
  
  _impl_.spaceconnectionid_ = value;
}
inline void CavrnusSpaceConnection::set_spaceconnectionid(int32_t value) {
  _internal_set_spaceconnectionid(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusSpaceConnection.SpaceConnectionId)
}

// -------------------------------------------------------------------

// CavrnusSpaceConnectionInfo

// int32 SpaceConnectionId = 1;
inline void CavrnusSpaceConnectionInfo::clear_spaceconnectionid() {
  _impl_.spaceconnectionid_ = 0;
}
inline int32_t CavrnusSpaceConnectionInfo::_internal_spaceconnectionid() const {
  return _impl_.spaceconnectionid_;
}
inline int32_t CavrnusSpaceConnectionInfo::spaceconnectionid() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusSpaceConnectionInfo.SpaceConnectionId)
  return _internal_spaceconnectionid();
}
inline void CavrnusSpaceConnectionInfo::_internal_set_spaceconnectionid(int32_t value) {
  
  _impl_.spaceconnectionid_ = value;
}
inline void CavrnusSpaceConnectionInfo::set_spaceconnectionid(int32_t value) {
  _internal_set_spaceconnectionid(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusSpaceConnectionInfo.SpaceConnectionId)
}

// string localUserConnectionId = 10;
inline void CavrnusSpaceConnectionInfo::clear_localuserconnectionid() {
  _impl_.localuserconnectionid_.ClearToEmpty();
}
inline const std::string& CavrnusSpaceConnectionInfo::localuserconnectionid() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusSpaceConnectionInfo.localUserConnectionId)
  return _internal_localuserconnectionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusSpaceConnectionInfo::set_localuserconnectionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.localuserconnectionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusSpaceConnectionInfo.localUserConnectionId)
}
inline std::string* CavrnusSpaceConnectionInfo::mutable_localuserconnectionid() {
  std::string* _s = _internal_mutable_localuserconnectionid();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusSpaceConnectionInfo.localUserConnectionId)
  return _s;
}
inline const std::string& CavrnusSpaceConnectionInfo::_internal_localuserconnectionid() const {
  return _impl_.localuserconnectionid_.Get();
}
inline void CavrnusSpaceConnectionInfo::_internal_set_localuserconnectionid(const std::string& value) {
  
  _impl_.localuserconnectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusSpaceConnectionInfo::_internal_mutable_localuserconnectionid() {
  
  return _impl_.localuserconnectionid_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusSpaceConnectionInfo::release_localuserconnectionid() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusSpaceConnectionInfo.localUserConnectionId)
  return _impl_.localuserconnectionid_.Release();
}
inline void CavrnusSpaceConnectionInfo::set_allocated_localuserconnectionid(std::string* localuserconnectionid) {
  if (localuserconnectionid != nullptr) {
    
  } else {
    
  }
  _impl_.localuserconnectionid_.SetAllocated(localuserconnectionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.localuserconnectionid_.IsDefault()) {
    _impl_.localuserconnectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusSpaceConnectionInfo.localUserConnectionId)
}

// bool spaceOwnedByLocalUser = 11;
inline void CavrnusSpaceConnectionInfo::clear_spaceownedbylocaluser() {
  _impl_.spaceownedbylocaluser_ = false;
}
inline bool CavrnusSpaceConnectionInfo::_internal_spaceownedbylocaluser() const {
  return _impl_.spaceownedbylocaluser_;
}
inline bool CavrnusSpaceConnectionInfo::spaceownedbylocaluser() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusSpaceConnectionInfo.spaceOwnedByLocalUser)
  return _internal_spaceownedbylocaluser();
}
inline void CavrnusSpaceConnectionInfo::_internal_set_spaceownedbylocaluser(bool value) {
  
  _impl_.spaceownedbylocaluser_ = value;
}
inline void CavrnusSpaceConnectionInfo::set_spaceownedbylocaluser(bool value) {
  _internal_set_spaceownedbylocaluser(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusSpaceConnectionInfo.spaceOwnedByLocalUser)
}

// .ServerData.SpaceInfo spaceInfo = 12;
inline bool CavrnusSpaceConnectionInfo::_internal_has_spaceinfo() const {
  return this != internal_default_instance() && _impl_.spaceinfo_ != nullptr;
}
inline bool CavrnusSpaceConnectionInfo::has_spaceinfo() const {
  return _internal_has_spaceinfo();
}
inline void CavrnusSpaceConnectionInfo::clear_spaceinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.spaceinfo_ != nullptr) {
    delete _impl_.spaceinfo_;
  }
  _impl_.spaceinfo_ = nullptr;
}
inline const ::ServerData::SpaceInfo& CavrnusSpaceConnectionInfo::_internal_spaceinfo() const {
  const ::ServerData::SpaceInfo* p = _impl_.spaceinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::SpaceInfo&>(
      ::ServerData::_SpaceInfo_default_instance_);
}
inline const ::ServerData::SpaceInfo& CavrnusSpaceConnectionInfo::spaceinfo() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusSpaceConnectionInfo.spaceInfo)
  return _internal_spaceinfo();
}
inline void CavrnusSpaceConnectionInfo::unsafe_arena_set_allocated_spaceinfo(
    ::ServerData::SpaceInfo* spaceinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spaceinfo_);
  }
  _impl_.spaceinfo_ = spaceinfo;
  if (spaceinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.CavrnusSpaceConnectionInfo.spaceInfo)
}
inline ::ServerData::SpaceInfo* CavrnusSpaceConnectionInfo::release_spaceinfo() {
  
  ::ServerData::SpaceInfo* temp = _impl_.spaceinfo_;
  _impl_.spaceinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::SpaceInfo* CavrnusSpaceConnectionInfo::unsafe_arena_release_spaceinfo() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusSpaceConnectionInfo.spaceInfo)
  
  ::ServerData::SpaceInfo* temp = _impl_.spaceinfo_;
  _impl_.spaceinfo_ = nullptr;
  return temp;
}
inline ::ServerData::SpaceInfo* CavrnusSpaceConnectionInfo::_internal_mutable_spaceinfo() {
  
  if (_impl_.spaceinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::SpaceInfo>(GetArenaForAllocation());
    _impl_.spaceinfo_ = p;
  }
  return _impl_.spaceinfo_;
}
inline ::ServerData::SpaceInfo* CavrnusSpaceConnectionInfo::mutable_spaceinfo() {
  ::ServerData::SpaceInfo* _msg = _internal_mutable_spaceinfo();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusSpaceConnectionInfo.spaceInfo)
  return _msg;
}
inline void CavrnusSpaceConnectionInfo::set_allocated_spaceinfo(::ServerData::SpaceInfo* spaceinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.spaceinfo_;
  }
  if (spaceinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spaceinfo);
    if (message_arena != submessage_arena) {
      spaceinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spaceinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spaceinfo_ = spaceinfo;
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusSpaceConnectionInfo.spaceInfo)
}

// -------------------------------------------------------------------

// CavrnusUser

// string userConnectionId = 1;
inline void CavrnusUser::clear_userconnectionid() {
  _impl_.userconnectionid_.ClearToEmpty();
}
inline const std::string& CavrnusUser::userconnectionid() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusUser.userConnectionId)
  return _internal_userconnectionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusUser::set_userconnectionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userconnectionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusUser.userConnectionId)
}
inline std::string* CavrnusUser::mutable_userconnectionid() {
  std::string* _s = _internal_mutable_userconnectionid();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusUser.userConnectionId)
  return _s;
}
inline const std::string& CavrnusUser::_internal_userconnectionid() const {
  return _impl_.userconnectionid_.Get();
}
inline void CavrnusUser::_internal_set_userconnectionid(const std::string& value) {
  
  _impl_.userconnectionid_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusUser::_internal_mutable_userconnectionid() {
  
  return _impl_.userconnectionid_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusUser::release_userconnectionid() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusUser.userConnectionId)
  return _impl_.userconnectionid_.Release();
}
inline void CavrnusUser::set_allocated_userconnectionid(std::string* userconnectionid) {
  if (userconnectionid != nullptr) {
    
  } else {
    
  }
  _impl_.userconnectionid_.SetAllocated(userconnectionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userconnectionid_.IsDefault()) {
    _impl_.userconnectionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusUser.userConnectionId)
}

// bool IsLocalUser = 2;
inline void CavrnusUser::clear_islocaluser() {
  _impl_.islocaluser_ = false;
}
inline bool CavrnusUser::_internal_islocaluser() const {
  return _impl_.islocaluser_;
}
inline bool CavrnusUser::islocaluser() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusUser.IsLocalUser)
  return _internal_islocaluser();
}
inline void CavrnusUser::_internal_set_islocaluser(bool value) {
  
  _impl_.islocaluser_ = value;
}
inline void CavrnusUser::set_islocaluser(bool value) {
  _internal_set_islocaluser(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusUser.IsLocalUser)
}

// -------------------------------------------------------------------

// CavrnusRoomMember

// .ServerData.CavrnusUserAccount user = 1;
inline bool CavrnusRoomMember::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool CavrnusRoomMember::has_user() const {
  return _internal_has_user();
}
inline void CavrnusRoomMember::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::ServerData::CavrnusUserAccount& CavrnusRoomMember::_internal_user() const {
  const ::ServerData::CavrnusUserAccount* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerData::CavrnusUserAccount&>(
      ::ServerData::_CavrnusUserAccount_default_instance_);
}
inline const ::ServerData::CavrnusUserAccount& CavrnusRoomMember::user() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRoomMember.user)
  return _internal_user();
}
inline void CavrnusRoomMember::unsafe_arena_set_allocated_user(
    ::ServerData::CavrnusUserAccount* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerData.CavrnusRoomMember.user)
}
inline ::ServerData::CavrnusUserAccount* CavrnusRoomMember::release_user() {
  
  ::ServerData::CavrnusUserAccount* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerData::CavrnusUserAccount* CavrnusRoomMember::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusRoomMember.user)
  
  ::ServerData::CavrnusUserAccount* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::ServerData::CavrnusUserAccount* CavrnusRoomMember::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerData::CavrnusUserAccount>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::ServerData::CavrnusUserAccount* CavrnusRoomMember::mutable_user() {
  ::ServerData::CavrnusUserAccount* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRoomMember.user)
  return _msg;
}
inline void CavrnusRoomMember::set_allocated_user(::ServerData::CavrnusUserAccount* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusRoomMember.user)
}

// bool isOwner = 2;
inline void CavrnusRoomMember::clear_isowner() {
  _impl_.isowner_ = false;
}
inline bool CavrnusRoomMember::_internal_isowner() const {
  return _impl_.isowner_;
}
inline bool CavrnusRoomMember::isowner() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRoomMember.isOwner)
  return _internal_isowner();
}
inline void CavrnusRoomMember::_internal_set_isowner(bool value) {
  
  _impl_.isowner_ = value;
}
inline void CavrnusRoomMember::set_isowner(bool value) {
  _internal_set_isowner(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRoomMember.isOwner)
}

// bool hasJoined = 3;
inline void CavrnusRoomMember::clear_hasjoined() {
  _impl_.hasjoined_ = false;
}
inline bool CavrnusRoomMember::_internal_hasjoined() const {
  return _impl_.hasjoined_;
}
inline bool CavrnusRoomMember::hasjoined() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRoomMember.hasJoined)
  return _internal_hasjoined();
}
inline void CavrnusRoomMember::_internal_set_hasjoined(bool value) {
  
  _impl_.hasjoined_ = value;
}
inline void CavrnusRoomMember::set_hasjoined(bool value) {
  _internal_set_hasjoined(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRoomMember.hasJoined)
}

// repeated string roles = 30;
inline int CavrnusRoomMember::_internal_roles_size() const {
  return _impl_.roles_.size();
}
inline int CavrnusRoomMember::roles_size() const {
  return _internal_roles_size();
}
inline void CavrnusRoomMember::clear_roles() {
  _impl_.roles_.Clear();
}
inline std::string* CavrnusRoomMember::add_roles() {
  std::string* _s = _internal_add_roles();
  // @@protoc_insertion_point(field_add_mutable:ServerData.CavrnusRoomMember.roles)
  return _s;
}
inline const std::string& CavrnusRoomMember::_internal_roles(int index) const {
  return _impl_.roles_.Get(index);
}
inline const std::string& CavrnusRoomMember::roles(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRoomMember.roles)
  return _internal_roles(index);
}
inline std::string* CavrnusRoomMember::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRoomMember.roles)
  return _impl_.roles_.Mutable(index);
}
inline void CavrnusRoomMember::set_roles(int index, const std::string& value) {
  _impl_.roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRoomMember.roles)
}
inline void CavrnusRoomMember::set_roles(int index, std::string&& value) {
  _impl_.roles_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRoomMember.roles)
}
inline void CavrnusRoomMember::set_roles(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerData.CavrnusRoomMember.roles)
}
inline void CavrnusRoomMember::set_roles(int index, const char* value, size_t size) {
  _impl_.roles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerData.CavrnusRoomMember.roles)
}
inline std::string* CavrnusRoomMember::_internal_add_roles() {
  return _impl_.roles_.Add();
}
inline void CavrnusRoomMember::add_roles(const std::string& value) {
  _impl_.roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerData.CavrnusRoomMember.roles)
}
inline void CavrnusRoomMember::add_roles(std::string&& value) {
  _impl_.roles_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerData.CavrnusRoomMember.roles)
}
inline void CavrnusRoomMember::add_roles(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerData.CavrnusRoomMember.roles)
}
inline void CavrnusRoomMember::add_roles(const char* value, size_t size) {
  _impl_.roles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerData.CavrnusRoomMember.roles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CavrnusRoomMember::roles() const {
  // @@protoc_insertion_point(field_list:ServerData.CavrnusRoomMember.roles)
  return _impl_.roles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CavrnusRoomMember::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.CavrnusRoomMember.roles)
  return &_impl_.roles_;
}

// -------------------------------------------------------------------

// CavrnusUserAccount

// string userAccountId = 1;
inline void CavrnusUserAccount::clear_useraccountid() {
  _impl_.useraccountid_.ClearToEmpty();
}
inline const std::string& CavrnusUserAccount::useraccountid() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusUserAccount.userAccountId)
  return _internal_useraccountid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusUserAccount::set_useraccountid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.useraccountid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusUserAccount.userAccountId)
}
inline std::string* CavrnusUserAccount::mutable_useraccountid() {
  std::string* _s = _internal_mutable_useraccountid();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusUserAccount.userAccountId)
  return _s;
}
inline const std::string& CavrnusUserAccount::_internal_useraccountid() const {
  return _impl_.useraccountid_.Get();
}
inline void CavrnusUserAccount::_internal_set_useraccountid(const std::string& value) {
  
  _impl_.useraccountid_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusUserAccount::_internal_mutable_useraccountid() {
  
  return _impl_.useraccountid_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusUserAccount::release_useraccountid() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusUserAccount.userAccountId)
  return _impl_.useraccountid_.Release();
}
inline void CavrnusUserAccount::set_allocated_useraccountid(std::string* useraccountid) {
  if (useraccountid != nullptr) {
    
  } else {
    
  }
  _impl_.useraccountid_.SetAllocated(useraccountid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.useraccountid_.IsDefault()) {
    _impl_.useraccountid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusUserAccount.userAccountId)
}

// bool IsLocalUserAccount = 2;
inline void CavrnusUserAccount::clear_islocaluseraccount() {
  _impl_.islocaluseraccount_ = false;
}
inline bool CavrnusUserAccount::_internal_islocaluseraccount() const {
  return _impl_.islocaluseraccount_;
}
inline bool CavrnusUserAccount::islocaluseraccount() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusUserAccount.IsLocalUserAccount)
  return _internal_islocaluseraccount();
}
inline void CavrnusUserAccount::_internal_set_islocaluseraccount(bool value) {
  
  _impl_.islocaluseraccount_ = value;
}
inline void CavrnusUserAccount::set_islocaluseraccount(bool value) {
  _internal_set_islocaluseraccount(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusUserAccount.IsLocalUserAccount)
}

// string userEmail = 10;
inline void CavrnusUserAccount::clear_useremail() {
  _impl_.useremail_.ClearToEmpty();
}
inline const std::string& CavrnusUserAccount::useremail() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusUserAccount.userEmail)
  return _internal_useremail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusUserAccount::set_useremail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.useremail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusUserAccount.userEmail)
}
inline std::string* CavrnusUserAccount::mutable_useremail() {
  std::string* _s = _internal_mutable_useremail();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusUserAccount.userEmail)
  return _s;
}
inline const std::string& CavrnusUserAccount::_internal_useremail() const {
  return _impl_.useremail_.Get();
}
inline void CavrnusUserAccount::_internal_set_useremail(const std::string& value) {
  
  _impl_.useremail_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusUserAccount::_internal_mutable_useremail() {
  
  return _impl_.useremail_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusUserAccount::release_useremail() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusUserAccount.userEmail)
  return _impl_.useremail_.Release();
}
inline void CavrnusUserAccount::set_allocated_useremail(std::string* useremail) {
  if (useremail != nullptr) {
    
  } else {
    
  }
  _impl_.useremail_.SetAllocated(useremail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.useremail_.IsDefault()) {
    _impl_.useremail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusUserAccount.userEmail)
}

// string userProfilePic = 11;
inline void CavrnusUserAccount::clear_userprofilepic() {
  _impl_.userprofilepic_.ClearToEmpty();
}
inline const std::string& CavrnusUserAccount::userprofilepic() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusUserAccount.userProfilePic)
  return _internal_userprofilepic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusUserAccount::set_userprofilepic(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userprofilepic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusUserAccount.userProfilePic)
}
inline std::string* CavrnusUserAccount::mutable_userprofilepic() {
  std::string* _s = _internal_mutable_userprofilepic();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusUserAccount.userProfilePic)
  return _s;
}
inline const std::string& CavrnusUserAccount::_internal_userprofilepic() const {
  return _impl_.userprofilepic_.Get();
}
inline void CavrnusUserAccount::_internal_set_userprofilepic(const std::string& value) {
  
  _impl_.userprofilepic_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusUserAccount::_internal_mutable_userprofilepic() {
  
  return _impl_.userprofilepic_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusUserAccount::release_userprofilepic() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusUserAccount.userProfilePic)
  return _impl_.userprofilepic_.Release();
}
inline void CavrnusUserAccount::set_allocated_userprofilepic(std::string* userprofilepic) {
  if (userprofilepic != nullptr) {
    
  } else {
    
  }
  _impl_.userprofilepic_.SetAllocated(userprofilepic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userprofilepic_.IsDefault()) {
    _impl_.userprofilepic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusUserAccount.userProfilePic)
}

// string userFirstName = 12;
inline void CavrnusUserAccount::clear_userfirstname() {
  _impl_.userfirstname_.ClearToEmpty();
}
inline const std::string& CavrnusUserAccount::userfirstname() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusUserAccount.userFirstName)
  return _internal_userfirstname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusUserAccount::set_userfirstname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userfirstname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusUserAccount.userFirstName)
}
inline std::string* CavrnusUserAccount::mutable_userfirstname() {
  std::string* _s = _internal_mutable_userfirstname();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusUserAccount.userFirstName)
  return _s;
}
inline const std::string& CavrnusUserAccount::_internal_userfirstname() const {
  return _impl_.userfirstname_.Get();
}
inline void CavrnusUserAccount::_internal_set_userfirstname(const std::string& value) {
  
  _impl_.userfirstname_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusUserAccount::_internal_mutable_userfirstname() {
  
  return _impl_.userfirstname_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusUserAccount::release_userfirstname() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusUserAccount.userFirstName)
  return _impl_.userfirstname_.Release();
}
inline void CavrnusUserAccount::set_allocated_userfirstname(std::string* userfirstname) {
  if (userfirstname != nullptr) {
    
  } else {
    
  }
  _impl_.userfirstname_.SetAllocated(userfirstname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userfirstname_.IsDefault()) {
    _impl_.userfirstname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusUserAccount.userFirstName)
}

// string userLastName = 13;
inline void CavrnusUserAccount::clear_userlastname() {
  _impl_.userlastname_.ClearToEmpty();
}
inline const std::string& CavrnusUserAccount::userlastname() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusUserAccount.userLastName)
  return _internal_userlastname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusUserAccount::set_userlastname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userlastname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusUserAccount.userLastName)
}
inline std::string* CavrnusUserAccount::mutable_userlastname() {
  std::string* _s = _internal_mutable_userlastname();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusUserAccount.userLastName)
  return _s;
}
inline const std::string& CavrnusUserAccount::_internal_userlastname() const {
  return _impl_.userlastname_.Get();
}
inline void CavrnusUserAccount::_internal_set_userlastname(const std::string& value) {
  
  _impl_.userlastname_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusUserAccount::_internal_mutable_userlastname() {
  
  return _impl_.userlastname_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusUserAccount::release_userlastname() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusUserAccount.userLastName)
  return _impl_.userlastname_.Release();
}
inline void CavrnusUserAccount::set_allocated_userlastname(std::string* userlastname) {
  if (userlastname != nullptr) {
    
  } else {
    
  }
  _impl_.userlastname_.SetAllocated(userlastname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userlastname_.IsDefault()) {
    _impl_.userlastname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusUserAccount.userLastName)
}

// string userDisplayName = 14;
inline void CavrnusUserAccount::clear_userdisplayname() {
  _impl_.userdisplayname_.ClearToEmpty();
}
inline const std::string& CavrnusUserAccount::userdisplayname() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusUserAccount.userDisplayName)
  return _internal_userdisplayname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusUserAccount::set_userdisplayname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userdisplayname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusUserAccount.userDisplayName)
}
inline std::string* CavrnusUserAccount::mutable_userdisplayname() {
  std::string* _s = _internal_mutable_userdisplayname();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusUserAccount.userDisplayName)
  return _s;
}
inline const std::string& CavrnusUserAccount::_internal_userdisplayname() const {
  return _impl_.userdisplayname_.Get();
}
inline void CavrnusUserAccount::_internal_set_userdisplayname(const std::string& value) {
  
  _impl_.userdisplayname_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusUserAccount::_internal_mutable_userdisplayname() {
  
  return _impl_.userdisplayname_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusUserAccount::release_userdisplayname() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusUserAccount.userDisplayName)
  return _impl_.userdisplayname_.Release();
}
inline void CavrnusUserAccount::set_allocated_userdisplayname(std::string* userdisplayname) {
  if (userdisplayname != nullptr) {
    
  } else {
    
  }
  _impl_.userdisplayname_.SetAllocated(userdisplayname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userdisplayname_.IsDefault()) {
    _impl_.userdisplayname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusUserAccount.userDisplayName)
}

// repeated string roles = 30;
inline int CavrnusUserAccount::_internal_roles_size() const {
  return _impl_.roles_.size();
}
inline int CavrnusUserAccount::roles_size() const {
  return _internal_roles_size();
}
inline void CavrnusUserAccount::clear_roles() {
  _impl_.roles_.Clear();
}
inline std::string* CavrnusUserAccount::add_roles() {
  std::string* _s = _internal_add_roles();
  // @@protoc_insertion_point(field_add_mutable:ServerData.CavrnusUserAccount.roles)
  return _s;
}
inline const std::string& CavrnusUserAccount::_internal_roles(int index) const {
  return _impl_.roles_.Get(index);
}
inline const std::string& CavrnusUserAccount::roles(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusUserAccount.roles)
  return _internal_roles(index);
}
inline std::string* CavrnusUserAccount::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusUserAccount.roles)
  return _impl_.roles_.Mutable(index);
}
inline void CavrnusUserAccount::set_roles(int index, const std::string& value) {
  _impl_.roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusUserAccount.roles)
}
inline void CavrnusUserAccount::set_roles(int index, std::string&& value) {
  _impl_.roles_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerData.CavrnusUserAccount.roles)
}
inline void CavrnusUserAccount::set_roles(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerData.CavrnusUserAccount.roles)
}
inline void CavrnusUserAccount::set_roles(int index, const char* value, size_t size) {
  _impl_.roles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerData.CavrnusUserAccount.roles)
}
inline std::string* CavrnusUserAccount::_internal_add_roles() {
  return _impl_.roles_.Add();
}
inline void CavrnusUserAccount::add_roles(const std::string& value) {
  _impl_.roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerData.CavrnusUserAccount.roles)
}
inline void CavrnusUserAccount::add_roles(std::string&& value) {
  _impl_.roles_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerData.CavrnusUserAccount.roles)
}
inline void CavrnusUserAccount::add_roles(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerData.CavrnusUserAccount.roles)
}
inline void CavrnusUserAccount::add_roles(const char* value, size_t size) {
  _impl_.roles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerData.CavrnusUserAccount.roles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CavrnusUserAccount::roles() const {
  // @@protoc_insertion_point(field_list:ServerData.CavrnusUserAccount.roles)
  return _impl_.roles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CavrnusUserAccount::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.CavrnusUserAccount.roles)
  return &_impl_.roles_;
}

// -------------------------------------------------------------------

// CavrnusRole

// string roleId = 1;
inline void CavrnusRole::clear_roleid() {
  _impl_.roleid_.ClearToEmpty();
}
inline const std::string& CavrnusRole::roleid() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRole.roleId)
  return _internal_roleid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusRole::set_roleid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roleid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRole.roleId)
}
inline std::string* CavrnusRole::mutable_roleid() {
  std::string* _s = _internal_mutable_roleid();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRole.roleId)
  return _s;
}
inline const std::string& CavrnusRole::_internal_roleid() const {
  return _impl_.roleid_.Get();
}
inline void CavrnusRole::_internal_set_roleid(const std::string& value) {
  
  _impl_.roleid_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusRole::_internal_mutable_roleid() {
  
  return _impl_.roleid_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusRole::release_roleid() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusRole.roleId)
  return _impl_.roleid_.Release();
}
inline void CavrnusRole::set_allocated_roleid(std::string* roleid) {
  if (roleid != nullptr) {
    
  } else {
    
  }
  _impl_.roleid_.SetAllocated(roleid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roleid_.IsDefault()) {
    _impl_.roleid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusRole.roleId)
}

// string roleName = 2;
inline void CavrnusRole::clear_rolename() {
  _impl_.rolename_.ClearToEmpty();
}
inline const std::string& CavrnusRole::rolename() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRole.roleName)
  return _internal_rolename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusRole::set_rolename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rolename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRole.roleName)
}
inline std::string* CavrnusRole::mutable_rolename() {
  std::string* _s = _internal_mutable_rolename();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRole.roleName)
  return _s;
}
inline const std::string& CavrnusRole::_internal_rolename() const {
  return _impl_.rolename_.Get();
}
inline void CavrnusRole::_internal_set_rolename(const std::string& value) {
  
  _impl_.rolename_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusRole::_internal_mutable_rolename() {
  
  return _impl_.rolename_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusRole::release_rolename() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusRole.roleName)
  return _impl_.rolename_.Release();
}
inline void CavrnusRole::set_allocated_rolename(std::string* rolename) {
  if (rolename != nullptr) {
    
  } else {
    
  }
  _impl_.rolename_.SetAllocated(rolename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rolename_.IsDefault()) {
    _impl_.rolename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusRole.roleName)
}

// -------------------------------------------------------------------

// RtcAudioInputDevice

// string id = 1;
inline void RtcAudioInputDevice::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& RtcAudioInputDevice::id() const {
  // @@protoc_insertion_point(field_get:ServerData.RtcAudioInputDevice.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtcAudioInputDevice::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RtcAudioInputDevice.id)
}
inline std::string* RtcAudioInputDevice::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ServerData.RtcAudioInputDevice.id)
  return _s;
}
inline const std::string& RtcAudioInputDevice::_internal_id() const {
  return _impl_.id_.Get();
}
inline void RtcAudioInputDevice::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* RtcAudioInputDevice::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* RtcAudioInputDevice::release_id() {
  // @@protoc_insertion_point(field_release:ServerData.RtcAudioInputDevice.id)
  return _impl_.id_.Release();
}
inline void RtcAudioInputDevice::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RtcAudioInputDevice.id)
}

// string name = 2;
inline void RtcAudioInputDevice::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RtcAudioInputDevice::name() const {
  // @@protoc_insertion_point(field_get:ServerData.RtcAudioInputDevice.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtcAudioInputDevice::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RtcAudioInputDevice.name)
}
inline std::string* RtcAudioInputDevice::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ServerData.RtcAudioInputDevice.name)
  return _s;
}
inline const std::string& RtcAudioInputDevice::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RtcAudioInputDevice::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RtcAudioInputDevice::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RtcAudioInputDevice::release_name() {
  // @@protoc_insertion_point(field_release:ServerData.RtcAudioInputDevice.name)
  return _impl_.name_.Release();
}
inline void RtcAudioInputDevice::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RtcAudioInputDevice.name)
}

// -------------------------------------------------------------------

// RtcAudioInputDeviceList

// repeated .ServerData.RtcAudioInputDevice devices = 1;
inline int RtcAudioInputDeviceList::_internal_devices_size() const {
  return _impl_.devices_.size();
}
inline int RtcAudioInputDeviceList::devices_size() const {
  return _internal_devices_size();
}
inline void RtcAudioInputDeviceList::clear_devices() {
  _impl_.devices_.Clear();
}
inline ::ServerData::RtcAudioInputDevice* RtcAudioInputDeviceList::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.RtcAudioInputDeviceList.devices)
  return _impl_.devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioInputDevice >*
RtcAudioInputDeviceList::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.RtcAudioInputDeviceList.devices)
  return &_impl_.devices_;
}
inline const ::ServerData::RtcAudioInputDevice& RtcAudioInputDeviceList::_internal_devices(int index) const {
  return _impl_.devices_.Get(index);
}
inline const ::ServerData::RtcAudioInputDevice& RtcAudioInputDeviceList::devices(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.RtcAudioInputDeviceList.devices)
  return _internal_devices(index);
}
inline ::ServerData::RtcAudioInputDevice* RtcAudioInputDeviceList::_internal_add_devices() {
  return _impl_.devices_.Add();
}
inline ::ServerData::RtcAudioInputDevice* RtcAudioInputDeviceList::add_devices() {
  ::ServerData::RtcAudioInputDevice* _add = _internal_add_devices();
  // @@protoc_insertion_point(field_add:ServerData.RtcAudioInputDeviceList.devices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioInputDevice >&
RtcAudioInputDeviceList::devices() const {
  // @@protoc_insertion_point(field_list:ServerData.RtcAudioInputDeviceList.devices)
  return _impl_.devices_;
}

// -------------------------------------------------------------------

// RtcAudioOutputDevice

// string id = 1;
inline void RtcAudioOutputDevice::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& RtcAudioOutputDevice::id() const {
  // @@protoc_insertion_point(field_get:ServerData.RtcAudioOutputDevice.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtcAudioOutputDevice::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RtcAudioOutputDevice.id)
}
inline std::string* RtcAudioOutputDevice::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ServerData.RtcAudioOutputDevice.id)
  return _s;
}
inline const std::string& RtcAudioOutputDevice::_internal_id() const {
  return _impl_.id_.Get();
}
inline void RtcAudioOutputDevice::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* RtcAudioOutputDevice::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* RtcAudioOutputDevice::release_id() {
  // @@protoc_insertion_point(field_release:ServerData.RtcAudioOutputDevice.id)
  return _impl_.id_.Release();
}
inline void RtcAudioOutputDevice::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RtcAudioOutputDevice.id)
}

// string name = 2;
inline void RtcAudioOutputDevice::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RtcAudioOutputDevice::name() const {
  // @@protoc_insertion_point(field_get:ServerData.RtcAudioOutputDevice.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtcAudioOutputDevice::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RtcAudioOutputDevice.name)
}
inline std::string* RtcAudioOutputDevice::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ServerData.RtcAudioOutputDevice.name)
  return _s;
}
inline const std::string& RtcAudioOutputDevice::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RtcAudioOutputDevice::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RtcAudioOutputDevice::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RtcAudioOutputDevice::release_name() {
  // @@protoc_insertion_point(field_release:ServerData.RtcAudioOutputDevice.name)
  return _impl_.name_.Release();
}
inline void RtcAudioOutputDevice::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RtcAudioOutputDevice.name)
}

// -------------------------------------------------------------------

// RtcAudioOutputDeviceList

// repeated .ServerData.RtcAudioOutputDevice devices = 1;
inline int RtcAudioOutputDeviceList::_internal_devices_size() const {
  return _impl_.devices_.size();
}
inline int RtcAudioOutputDeviceList::devices_size() const {
  return _internal_devices_size();
}
inline void RtcAudioOutputDeviceList::clear_devices() {
  _impl_.devices_.Clear();
}
inline ::ServerData::RtcAudioOutputDevice* RtcAudioOutputDeviceList::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.RtcAudioOutputDeviceList.devices)
  return _impl_.devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioOutputDevice >*
RtcAudioOutputDeviceList::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.RtcAudioOutputDeviceList.devices)
  return &_impl_.devices_;
}
inline const ::ServerData::RtcAudioOutputDevice& RtcAudioOutputDeviceList::_internal_devices(int index) const {
  return _impl_.devices_.Get(index);
}
inline const ::ServerData::RtcAudioOutputDevice& RtcAudioOutputDeviceList::devices(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.RtcAudioOutputDeviceList.devices)
  return _internal_devices(index);
}
inline ::ServerData::RtcAudioOutputDevice* RtcAudioOutputDeviceList::_internal_add_devices() {
  return _impl_.devices_.Add();
}
inline ::ServerData::RtcAudioOutputDevice* RtcAudioOutputDeviceList::add_devices() {
  ::ServerData::RtcAudioOutputDevice* _add = _internal_add_devices();
  // @@protoc_insertion_point(field_add:ServerData.RtcAudioOutputDeviceList.devices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcAudioOutputDevice >&
RtcAudioOutputDeviceList::devices() const {
  // @@protoc_insertion_point(field_list:ServerData.RtcAudioOutputDeviceList.devices)
  return _impl_.devices_;
}

// -------------------------------------------------------------------

// RtcVideoInputDevice

// string id = 1;
inline void RtcVideoInputDevice::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& RtcVideoInputDevice::id() const {
  // @@protoc_insertion_point(field_get:ServerData.RtcVideoInputDevice.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtcVideoInputDevice::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RtcVideoInputDevice.id)
}
inline std::string* RtcVideoInputDevice::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ServerData.RtcVideoInputDevice.id)
  return _s;
}
inline const std::string& RtcVideoInputDevice::_internal_id() const {
  return _impl_.id_.Get();
}
inline void RtcVideoInputDevice::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* RtcVideoInputDevice::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* RtcVideoInputDevice::release_id() {
  // @@protoc_insertion_point(field_release:ServerData.RtcVideoInputDevice.id)
  return _impl_.id_.Release();
}
inline void RtcVideoInputDevice::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RtcVideoInputDevice.id)
}

// string name = 2;
inline void RtcVideoInputDevice::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RtcVideoInputDevice::name() const {
  // @@protoc_insertion_point(field_get:ServerData.RtcVideoInputDevice.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtcVideoInputDevice::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.RtcVideoInputDevice.name)
}
inline std::string* RtcVideoInputDevice::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ServerData.RtcVideoInputDevice.name)
  return _s;
}
inline const std::string& RtcVideoInputDevice::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RtcVideoInputDevice::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RtcVideoInputDevice::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RtcVideoInputDevice::release_name() {
  // @@protoc_insertion_point(field_release:ServerData.RtcVideoInputDevice.name)
  return _impl_.name_.Release();
}
inline void RtcVideoInputDevice::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.RtcVideoInputDevice.name)
}

// -------------------------------------------------------------------

// RtcVideoInputDeviceList

// repeated .ServerData.RtcVideoInputDevice devices = 1;
inline int RtcVideoInputDeviceList::_internal_devices_size() const {
  return _impl_.devices_.size();
}
inline int RtcVideoInputDeviceList::devices_size() const {
  return _internal_devices_size();
}
inline void RtcVideoInputDeviceList::clear_devices() {
  _impl_.devices_.Clear();
}
inline ::ServerData::RtcVideoInputDevice* RtcVideoInputDeviceList::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.RtcVideoInputDeviceList.devices)
  return _impl_.devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcVideoInputDevice >*
RtcVideoInputDeviceList::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.RtcVideoInputDeviceList.devices)
  return &_impl_.devices_;
}
inline const ::ServerData::RtcVideoInputDevice& RtcVideoInputDeviceList::_internal_devices(int index) const {
  return _impl_.devices_.Get(index);
}
inline const ::ServerData::RtcVideoInputDevice& RtcVideoInputDeviceList::devices(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.RtcVideoInputDeviceList.devices)
  return _internal_devices(index);
}
inline ::ServerData::RtcVideoInputDevice* RtcVideoInputDeviceList::_internal_add_devices() {
  return _impl_.devices_.Add();
}
inline ::ServerData::RtcVideoInputDevice* RtcVideoInputDeviceList::add_devices() {
  ::ServerData::RtcVideoInputDevice* _add = _internal_add_devices();
  // @@protoc_insertion_point(field_add:ServerData.RtcVideoInputDeviceList.devices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerData::RtcVideoInputDevice >&
RtcVideoInputDeviceList::devices() const {
  // @@protoc_insertion_point(field_list:ServerData.RtcVideoInputDeviceList.devices)
  return _impl_.devices_;
}

// -------------------------------------------------------------------

// CavrnusRemoteContent

// string id = 1;
inline void CavrnusRemoteContent::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CavrnusRemoteContent::id() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRemoteContent.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusRemoteContent::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.id)
}
inline std::string* CavrnusRemoteContent::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRemoteContent.id)
  return _s;
}
inline const std::string& CavrnusRemoteContent::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CavrnusRemoteContent::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::release_id() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusRemoteContent.id)
  return _impl_.id_.Release();
}
inline void CavrnusRemoteContent::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusRemoteContent.id)
}

// string name = 2;
inline void CavrnusRemoteContent::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CavrnusRemoteContent::name() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRemoteContent.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusRemoteContent::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.name)
}
inline std::string* CavrnusRemoteContent::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRemoteContent.name)
  return _s;
}
inline const std::string& CavrnusRemoteContent::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CavrnusRemoteContent::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::release_name() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusRemoteContent.name)
  return _impl_.name_.Release();
}
inline void CavrnusRemoteContent::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusRemoteContent.name)
}

// string fileName = 3;
inline void CavrnusRemoteContent::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& CavrnusRemoteContent::filename() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRemoteContent.fileName)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusRemoteContent::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.fileName)
}
inline std::string* CavrnusRemoteContent::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRemoteContent.fileName)
  return _s;
}
inline const std::string& CavrnusRemoteContent::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void CavrnusRemoteContent::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::release_filename() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusRemoteContent.fileName)
  return _impl_.filename_.Release();
}
inline void CavrnusRemoteContent::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusRemoteContent.fileName)
}

// string thumbnailUrl = 4;
inline void CavrnusRemoteContent::clear_thumbnailurl() {
  _impl_.thumbnailurl_.ClearToEmpty();
}
inline const std::string& CavrnusRemoteContent::thumbnailurl() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRemoteContent.thumbnailUrl)
  return _internal_thumbnailurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusRemoteContent::set_thumbnailurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thumbnailurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.thumbnailUrl)
}
inline std::string* CavrnusRemoteContent::mutable_thumbnailurl() {
  std::string* _s = _internal_mutable_thumbnailurl();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRemoteContent.thumbnailUrl)
  return _s;
}
inline const std::string& CavrnusRemoteContent::_internal_thumbnailurl() const {
  return _impl_.thumbnailurl_.Get();
}
inline void CavrnusRemoteContent::_internal_set_thumbnailurl(const std::string& value) {
  
  _impl_.thumbnailurl_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::_internal_mutable_thumbnailurl() {
  
  return _impl_.thumbnailurl_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::release_thumbnailurl() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusRemoteContent.thumbnailUrl)
  return _impl_.thumbnailurl_.Release();
}
inline void CavrnusRemoteContent::set_allocated_thumbnailurl(std::string* thumbnailurl) {
  if (thumbnailurl != nullptr) {
    
  } else {
    
  }
  _impl_.thumbnailurl_.SetAllocated(thumbnailurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailurl_.IsDefault()) {
    _impl_.thumbnailurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusRemoteContent.thumbnailUrl)
}

// int64 fileSize = 5;
inline void CavrnusRemoteContent::clear_filesize() {
  _impl_.filesize_ = int64_t{0};
}
inline int64_t CavrnusRemoteContent::_internal_filesize() const {
  return _impl_.filesize_;
}
inline int64_t CavrnusRemoteContent::filesize() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRemoteContent.fileSize)
  return _internal_filesize();
}
inline void CavrnusRemoteContent::_internal_set_filesize(int64_t value) {
  
  _impl_.filesize_ = value;
}
inline void CavrnusRemoteContent::set_filesize(int64_t value) {
  _internal_set_filesize(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.fileSize)
}

// string fileSizeString = 6;
inline void CavrnusRemoteContent::clear_filesizestring() {
  _impl_.filesizestring_.ClearToEmpty();
}
inline const std::string& CavrnusRemoteContent::filesizestring() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRemoteContent.fileSizeString)
  return _internal_filesizestring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CavrnusRemoteContent::set_filesizestring(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filesizestring_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.fileSizeString)
}
inline std::string* CavrnusRemoteContent::mutable_filesizestring() {
  std::string* _s = _internal_mutable_filesizestring();
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRemoteContent.fileSizeString)
  return _s;
}
inline const std::string& CavrnusRemoteContent::_internal_filesizestring() const {
  return _impl_.filesizestring_.Get();
}
inline void CavrnusRemoteContent::_internal_set_filesizestring(const std::string& value) {
  
  _impl_.filesizestring_.Set(value, GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::_internal_mutable_filesizestring() {
  
  return _impl_.filesizestring_.Mutable(GetArenaForAllocation());
}
inline std::string* CavrnusRemoteContent::release_filesizestring() {
  // @@protoc_insertion_point(field_release:ServerData.CavrnusRemoteContent.fileSizeString)
  return _impl_.filesizestring_.Release();
}
inline void CavrnusRemoteContent::set_allocated_filesizestring(std::string* filesizestring) {
  if (filesizestring != nullptr) {
    
  } else {
    
  }
  _impl_.filesizestring_.SetAllocated(filesizestring, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesizestring_.IsDefault()) {
    _impl_.filesizestring_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerData.CavrnusRemoteContent.fileSizeString)
}

// bool isCachedOnDisk = 7;
inline void CavrnusRemoteContent::clear_iscachedondisk() {
  _impl_.iscachedondisk_ = false;
}
inline bool CavrnusRemoteContent::_internal_iscachedondisk() const {
  return _impl_.iscachedondisk_;
}
inline bool CavrnusRemoteContent::iscachedondisk() const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRemoteContent.isCachedOnDisk)
  return _internal_iscachedondisk();
}
inline void CavrnusRemoteContent::_internal_set_iscachedondisk(bool value) {
  
  _impl_.iscachedondisk_ = value;
}
inline void CavrnusRemoteContent::set_iscachedondisk(bool value) {
  _internal_set_iscachedondisk(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.isCachedOnDisk)
}

// repeated string tagKeys = 10;
inline int CavrnusRemoteContent::_internal_tagkeys_size() const {
  return _impl_.tagkeys_.size();
}
inline int CavrnusRemoteContent::tagkeys_size() const {
  return _internal_tagkeys_size();
}
inline void CavrnusRemoteContent::clear_tagkeys() {
  _impl_.tagkeys_.Clear();
}
inline std::string* CavrnusRemoteContent::add_tagkeys() {
  std::string* _s = _internal_add_tagkeys();
  // @@protoc_insertion_point(field_add_mutable:ServerData.CavrnusRemoteContent.tagKeys)
  return _s;
}
inline const std::string& CavrnusRemoteContent::_internal_tagkeys(int index) const {
  return _impl_.tagkeys_.Get(index);
}
inline const std::string& CavrnusRemoteContent::tagkeys(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRemoteContent.tagKeys)
  return _internal_tagkeys(index);
}
inline std::string* CavrnusRemoteContent::mutable_tagkeys(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRemoteContent.tagKeys)
  return _impl_.tagkeys_.Mutable(index);
}
inline void CavrnusRemoteContent::set_tagkeys(int index, const std::string& value) {
  _impl_.tagkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.tagKeys)
}
inline void CavrnusRemoteContent::set_tagkeys(int index, std::string&& value) {
  _impl_.tagkeys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.tagKeys)
}
inline void CavrnusRemoteContent::set_tagkeys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerData.CavrnusRemoteContent.tagKeys)
}
inline void CavrnusRemoteContent::set_tagkeys(int index, const char* value, size_t size) {
  _impl_.tagkeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerData.CavrnusRemoteContent.tagKeys)
}
inline std::string* CavrnusRemoteContent::_internal_add_tagkeys() {
  return _impl_.tagkeys_.Add();
}
inline void CavrnusRemoteContent::add_tagkeys(const std::string& value) {
  _impl_.tagkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerData.CavrnusRemoteContent.tagKeys)
}
inline void CavrnusRemoteContent::add_tagkeys(std::string&& value) {
  _impl_.tagkeys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerData.CavrnusRemoteContent.tagKeys)
}
inline void CavrnusRemoteContent::add_tagkeys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerData.CavrnusRemoteContent.tagKeys)
}
inline void CavrnusRemoteContent::add_tagkeys(const char* value, size_t size) {
  _impl_.tagkeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerData.CavrnusRemoteContent.tagKeys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CavrnusRemoteContent::tagkeys() const {
  // @@protoc_insertion_point(field_list:ServerData.CavrnusRemoteContent.tagKeys)
  return _impl_.tagkeys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CavrnusRemoteContent::mutable_tagkeys() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.CavrnusRemoteContent.tagKeys)
  return &_impl_.tagkeys_;
}

// repeated string tagValues = 11;
inline int CavrnusRemoteContent::_internal_tagvalues_size() const {
  return _impl_.tagvalues_.size();
}
inline int CavrnusRemoteContent::tagvalues_size() const {
  return _internal_tagvalues_size();
}
inline void CavrnusRemoteContent::clear_tagvalues() {
  _impl_.tagvalues_.Clear();
}
inline std::string* CavrnusRemoteContent::add_tagvalues() {
  std::string* _s = _internal_add_tagvalues();
  // @@protoc_insertion_point(field_add_mutable:ServerData.CavrnusRemoteContent.tagValues)
  return _s;
}
inline const std::string& CavrnusRemoteContent::_internal_tagvalues(int index) const {
  return _impl_.tagvalues_.Get(index);
}
inline const std::string& CavrnusRemoteContent::tagvalues(int index) const {
  // @@protoc_insertion_point(field_get:ServerData.CavrnusRemoteContent.tagValues)
  return _internal_tagvalues(index);
}
inline std::string* CavrnusRemoteContent::mutable_tagvalues(int index) {
  // @@protoc_insertion_point(field_mutable:ServerData.CavrnusRemoteContent.tagValues)
  return _impl_.tagvalues_.Mutable(index);
}
inline void CavrnusRemoteContent::set_tagvalues(int index, const std::string& value) {
  _impl_.tagvalues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.tagValues)
}
inline void CavrnusRemoteContent::set_tagvalues(int index, std::string&& value) {
  _impl_.tagvalues_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ServerData.CavrnusRemoteContent.tagValues)
}
inline void CavrnusRemoteContent::set_tagvalues(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagvalues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ServerData.CavrnusRemoteContent.tagValues)
}
inline void CavrnusRemoteContent::set_tagvalues(int index, const char* value, size_t size) {
  _impl_.tagvalues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ServerData.CavrnusRemoteContent.tagValues)
}
inline std::string* CavrnusRemoteContent::_internal_add_tagvalues() {
  return _impl_.tagvalues_.Add();
}
inline void CavrnusRemoteContent::add_tagvalues(const std::string& value) {
  _impl_.tagvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ServerData.CavrnusRemoteContent.tagValues)
}
inline void CavrnusRemoteContent::add_tagvalues(std::string&& value) {
  _impl_.tagvalues_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ServerData.CavrnusRemoteContent.tagValues)
}
inline void CavrnusRemoteContent::add_tagvalues(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tagvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ServerData.CavrnusRemoteContent.tagValues)
}
inline void CavrnusRemoteContent::add_tagvalues(const char* value, size_t size) {
  _impl_.tagvalues_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ServerData.CavrnusRemoteContent.tagValues)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CavrnusRemoteContent::tagvalues() const {
  // @@protoc_insertion_point(field_list:ServerData.CavrnusRemoteContent.tagValues)
  return _impl_.tagvalues_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CavrnusRemoteContent::mutable_tagvalues() {
  // @@protoc_insertion_point(field_mutable_list:ServerData.CavrnusRemoteContent.tagValues)
  return &_impl_.tagvalues_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ServerData

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_relay_5ftypes_2eproto
